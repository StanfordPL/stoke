# Ukrainian translation for coreutils.
# Copyright (C) 2006 Free Software Foundation, Inc.
# This file is put in the public domain.
#
# Maxim Dziumanenko <dziumanenko@gmail.com>, 2007-2009.
# sevenfourk <sevenfourk@gmail.com>, 2009.
# Yuri Chornoivan <yurchor@ukr.net>, 2011, 2012, 2013.
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.20-pre3\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2013-02-14 15:56+0000\n"
"PO-Revision-Date: 2013-02-11 22:58+0200\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian <translation-team-uk@lists.sourceforge.net>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#: lib/argmatch.c:133
#, c-format
msgid "invalid argument %s for %s"
msgstr "неправильний аргумент %s для %s"

#: lib/argmatch.c:134
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "неоднозначний аргумент %s для %s"

#: lib/argmatch.c:153
msgid "Valid arguments are:"
msgstr "Допустимі аргументи:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "помилка при закритті файла"

#: lib/closeout.c:112 src/base64.c:112 src/base64.c:124 src/base64.c:130
#: src/base64.c:171 src/base64.c:227 src/cat.c:186 src/cat.c:202 src/cat.c:286
#: src/cksum.c:251 src/expand.c:329 src/expand.c:354 src/head.c:297
#: src/head.c:347 src/head.c:763 src/head.c:804 src/mktemp.c:351 src/od.c:925
#: src/paste.c:160 src/shuf.c:368 src/split.c:741 src/split.c:978
#: src/split.c:983 src/tail.c:349 src/tail.c:1201 src/tail.c:1307
#: src/tail.c:2204 src/tr.c:1620 src/tr.c:1845 src/tr.c:1939
#: src/unexpand.c:426 src/unexpand.c:442
#, c-format
msgid "write error"
msgstr "помилка запису"

#: lib/copy-acl.c:611 src/copy.c:1165 src/copy.c:2617
#, c-format
msgid "preserving permissions for %s"
msgstr "збереження прав доступу для %s"

#: lib/error.c:188
msgid "Unknown system error"
msgstr "Невідома системна помилка"

#: lib/file-type.c:38
msgid "regular empty file"
msgstr "звичайний порожній файл"

#: lib/file-type.c:38
msgid "regular file"
msgstr "звичайний файл"

#: lib/file-type.c:41
msgid "directory"
msgstr "каталог"

#: lib/file-type.c:44
msgid "block special file"
msgstr "файл блочного пристрою"

#: lib/file-type.c:47
msgid "character special file"
msgstr "файл символьного пристрою"

#: lib/file-type.c:50
msgid "fifo"
msgstr "fifo"

#: lib/file-type.c:53
msgid "symbolic link"
msgstr "символічне посилання"

#: lib/file-type.c:56
msgid "socket"
msgstr "сокет"

#: lib/file-type.c:59
msgid "message queue"
msgstr "черга повідомлень"

#: lib/file-type.c:62
msgid "semaphore"
msgstr "семафор"

#: lib/file-type.c:65
msgid "shared memory object"
msgstr "об'єкт спільній пам'яті"

#: lib/file-type.c:68
msgid "typed memory object"
msgstr "об'єкт типізованої пам'яті"

#: lib/file-type.c:70
msgid "weird file"
msgstr "дивний файл"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "Сімейство адрес не підтримується для цього вузла"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "Тимчасова помилка розв'язання назв"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "Неправильне значення ai_flags"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "Критична помилка при розв'язанні назв"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "ai_family не підтримується"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "Помилка виділення пам'яті"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "З даною назвою вузла не пов'язано жодної адреси"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "Невідома назва чи сервіс"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "Servname не підтримується для ai_socktype"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "ai_socktype не підтримується"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "Системна помилка"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "Буфер аргументів надто малий"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "Триває обробка запиту"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "Запит скасовано"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "Запит не скасовано"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "Всі запити завершені"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "Перервано за сигналом"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "Неправильно закодований рядок параметрів"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "Невідома помилка"

#: lib/getopt.c:547 lib/getopt.c:576
#, c-format
msgid "%s: option '%s' is ambiguous; possibilities:"
msgstr "%s: неоднозначний параметр «%s»; можливі варіанти:"

#: lib/getopt.c:624 lib/getopt.c:628
#, c-format
msgid "%s: option '--%s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «--%s» не передбачено\n"

#: lib/getopt.c:637 lib/getopt.c:642
#, c-format
msgid "%s: option '%c%s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «%c%s» не передбачено\n"

#: lib/getopt.c:685 lib/getopt.c:704
#, c-format
msgid "%s: option '--%s' requires an argument\n"
msgstr "%s: до параметра «--%s» слід додати аргумент\n"

#: lib/getopt.c:742 lib/getopt.c:745
#, c-format
msgid "%s: unrecognized option '--%s'\n"
msgstr "%s: невідомий параметр «--%s»\n"

#: lib/getopt.c:753 lib/getopt.c:756
#, c-format
msgid "%s: unrecognized option '%c%s'\n"
msgstr "%s: невідомий параметр «%c%s»\n"

#: lib/getopt.c:805 lib/getopt.c:808
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: некоректний параметр — «%c»\n"

#: lib/getopt.c:861 lib/getopt.c:878 lib/getopt.c:1088 lib/getopt.c:1106
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: до параметра слід додати аргумент — «%c»\n"

#: lib/getopt.c:934 lib/getopt.c:950
#, c-format
msgid "%s: option '-W %s' is ambiguous\n"
msgstr "%s: параметр «-W %s» не є однозначним\n"

#: lib/getopt.c:974 lib/getopt.c:992
#, c-format
msgid "%s: option '-W %s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «-W %s» не передбачено\n"

#: lib/getopt.c:1013 lib/getopt.c:1031
#, c-format
msgid "%s: option '-W %s' requires an argument\n"
msgstr "%s: до параметра «-W %s» слід додати аргумент\n"

#: lib/mkdir-p.c:196 src/install.c:484
#, c-format
msgid "cannot change permissions of %s"
msgstr "Не вдалося змінити права доступу до %s"

#: lib/mkdir-p.c:206 src/copy.c:2266 src/install.c:709 src/install.c:722
#, c-format
msgid "cannot create directory %s"
msgstr "Не вдалося створити каталог %s"

#: lib/obstack.c:413 lib/obstack.c:415 lib/xalloc-die.c:34 src/csplit.c:219
#: src/split.c:929 src/tac.c:434
#, c-format
msgid "memory exhausted"
msgstr "пам'ять вичерпано"

# c-format
#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "не вдалося зберегти поточний робочий каталог"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "не вдалося повернутись до початкового робочого каталогу"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:312
msgid "`"
msgstr "«"

#: lib/quotearg.c:313
msgid "'"
msgstr "»"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s: кінець файла"

#: lib/regcomp.c:131
msgid "Success"
msgstr "Виконано"

#: lib/regcomp.c:134
msgid "No match"
msgstr "Немає збігів"

#: lib/regcomp.c:137
msgid "Invalid regular expression"
msgstr "Неправильний регулярний вираз"

#: lib/regcomp.c:140
msgid "Invalid collation character"
msgstr "Неправильний символ порівняння"

#: lib/regcomp.c:143
msgid "Invalid character class name"
msgstr "Некоректна назва класу символу"

#: lib/regcomp.c:146
msgid "Trailing backslash"
msgstr "Зворотна коса риска наприкінці"

#: lib/regcomp.c:149
msgid "Invalid back reference"
msgstr "Неправильне зворотне посилання"

#: lib/regcomp.c:152
msgid "Unmatched [ or [^"
msgstr "Непарна [ чи [^"

#: lib/regcomp.c:155
msgid "Unmatched ( or \\("
msgstr "Непарна ( чи \\("

#: lib/regcomp.c:158
msgid "Unmatched \\{"
msgstr "Непарна \\{"

#: lib/regcomp.c:161
msgid "Invalid content of \\{\\}"
msgstr "Неприпустимий вміст \\{\\}"

#: lib/regcomp.c:164
msgid "Invalid range end"
msgstr "Неправильний кінець діапазону"

#: lib/regcomp.c:167
msgid "Memory exhausted"
msgstr "Скінчилась пам'ять"

#: lib/regcomp.c:170
msgid "Invalid preceding regular expression"
msgstr "Некоректний попередній регулярний вираз"

#: lib/regcomp.c:173
msgid "Premature end of regular expression"
msgstr "Передчасний кінець регулярного виразу"

#: lib/regcomp.c:176
msgid "Regular expression too big"
msgstr "Розмір виразу надто великий"

#: lib/regcomp.c:179
msgid "Unmatched ) or \\)"
msgstr "Непарна ) чи \\)"

#: lib/regcomp.c:704
msgid "No previous regular expression"
msgstr "Відсутній попередній регулярний вираз"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "небезпечно рекурсивно обробляти %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "небезпечно рекурсивно обробляти %s (те ж саме, що й %s)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr ""
"використовуйте --no-preserve-root, щоб скасувати попередження про небезпеку"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:147
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:160
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-mode-acl.c:697 src/copy.c:2289 src/cp.c:516
#, c-format
msgid "setting permissions for %s"
msgstr "встановлення прав доступу для %s"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "Від'єднання"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "Переривання"

#: lib/siglist.h:37
msgid "Quit"
msgstr "Вихід"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "Помилкова інструкція"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "Переривання на точці зупину"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "Перервано"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "Помилка обчислень з рухомою комою"

#: lib/siglist.h:52
msgid "Killed"
msgstr "Вбито"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "Помилка каналу обміну даними"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "Помилка адресування"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "Канал обірвано"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "Сигнал таймера"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "Припинено"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "Термінова дія з введення-виведення"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "Зупинено (сигнал)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "Зупинено"

#: lib/siglist.h:79
msgid "Continued"
msgstr "Поновлено"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "Дочірній процес завершив роботу"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "Зупинено (ввід з термінала)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "Зупинено (вивід на термінал)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "Можливе введення-виведення"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "Перевищено обмеження часу використання процесора"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "Перевищено обмеження на розмір файла"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "Збіг час на віртуальному таймері"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "Збіг час профілювання"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "Зміна вікна"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "Визначений користувачем сигнал 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "Визначений користувачем сигнал 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "Пастка емулятора"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "Помилковий системний виклик"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "Помилка роботи зі стеком"

#: lib/siglist.h:126
msgid "Information request"
msgstr "Інформаційний запит"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "Відмова живлення"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "Втрачено ресурс"

#: lib/spawn-pipe.c:140 lib/spawn-pipe.c:143 lib/spawn-pipe.c:264
#: lib/spawn-pipe.c:267
#, c-format
msgid "cannot create pipe"
msgstr "не вдалося створити канал"

#: lib/spawn-pipe.c:234 lib/spawn-pipe.c:348 lib/wait-process.c:282
#: lib/wait-process.c:356
#, c-format
msgid "%s subprocess failed"
msgstr "помилка підпроцесу %s"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "Сигнал реального часу %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "Невідомий сигнал %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "функцію iconv неможливо використати"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "функція iconv недоступна"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "символ поза діапазоном"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "неможливо перетворити U+%04X у локальне кодування"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "неможливо перетворити U+%04X у локальне кодування: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "неправильний користувач"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "неправильна група"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "неправильна специфікація"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "Неможливо вивести повідомлення про помилку"

#: lib/version-etc.c:74
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "Пакування виконано %s (%s)\n"

#: lib/version-etc.c:77
#, c-format
msgid "Packaged by %s\n"
msgstr "Пакування виконано %s\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:84
msgid "(C)"
msgstr "©"

#: lib/version-etc.c:86
msgid ""
"\n"
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
"\n"
msgstr ""
"\n"
"Умови ліцензування викладено у GPLv3+: GNU GPL версії 3 або новішій, <http://"
"gnu.org/licenses/gpl.html>\n"
"Це вільне програмне забезпечення: ви можете вільно змінювати і поширювати "
"його.\n"
"Вам не надається ЖОДНИХ ГАРАНТІЙ, окрім гарантій передбачених "
"законодавством.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:102
#, c-format
msgid "Written by %s.\n"
msgstr "Автор програми %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:106
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Автор програми %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:110
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Автор програми %s, %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:117
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s\n"
"та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:124
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:131
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:139
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:147
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:156
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:167
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s, %s та інші.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:245
#, c-format
msgid ""
"\n"
"Report bugs to: %s\n"
msgstr ""
"\n"
"Про вади повідомляйте за такою адресою: %s\n"

#: lib/version-etc.c:247
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "Про вади у %s повідомляйте на адресу %s\n"

#: lib/version-etc.c:251 src/system.h:573
#, c-format
msgid "%s home page: <%s>\n"
msgstr "Домашня сторінка %s: <%s>\n"

#: lib/version-etc.c:253
#, c-format
msgid "%s home page: <http://www.gnu.org/software/%s/>\n"
msgstr "%s домашня сторінка: <http://www.gnu.org/software/%s/>\n"

#: lib/version-etc.c:256 src/system.h:574
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Загальна довідка з ПЗ GNU: <http://www.gnu.org/gethelp/>\n"

#: lib/w32spawn.h:43
#, c-format
msgid "_open_osfhandle failed"
msgstr "Помилка _open_osfhandle"

#: lib/w32spawn.h:84
#, c-format
msgid "cannot restore fd %d: dup2 failed"
msgstr "не вдалося відновити файловий дескриптор %d: помилка dup2"

#: lib/wait-process.c:223 lib/wait-process.c:255 lib/wait-process.c:317
#, c-format
msgid "%s subprocess"
msgstr "дочірній процес %s"

#: lib/wait-process.c:274 lib/wait-process.c:346
#, c-format
msgid "%s subprocess got fatal signal %d"
msgstr "дочірнім процесом %s отримано сигнал щодо аварійного завершення %d"

#: lib/xfreopen.c:35
msgid "stdin"
msgstr "stdin"

#: lib/xfreopen.c:36
msgid "stdout"
msgstr "stdout"

#: lib/xfreopen.c:37
msgid "stderr"
msgstr "stderr"

#: lib/xfreopen.c:38
msgid "unknown stream"
msgstr "невідомий потік"

#: lib/xfreopen.c:39
#, c-format
msgid "failed to reopen %s with mode %s"
msgstr "не вдалося повторно відкрити %s у режимі %s"

#: lib/xmemcoll.c:39 src/expr.c:886
#, c-format
msgid "string comparison failed"
msgstr "помилка порівняння рядків"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Помилка порівняння рядків %s та %s."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "не вдалося виконати форматований вивід"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "некоректний аргумент %s%s — '%s'"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "некоректний суфікс у аргументі %s%s: '%s'"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s, аргумент '%s' є занадто об’ємним"

#. This is a proper name. See the gettext manual, section Names.
#: src/base64.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#: src/base64.c:60
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"Base64 encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"
"Кодування чи декодування файла чи стандартного потоку вводу у форматі\n"
"Base64, і запис у стандартний потік виводу.\n"

#: src/base64.c:67
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode          декодувати дані\n"
"  -i, --ignore-garbage  під час декодування пропускати символи поза абеткою\n"
"  -w, --wrap=СТОВПЧИК   переносити кодовані рядки після символу СТОВПЧИК "
"(типово 76).\n"
"                          0 вимикає перенесення рядків.\n"
"\n"

#: src/base64.c:76 src/cat.c:110 src/fmt.c:295 src/shuf.c:70 src/sum.c:70
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Якщо вхідний файл не вказаний, або якщо вказано символ -,\n"
"використовується стандартний ввід.\n"

#: src/base64.c:79
msgid ""
"\n"
"The data are encoded as described for the base64 alphabet in RFC 3548.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal base64 alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Дані закодовані символами з алфавіту base64, відповідно до RFC 3548. При\n"
"декодуванні ввід може містити також переведення рядків окрім байтів\n"
"формального алфавіту base64.  Вказуйте ключ --ignore-garbage, щоб\n"
"спробувати ігнорувати неалфавітні знаки в закодованому потоці.\n"

#: src/base64.c:174 src/base64.c:211 src/csplit.c:263 src/csplit.c:1437
#: src/join.c:451 src/shuf.c:156 src/shuf.c:360 src/tac-pipe.c:74
#: src/tee.c:204 src/tr.c:1644
#, c-format
msgid "read error"
msgstr "помилка читання"

#: src/base64.c:230
#, c-format
msgid "invalid input"
msgstr "неправильні вхідні дані"

#: src/base64.c:267
#, c-format
msgid "invalid wrap size: %s"
msgstr "неправильна величина переносу: %s"

#: src/base64.c:286 src/basename.c:174 src/comm.c:435 src/cp.c:605
#: src/date.c:445 src/dircolors.c:447 src/du.c:964 src/hostid.c:74
#: src/hostname.c:111 src/id.c:169 src/install.c:930 src/join.c:961
#: src/link.c:85 src/ln.c:563 src/logname.c:71 src/mknod.c:156 src/mv.c:449
#: src/nproc.c:119 src/od.c:1808 src/ptx.c:2080 src/seq.c:546 src/shuf.c:319
#: src/shuf.c:338 src/sort.c:4531 src/split.c:1326 src/tr.c:1797
#: src/tsort.c:555 src/tty.c:112 src/uname.c:251 src/uniq.c:453 src/uniq.c:470
#: src/unlink.c:81 src/uptime.c:250 src/users.c:146 src/wc.c:666 src/who.c:827
#: src/whoami.c:79
#, c-format
msgid "extra operand %s"
msgstr "зайвий операнд %s"

#: src/base64.c:318 src/cat.c:781
#, c-format
msgid "closing standard input"
msgstr "закривається стандартний потік вводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:37 src/chmod.c:39 src/chown.c:36
#: src/comm.c:38 src/cp.c:57 src/csplit.c:42 src/cut.c:45 src/date.c:39
#: src/dd.c:45 src/df.c:43 src/dirname.c:32 src/du.c:54 src/env.c:33
#: src/expand.c:49 src/fold.c:36 src/groups.c:35 src/head.c:45 src/id.c:39
#: src/install.c:50 src/ln.c:42 src/ls.c:124 src/mkdir.c:36 src/mkfifo.c:33
#: src/mknod.c:34 src/mv.c:42 src/nice.c:39 src/nl.c:41 src/paste.c:53
#: src/pathchk.c:33 src/pinky.c:37 src/printenv.c:44 src/printf.c:63
#: src/rm.c:42 src/rmdir.c:38 src/stty.c:66 src/sum.c:38 src/tac.c:59
#: src/tail.c:70 src/tee.c:36 src/touch.c:44 src/tty.c:43 src/uname.c:60
#: src/unexpand.c:50 src/uniq.c:42 src/uptime.c:46 src/users.c:36 src/wc.c:51
#: src/who.c:49 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"Використання: %s НАЗВА [СУФІКС]\n"
"  чи:  %s КЛЮЧ... НАЗВА...\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"Вивести НАЗВУ з вилученням компонента каталогу на початку рядка.\n"
"Також вилучити завершальний СУФІКС (якщо вказано).\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX\n"
"  -z, --zero           separate output with NUL rather than newline\n"
msgstr ""
"  -a, --multiple       увімкнути підтримку декількох аргументів, вважати "
"кожен з них НАЗВОЮ\n"
"  -s, --suffix=СУФІКС  вилучити кінцевий СУФІКС\n"
"  -z, --zero           відокремлювати пункти у виведенні символом NUL, а не "
"символом нового рядка\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/sort          -> «sort»\n"
"  %s include/stdio.h .h     -> «stdio»\n"
"  %s -s .h include/stdio.h  -> «stdio»\n"
"  %s -a any/str1 any/str2   -> «str1», потім «str2»\n"

#: src/basename.c:168 src/chcon.c:537 src/chgrp.c:277 src/chmod.c:526
#: src/chown.c:280 src/chroot.c:197 src/comm.c:427 src/csplit.c:1371
#: src/dirname.c:116 src/expr.c:326 src/join.c:1147 src/link.c:77
#: src/mkdir.c:182 src/mkfifo.c:107 src/mknod.c:145 src/nohup.c:111
#: src/pathchk.c:148 src/printf.c:674 src/readlink.c:145 src/realpath.c:236
#: src/rm.c:321 src/rmdir.c:223 src/seq.c:540 src/setuidgid.c:137
#: src/sleep.c:119 src/stat.c:1499 src/stdbuf.c:345 src/tr.c:1782
#: src/unlink.c:75
#, c-format
msgid "missing operand"
msgstr "відсутній операнд"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:56 src/df.c:42 src/du.c:53 src/factor.c:110
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:37 src/ls.c:123 src/rm.c:43 src/split.c:50
#: src/tee.c:35 src/uniq.c:41
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1209 src/expand.c:103 src/fold.c:66 src/head.c:105
#: src/ls.c:4720 src/nl.c:175 src/paste.c:435 src/pr.c:2752 src/sum.c:58
#: src/tac.c:133 src/tail.c:258 src/tee.c:62 src/unexpand.c:113
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"

#: src/cat.c:92
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"Конкатенація файлів чи стандартного вводу до стандартного потоку виводу.\n"
"\n"
"  -A, --show-all           еквівалент -vET\n"
"  -b, --number-nonblank    кількість непорожніх рядків виводу\n"
"  -e                       еквівалент -vE\n"
"  -E, --show-ends          показувати $ наприкінці кожного рядка\n"
"  -n, --number             кількість усіх рядків виводу\n"
"  -s, --squeeze-blank      не більше ніж один порожній рядок\n"

#: src/cat.c:102
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       еквівалент -vT\n"
"  -T, --show-tabs          відображати символи табуляцій як  ^I\n"
"  -u                       (ігнорується)\n"
"  -v, --show-nonprinting   використовувати нотацію ^ та M-, за винятком\n"
"                           переведення рядка та табуляції\n"

#: src/cat.c:114
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s f - g  Виводить вміст f, потім стандартний потік вводу, потім вміст g.\n"
"  %s        Копіює дані зі стандартного потоку вводу у стандартний вивід.\n"

#: src/cat.c:326
#, c-format
msgid "cannot do ioctl on %s"
msgstr "помилка ioctl на %s"

#: src/cat.c:637 src/dd.c:2217 src/sort.c:383 src/tee.c:165 src/yes.c:86
#, c-format
msgid "standard output"
msgstr "стандартний вивід"

#: src/cat.c:716
#, c-format
msgid "%s: input file is output file"
msgstr "%s: вхідний файл є файлом виводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:36 src/runcon.c:62
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/chgrp.c:38 src/chmod.c:40 src/chown.c:37 src/cp.c:58
#: src/cut.c:46 src/dirname.c:33 src/du.c:56 src/head.c:46 src/hostid.c:33
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:43 src/nohup.c:37 src/od.c:36
#: src/pathchk.c:34 src/pwd.c:31 src/rm.c:44 src/setuidgid.c:38 src/sleep.c:34
#: src/sync.c:31 src/tail.c:72 src/tr.c:37 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:100 src/runcon.c:207 src/runcon.c:238
#, c-format
msgid "failed to create security context: %s"
msgstr "не вдалося створити контексту безпеки: %s"

#: src/chcon.c:112
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "не вдалося встановити %s контекст безпеки компоненту %s"

#: src/chcon.c:156 src/chcon.c:546 src/copy.c:2227 src/runcon.c:221
#: src/stat.c:702
#, c-format
msgid "failed to get security context of %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/chcon.c:166
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "не вдалося застосувати частковий контекст для непозначеного файла %s"

#: src/chcon.c:193
#, c-format
msgid "failed to change context of %s to %s"
msgstr "не вдалося змінити контекст %s на %s"

#: src/chcon.c:255 src/chmod.c:216 src/chown-core.c:325 src/copy.c:581
#: src/du.c:457 src/ls.c:2981
#, c-format
msgid "cannot access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/chcon.c:265 src/chmod.c:229 src/chown-core.c:338 src/du.c:437
#, c-format
msgid "cannot read directory %s"
msgstr "не вдалося прочитати каталог %s"

#: src/chcon.c:292
#, c-format
msgid "changing security context of %s\n"
msgstr "зміна контексту безпеки для %s\n"

#: src/chcon.c:326 src/chmod.c:346 src/chown-core.c:539 src/remove.c:562
#, c-format
msgid "fts_read failed"
msgstr "помилка при операції fts_read"

#: src/chcon.c:337 src/chmod.c:357 src/chown-core.c:551 src/du.c:642
#: src/remove.c:576
#, c-format
msgid "fts_close failed"
msgstr "помилка fts_close"

#: src/chcon.c:351
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання:  %s [КЛЮЧ]... КОНТЕКСТ ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... [-u КОРИСТУВАЧ] [-r РОЛЬ] [-l ДІАПАЗОН] [-t ТИП] "
"ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chcon.c:357
msgid ""
"Change the security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"Змінює контекст безпеки кожного файла ФАЙЛ на КОНТЕКСТ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛа на контекст "
"ЗФАЙЛа.\n"

#: src/chcon.c:364 src/chgrp.c:123 src/chown.c:94
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      впливає на ціль кожного символічного посилання,\n"
"                         а не на саме символічне посилання\n"
"  -h, --no-dereference   обробити символічні посилання замість файлів, на "
"які вони посилаються\n"

#: src/chcon.c:369
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=КОРИСТУВАЧ  встановити користувача КОРИСТУВАЧ у цільовому "
"контексті безпеки\n"
"  -r, --role=РОЛЬ        встановити роль РОЛЬ у цільовому контексті безпеки\n"
"  -t, --type=ТИП         встановити тип ТИП у цільовому контексті безпеки\n"
"  -l, --range=ДІАПАЗОН   встановити діапазон ДІАПАЗОН у цільовому контексті "
"безпеки\n"

#: src/chcon.c:375 src/chgrp.c:132 src/chmod.c:387 src/chown.c:110
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root  не трактувати '/' особливим чином (типово)\n"
"      --preserve-root    перешкоджати рекурсивному виконанню на '/'\n"

#: src/chcon.c:379
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=ЗФАЙЛА використовувати контекст ЗФАЙЛА замість явного\n"
"                         вказування КОНТЕКСТ\n"

#: src/chcon.c:383 src/chgrp.c:140 src/chown.c:118
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        обробляти файли і каталоги рекурсивно\n"

#: src/chcon.c:386
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chcon.c:389 src/chgrp.c:143 src/chown.c:121
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"Вказані нижче ключі впливають на спосіб обходу ієрархії каталогів при\n"
"заданому ключі -R.  Якщо вказано декілька цих ключів, діє\n"
"лише останній.\n"
"\n"
"  -H                     якщо аргумент командного рядка є символьним\n"
"                         посиланням на каталог, перейти за ним\n"
"  -L                     переходити за кожним символьним посиланням на\n"
"                         каталог\n"
"  -P                     не переходити за символьними посиланнями (типово)\n"
"\n"

#: src/chcon.c:518 src/chgrp.c:264 src/chown.c:267
#, c-format
msgid "-R --dereference requires either -H or -L"
msgstr "Для комбінації ключів -R --dereference слід вказати -H або -L"

#: src/chcon.c:524
#, c-format
msgid "-R -h requires -P"
msgstr "при вказуванні -R -h потрібно вказати -P"

#: src/chcon.c:539 src/chgrp.c:279 src/chmod.c:528 src/chown.c:282
#: src/comm.c:429 src/csplit.c:1373 src/join.c:1149 src/link.c:79
#: src/mknod.c:147 src/setuidgid.c:139 src/tr.c:1785
#, c-format
msgid "missing operand after %s"
msgstr "пропущений операнд після %s"

#: src/chcon.c:562 src/runcon.c:251
#, c-format
msgid "invalid context: %s"
msgstr "неправильний контекст: %s"

#: src/chcon.c:569
#, c-format
msgid "conflicting security context specifiers given"
msgstr "вказано конфліктні специфікатори контексту безпеки"

#: src/chcon.c:578 src/chgrp.c:287 src/chgrp.c:305 src/chmod.c:536
#: src/chmod.c:555 src/chown.c:290 src/chown.c:319 src/cp.c:431 src/cp.c:491
#: src/mv.c:97 src/pwd.c:273 src/rm.c:331 src/touch.c:347
#, c-format
msgid "failed to get attributes of %s"
msgstr "помилка отримання атрибутів %s"

#: src/chgrp.c:92
#, c-format
msgid "invalid group: %s"
msgstr "неправильна група: %s"

#: src/chgrp.c:108
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ГРУПА ФАЙЛ...\n"
"  чи:  %s [КЛЮЧ]... --reference=ЗФАЙЛА ФАЙЛ...\n"

#: src/chgrp.c:113
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити групу кожного файла ФАЙЛ на ГРУПУ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛА на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chgrp.c:118 src/chmod.c:382 src/chown.c:89
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          подібний до verbose, але повідомити про них, лише "
"якщо внесено зміни\n"
"  -f, --silent, --quiet  придушити всі повідомлення про помилки\n"
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chgrp.c:128 src/chown.c:99
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (діє лише на системі з підтримкою зміни прав\n"
"                         власності символічних посилань)\n"

#: src/chgrp.c:136
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=ЗФАЙЛа використовувати групу ЗФАЙЛа замість явного\n"
"                         вказування ГРУПИ\n"

#: src/chgrp.c:158
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s staff /u      Змінює групу /u на \"staff\".\n"
"  %s -hR staff /u  Змінює групу /u та вкладених файлів на \"staff\".\n"

#: src/chmod.c:126
#, c-format
msgid "getting new attributes of %s"
msgstr "отримуються нові атрибути %s"

#: src/chmod.c:149 src/chown-core.c:147
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr ""
"ані символьне посилання %s, ані об'єкт на який воно вказує, не були змінені\n"

#: src/chmod.c:163
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "режим %s змінено з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:166
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "не вдалося змінити режим %s з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:169
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "права доступу %s залишені як %04lo (%s)\n"

#: src/chmod.c:236
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "обробка небезпечного символьного посилання %s неможлива"

#: src/chmod.c:276
#, c-format
msgid "changing permissions of %s"
msgstr "зміна прав доступу для %s"

#: src/chmod.c:311
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: нові права доступу %s, а не %s"

#: src/chmod.c:371
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... РЕЖИМ[,РЕЖИМ]... ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... ВІСІМК-РЕЖИМ ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chmod.c:377
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити режим для всіх файлів на РЕЖИМ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛУ на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chmod.c:391
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати режим ЗФАЙЛа, замість значень "
"РЕЖИМ\n"

#: src/chmod.c:394
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        змінювати файли і каталоги рекурсивно\n"

#: src/chmod.c:399
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"РЕЖИМ вказується у формі '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"

#: src/chmod.c:513
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "не можна використовувати разом ключі режиму та --reference"

#: src/chmod.c:544
#, c-format
msgid "invalid mode: %s"
msgstr "неправильний режим: %s"

#: src/chown-core.c:158
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "змінено власника %s з %s на %s\n"

#: src/chown-core.c:159
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "змінено групу %s з %s на %s\n"

#: src/chown-core.c:160
#, c-format
msgid "no change to ownership of %s\n"
msgstr "не змінений власник %s\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "не вдалося змінити власника %s з %s на %s\n"

#: src/chown-core.c:166
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "не вдалося змінити групу %s з %s на %s\n"

#: src/chown-core.c:167 src/chown-core.c:173
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "не вдалося змінити власника %s\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "не вдалося змінити власника %s на %s\n"

#: src/chown-core.c:172
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "помилка зміни групи %s на %s\n"

#: src/chown-core.c:180
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "власник %s залишений як %s\n"

#: src/chown-core.c:181
#, c-format
msgid "group of %s retained as %s\n"
msgstr "група %s залишена як %s\n"

#: src/chown-core.c:182
#, c-format
msgid "ownership of %s retained\n"
msgstr "власник %s залишений без змін\n"

#: src/chown-core.c:379
#, c-format
msgid "cannot dereference %s"
msgstr "не вдалося перейти за символьним посиланням %s"

#: src/chown-core.c:467
#, c-format
msgid "changing ownership of %s"
msgstr "зміна власника %s"

#: src/chown-core.c:468
#, c-format
msgid "changing group of %s"
msgstr "зміна групи для %s"

#: src/chown.c:79
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВЛАСНИК][:[ГРУПА]] ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chown.c:84
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"Змінити власника і/або групу для кожного з ФАЙЛів на ВЛАСНИКА і/або ГРУПУ.\n"
"З ключем  --reference, змінити власника і групу всіх ФАЙЛів на значення "
"ЗФАЙЛа.\n"

#: src/chown.c:103
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=ПОТОЧНИЙ_ВЛАСНИК:ПОТОЧНА_ГРУПА\n"
"                         змінює власника та/або групу кожного файла\n"
"                         лише якщо поточний власник та/або група\n"
"                         відповідає вказаному виразу.\n"
"                         Як група, так і власник можуть бути опущені,\n"
"                         у цьому випадку відповідність атрибута\n"
"                         не обов'язкова.\n"

#: src/chown.c:114
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛа замість\n"
"                         явного вказування ВЛАСНИКА:ГРУПИ\n"

#: src/chown.c:136
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Власник не змінюється, якщо він не вказаний у аргументі.  Група також не\n"
"змінюється, якщо не вказана; але якщо після символьного ВЛАСНИКА стоїть\n"
"знак ':', вважається зміна групи на основну групу поточного\n"
"користувача.\n"
"ВЛАСНИК та ГРУПА можуть бути як числовими, так і символьними.\n"

#: src/chown.c:142
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s root /u        Змінює власника /u на \"root\".\n"
"  %s root:staff /u  То же, але ще міняє групу на \"staff\".\n"
"  %s -hR root /u    Змінює власника /u та вкладених файлів на \"root\".\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:34
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:97 src/install.c:576 src/setuidgid.c:110 src/setuidgid.c:120
#, c-format
msgid "invalid group %s"
msgstr "неправильна група %s"

#: src/chroot.c:109
#, c-format
msgid "invalid group list %s"
msgstr "некоректний список груп %s"

#: src/chroot.c:117
#, c-format
msgid "failed to set additional groups"
msgstr "не вдалося встановити додаткові групи"

#: src/chroot.c:132
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] НОВИЙКОРІНЬ [КОМАНДА [АРГУМЕНТ]...]\n"
"  або:  %s ПАРАМЕТР\n"

#: src/chroot.c:137
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ з вказаним кореневим каталогом.\n"
"\n"

#: src/chroot.c:142
msgid ""
"  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
"  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"  --userspec=КОР:ГРУПА   вказати користувача і групу (ід. або назву)\n"
"  --groups=СПИСОК_ГРУП   вказати додаткові групи у форматі гр1,гр2,…,грN\n"

#: src/chroot.c:149
msgid ""
"\n"
"If no command is given, run '${SHELL} -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"Якщо команду не вказано, виконати '${SHELL} -i' (default: '/bin/sh -i').\n"

#: src/chroot.c:202
#, c-format
msgid "cannot change root directory to %s"
msgstr "не вдалося змінити кореневий каталог на %s"

#: src/chroot.c:206
#, c-format
msgid "cannot chdir to root directory"
msgstr "не вдалося перейти до кореневого каталогу"

#: src/chroot.c:247
#, c-format
msgid "failed to set group-ID"
msgstr "не вдалося встановити ідентифікатор групи"

#: src/chroot.c:253
#, c-format
msgid "failed to set user-ID"
msgstr "не вдалося встановити ідентифікатор користувача"

#: src/chroot.c:275 src/nohup.c:236 src/setuidgid.c:212 src/stdbuf.c:365
#: src/timeout.c:454
#, c-format
msgid "failed to run command %s"
msgstr "не вдалося виконати команду %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:216
#, c-format
msgid "%s: file too long"
msgstr "%s: файл надто великий"

#: src/cksum.c:263
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ФАЙЛ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/cksum.c:268
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Виводить контрольну суму (CRC) та число байт для кожного ФАЙЛА.\n"
"\n"

#: src/comm.c:103 src/join.c:187
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ1 ФАЙЛ2\n"

#: src/comm.c:107
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Порівнює сортовані файли ФАЙЛ1 та ФАЙЛ2 по рядках.\n"

#: src/comm.c:110
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Якщо запущений без ключів виводить результат у три стовпчики. Перший\n"
"стовпчик містить рядки, унікальні для ФАЙЛА1, другий -- унікальні для\n"
"ФАЙЛА2, а третій -- спільні для обох файлів рядки.\n"

#: src/comm.c:116
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              не виводити стовпчик 1 (рядки, які є лише у ФАЙЛ1)\n"
"  -2              не виводити стовпчик 2 (рядки, які є лише у ФАЙЛ2)\n"
"  -3              не виводити стовпчик 3 (рядки, які є у обох файлах)\n"

#: src/comm.c:122
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order     перевіряти, що вхідний потік сортований, навіть\n"
"                      якщо усі вхідні рядки утворюють пари\n"
"  --nocheck-order   не перевіряти, що вхідний потік коректно сортований\n"

#: src/comm.c:128
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=РЯД  розділяти стовпчику вставляючи РЯД\n"

#: src/comm.c:133
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"Зауважте, що під час порівняння використовуються правила LC_COLLATE.\n"

#: src/comm.c:137
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s -12 файл1 файл2  Вивести лише рядки, які є спільними для файл1 і "
"файл2.\n"
"  %s -3 файл1 файл2   Вивести рядки у файл1, яких немає у файл2, і навпаки.\n"

#: src/comm.c:222
#, c-format
msgid "file %d is not in sorted order"
msgstr "файл %d не сортований"

#: src/comm.c:407
#, c-format
msgid "multiple delimiters specified"
msgstr "задано декілька розділювачів"

#: src/comm.c:411
#, c-format
msgid "empty %s not allowed"
msgstr "порожній рядок %s є неприпустимим"

#: src/copy.c:168 src/dd.c:1617 src/dd.c:1984 src/du.c:1085 src/head.c:148
#: src/head.c:261 src/head.c:333 src/head.c:537 src/head.c:619 src/head.c:699
#: src/head.c:757 src/head.c:781 src/tail.c:411 src/tail.c:499 src/tail.c:548
#: src/tail.c:641 src/tail.c:769 src/tail.c:817 src/tail.c:854 src/tail.c:1782
#: src/tail.c:1812 src/uniq.c:394
#, c-format
msgid "error reading %s"
msgstr "помилка читання %s"

#: src/copy.c:195 src/copy.c:346 src/copy.c:357 src/head.c:425
#, c-format
msgid "cannot lseek %s"
msgstr "не вдалося виконати lseek для %s"

#: src/copy.c:206 src/dd.c:2047 src/dd.c:2110 src/head.c:151
#, c-format
msgid "error writing %s"
msgstr "помилка запису %s"

#: src/copy.c:313
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s: не вдалося отримати дані щодо розширень"

#: src/copy.c:373
#, c-format
msgid "%s: write failed"
msgstr "%s: помилка під час спроби запису"

#: src/copy.c:442 src/copy.c:1083
#, c-format
msgid "failed to extend %s"
msgstr "не вдалося розширити %s"

#: src/copy.c:662
#, c-format
msgid "clearing permissions for %s"
msgstr "очищення прав доступу для %s"

#: src/copy.c:697 src/copy.c:2480 src/cp.c:329
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "не вдалося зберегти власника %s"

#: src/copy.c:723
#, c-format
msgid "failed to lookup file %s"
msgstr "не вдалося найти файл %s"

#: src/copy.c:728
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "не вдалося зберегти автора %s"

#: src/copy.c:804 src/csplit.c:640 src/du.c:971 src/fmt.c:451 src/head.c:854
#: src/sort.c:4543 src/split.c:1342 src/tail.c:1756 src/wc.c:678
#, c-format
msgid "cannot open %s for reading"
msgstr "не вдалося відкрити %s для читання"

#: src/copy.c:810 src/copy.c:972 src/dd.c:1554 src/dd.c:2122 src/dd.c:2261
#: src/tail.c:1592 src/tail.c:1658 src/truncate.c:140
#, c-format
msgid "cannot fstat %s"
msgstr "не вдалося виконати fstat для %s"

#: src/copy.c:820
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "пропущено файл %s, оскільки він був замінений під час копіювання"

#: src/copy.c:850
#, c-format
msgid "failed to get file system create context"
msgstr "не вдалося отримати контекст файлової системи для створення файлів"

#: src/copy.c:864
#, c-format
msgid "failed to set the security context of %s to %s"
msgstr "не вдалося встановити контекст безпеки %s на %s"

#: src/copy.c:881 src/copy.c:1579 src/copy.c:1782 src/copy.c:1940 src/ln.c:314
#: src/remove.c:263 src/remove.c:280 src/remove.c:405 src/remove.c:431
#, c-format
msgid "cannot remove %s"
msgstr "не вдалося вилучити %s"

#: src/copy.c:886 src/copy.c:1583 src/copy.c:1777 src/copy.c:1945
#: src/remove.c:375
#, c-format
msgid "removed %s\n"
msgstr "вилучено %s\n"

#: src/copy.c:926
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "запис через через висяче символьне посилання %s не виконується"

#: src/copy.c:964
#, c-format
msgid "cannot create regular file %s"
msgstr "не вдалося створити звичайний файл %s"

#: src/copy.c:985
#, c-format
msgid "failed to clone %s from %s"
msgstr "не вдалося клонувати %s з %s"

#: src/copy.c:1098 src/copy.c:2541
#, c-format
msgid "preserving times for %s"
msgstr "збереження відмітки про час %s"

#: src/copy.c:1175 src/copy.c:1181 src/head.c:862 src/touch.c:172
#: src/truncate.c:417
#, c-format
msgid "failed to close %s"
msgstr "не вдалося закрити %s"

#: src/copy.c:1471
#, c-format
msgid "%s: try to overwrite %s, overriding mode %04lo (%s)? "
msgstr "%s: намагатись переписати %s, незважаючи на права доступу %04lo (%s)? "

#: src/copy.c:1478
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: переписати %s? "

#: src/copy.c:1547
#, c-format
msgid " (backup: %s)"
msgstr " (резервна копія: %s)"

#: src/copy.c:1557
#, c-format
msgid "failed to restore the default file creation context"
msgstr "помилка при відновленні типового контексту при створенні файла"

#: src/copy.c:1589
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "не вдалося створити жорстке посилання %s на %s"

#: src/copy.c:1642 src/copy.c:1694 src/copy.c:2277 src/copy.c:2604
#: src/find-mount-point.c:84 src/install.c:678 src/realpath.c:145
#: src/stat.c:1239 src/truncate.c:363
#, c-format
msgid "cannot stat %s"
msgstr "не вдалося виконати stat для %s"

#: src/copy.c:1650
#, c-format
msgid "omitting directory %s"
msgstr "пропуск каталогу %s"

#: src/copy.c:1664
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "попередження: вхідний файл %s вказаний більше одного разу"

#: src/copy.c:1712 src/ln.c:246
#, c-format
msgid "%s and %s are the same file"
msgstr "%s та %s - один і той самий файл"

#: src/copy.c:1811
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "не можна перезаписати файл %s, що не є каталогом, каталогом %s"

#: src/copy.c:1829 src/ln.c:214
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "не переписується щойно створений %s %s"

#: src/copy.c:1847
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "не можна перезаписувати каталог %s файлом, що не є каталогом"

#: src/copy.c:1861
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "не можна перейменувати каталог на файл, що не є каталогом: %s -> %s"

#: src/copy.c:1891
#, c-format
msgid "backing up %s would destroy source;  %s not moved"
msgstr "збереження запасної копії %s знищить оригінал; %s не перенесений"

#: src/copy.c:1892
#, c-format
msgid "backing up %s would destroy source;  %s not copied"
msgstr "збереження запасної копії %s знищить оригінал; %s не скопійовано"

#: src/copy.c:1915 src/ln.c:276
#, c-format
msgid "cannot backup %s"
msgstr "не вдалося створити резервну копію для %s"

#: src/copy.c:1979
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "не буде копіюватися %s через щойно створене символьне посилання %s"

#: src/copy.c:2056
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "не вдалося скопіювати каталог, %s, у самого себе, %s"

#: src/copy.c:2073
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "жорстке посилання %s на каталог %s не буде створено"

#: src/copy.c:2123
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "не вдалося перенести %s у свій власний підкаталог, %s"

#: src/copy.c:2166
#, c-format
msgid "cannot move %s to %s"
msgstr "не вдалося перемістити %s у %s"

#: src/copy.c:2178
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"помилка при переміщенні з пристрою %s на пристрій %s: не вдалося вилучити "
"цільовий файл"

#: src/copy.c:2212 src/install.c:906 src/mkdir.c:188 src/mkfifo.c:113
#: src/mknod.c:166
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "помилка встановлення типового контексту для створення файлів %s"

#: src/copy.c:2246
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "не вдалося скопіювати циклічне символьне посилання %s"

#: src/copy.c:2355
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: відносні символьні посилання можна створювати лише у поточному каталозі"

#: src/copy.c:2362
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "не вдалося створити символьне посилання %s на %s"

#: src/copy.c:2416 src/mkfifo.c:132
#, c-format
msgid "cannot create fifo %s"
msgstr "не вдалося створити чергу %s"

#: src/copy.c:2425
#, c-format
msgid "cannot create special file %s"
msgstr "не вдалося створити спеціальній файл %s"

#: src/copy.c:2436 src/ls.c:3185 src/stat.c:921
#, c-format
msgid "cannot read symbolic link %s"
msgstr "не вдалося прочитати символьне посилання %s"

#: src/copy.c:2463
#, c-format
msgid "cannot create symbolic link %s"
msgstr "не вдалося створити символьне посилання %s"

#: src/copy.c:2495
#, c-format
msgid "%s has unknown file type"
msgstr "%s має невідомий тип файла"

#: src/copy.c:2644 src/ln.c:358
#, c-format
msgid "cannot un-backup %s"
msgstr "не вдалося відновити %s з резервної копії"

#: src/copy.c:2648
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (відновлення)\n"

#: src/cp.c:156 src/mv.c:286
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ЦІЛЬ\n"
"       або:    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або:    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"

#: src/cp.c:162
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "Копіює ДЖЕРЕЛО у ЦІЛЬ, або декілька ДЖЕРЕЛ у КАТАЛОГ.\n"

#: src/cp.c:168
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                те саме що та -dR --preserve=all\n"
"      --attributes-only        не копіювати даних файла, лише атрибути\n"
"      --backup[=CONTROL]       створити резервну копію перед вилученням\n"
"  -b                           те саме, що й --backup, але без аргументу\n"
"      --copy-contents          копіює зміст спеціальних файлів при\n"
"                               рекурсивному використанні\n"
"  -d                           те саме, що й --no-dereference --"
"preserve=link\n"

#: src/cp.c:177
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  якщо не можна відкрити існуючий файл,\n"
"                                 вилучити його та спробувати ще раз\n"
"                                 (буде проігноровано, якщо вказано\n"
"                                  параметр -n )\n"
"  -i, --interactive            запитувати підтвердження перед переписом\n"
"                                 (перевизначає раніше вказаний параметрі -"
"n )\n"
"  -H                           слідувати за символьним посиланням у ДЖЕРЕЛО\n"

#: src/cp.c:186
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   створювати жорсткі посилання, а не копіювати\n"
"  -L, --dereference            завжди слідувати за символічним посиланням у "
"ДЖЕРЕЛО\n"

#: src/cp.c:190
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             не переписувати існуючий файл (перевизначає\n"
"                                 попередній параметр -i)\n"
"  -P, --no-dereference         ніколи не йти за символічними посиланнями у "
"ДЖЕРЕЛО\n"

#: src/cp.c:195
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           те саме, що й --preserve=mode,ownership,"
"timestamps\n"
"      --preserve[=СПИС_АТТР]   зберігати вказані атрибути (типово:\n"
"                                 mode,ownership,timestamps), якщо можливо\n"
"                                 додаткові атрибути: context, links, xattr, "
"all\n"

#: src/cp.c:203
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=СПИС_АТТР  не зберігати вказані атрибути\n"
"      --parents                добавить вихідний шлях до КАТАЛОГУ\n"

#: src/cp.c:207
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          копіювати каталоги рекурсивно\n"
"      --reflink[=КОЛИ]         керувати копіями clone/CoW. Див. нижче.\n"
"      --remove-destination     вилучати кожен цільовий файл, перш ніж\n"
"                                 копіювати його (протилежність до --force)\n"

#: src/cp.c:213
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=КОЛИ            керує створенням розріджених файлів. Див. "
"нижче.\n"
"      --strip-trailing-slashes вилучає усі кінцеві похилі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"

#: src/cp.c:218
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link          створювати символьні посилання а не "
"копіювати\n"
"  -S, --suffix=СУФІКС          використовувати для запасних копій вказаний "
"СУФІКС\n"
"      --target-directory=КАТАЛОГ  скопіювати всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"

#: src/cp.c:224
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 копіювати лише тоді коли вихідний файл\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати що зроблено\n"
"  -x, --one-file-system        залишатись у межах однієї файлової системи\n"

#: src/cp.c:233
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
msgstr ""
"\n"
"Типово розріджені файли ДЖЕРЕЛА розпізнається за допомогою грубої\n"
"евристичної процедури та відповідно створюється розріджений файл\n"
"ПРИЗНАЧЕННЯ. Таку поведінку можна визначити за допомогою\n"
"параметра --sparse=auto. З параметром --sparse=always ПРТИЗНАЧЕННЯ\n"
"завжди створюється розрідженим, незалежно від того, чи містить\n"
"файл ДЖЕРЕЛА довгі послідовності нульових байтів.\n"
"Скористайтеся параметром --sparse=never для заборони створення розріджених\n"
"файлів.\n"
"\n"
"Якщо вказано параметр --reflink[=always], буде виконано полегшене "
"копіювання,\n"
"за якого блоки даних копіюватимуться лише у разі внесення змін. Якщо це\n"
"неможливо, копіювання зазнає невдачі або, якщо вказано --reflink=auto,\n"
"повернеться до стандартного режиму.\n"

#: src/cp.c:245 src/install.c:649 src/ln.c:420 src/mv.c:322
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Типовий суфікс для запасних копій ~, лише якщо не встановлена\n"
"змінна оточення SIMPLE_BACKUP_SUFFIX або ключ --suffix. Спосіб контролю\n"
"версій можна вказати ключем --backup або змінною оточення\n"
"VERSION_CONTROL. Можливі значення:\n"
"\n"

#: src/cp.c:252 src/install.c:656 src/ln.c:427 src/mv.c:329
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       ніколи не створювати резервних копій (навіть якщо\n"
"                  вказаний ключ --backup)\n"
"  numbered, t     створювати нумеровані копії\n"
"  existing, nil   якщо існують нумеровані копії, то створювати\n"
"                  нумеровані інакше створювати прості\n"
"  simple. never   завжди створювати прості копії\n"

#: src/cp.c:258
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"Коли вказані ключі -f та -b, та SOURCE збігається з DEST cp створює\n"
"резервну копію DEST.\n"

#: src/cp.c:317
#, c-format
msgid "failed to preserve times for %s"
msgstr "не вдалося зберегти мітки часу для %s"

#: src/cp.c:348
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "не вдалося зберегти права доступу для %s"

#: src/cp.c:475
#, c-format
msgid "cannot make directory %s"
msgstr "не вдалося створити каталог %s"

#: src/cp.c:524 src/cp.c:543
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s існує, але не є каталогом"

#: src/cp.c:570 src/cp.c:1069 src/install.c:402 src/install.c:844 src/ln.c:123
#: src/ln.c:181 src/ln.c:202 src/ln.c:515 src/mv.c:154 src/mv.c:400
#, c-format
msgid "failed to access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/cp.c:590 src/install.c:915 src/ln.c:546 src/mv.c:434 src/shred.c:1181
#: src/touch.c:429 src/truncate.c:354
#, c-format
msgid "missing file operand"
msgstr "пропущений операнд, що вказує файл"

#: src/cp.c:592 src/install.c:917 src/ln.c:560 src/mv.c:436
#, c-format
msgid "missing destination file operand after %s"
msgstr "після %s пропущений операнд, що вказує цільовий файл"

#: src/cp.c:601 src/install.c:926 src/mv.c:445
#, c-format
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"не можна використовувати водночас --target-directory (-t) і --no-target-"
"directory (-T)"

#: src/cp.c:617 src/cp.c:1072 src/install.c:404 src/install.c:847
#: src/install.c:939 src/ln.c:125 src/ln.c:518 src/ln.c:574 src/mv.c:403
#: src/mv.c:459
#, c-format
msgid "target %s is not a directory"
msgstr "вказана ціль %s не є каталогом"

#: src/cp.c:728
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "при заданому --parents ціль повинна бути каталогом"

#: src/cp.c:1064 src/install.c:839 src/ln.c:510 src/mv.c:395
#, c-format
msgid "multiple target directories specified"
msgstr "вказано декілька цільових каталогів"

#: src/cp.c:1110
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "не можна створювати жорстке та символьне посилання одночасно"

#: src/cp.c:1117 src/mv.c:466
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "параметри --backup і --no-clobber не можна використовувати одночасно"

#: src/cp.c:1123
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink можна використовувати лише разом з --sparse=auto"

#: src/cp.c:1131 src/install.c:900 src/ln.c:582 src/mv.c:474
msgid "backup type"
msgstr "тип резервної копії"

#: src/cp.c:1156
#, c-format
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "не можна зберігати контекст безпеки, якщо ядро не підтримує SELinux"

#: src/cp.c:1162
#, c-format
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr "не вдалося зберегти розширені атрибути, cp зібрано без підтримки xattr"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:41 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:531
#, c-format
msgid "input disappeared"
msgstr "ввід став недоступний"

#: src/csplit.c:660 src/csplit.c:671
#, c-format
msgid "%s: line number out of range"
msgstr "%s: номер рядка поза допустимими межами"

#: src/csplit.c:700
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: номер рядка поза допустимими межами"

#: src/csplit.c:703 src/csplit.c:752
#, c-format
msgid " on repetition %s\n"
msgstr " при повторі %s\n"

#: src/csplit.c:746
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: відповідність не знайдено"

#: src/csplit.c:810 src/csplit.c:850 src/nl.c:351 src/tac.c:273
#, c-format
msgid "error in regular expression search"
msgstr "помилка пошуку регулярного виразу"

#: src/csplit.c:983
#, c-format
msgid "write error for %s"
msgstr "помилка запису для %s"

#: src/csplit.c:1059
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: після розділювача очікується ціле число"

#: src/csplit.c:1075
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: при вказуванні числа повторів слід додати '}'"

#: src/csplit.c:1085
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s: між '{' та '}' має бути вказано ціле число"

#: src/csplit.c:1112
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: пропущено кінцевий роздільник '%c'"

#: src/csplit.c:1129
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: неприпустимий регулярний вираз: %s"

#: src/csplit.c:1162
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: неприпустимий шаблон"

#: src/csplit.c:1165
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: номер рядка повинен бути більше нуля"

#: src/csplit.c:1171
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "номер рядка %s менше номеру попереднього рядка, %s"

#: src/csplit.c:1177
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "попередження: номер рядка %s дорівнює попередньому номеру рядка"

#: src/csplit.c:1255
#, c-format
msgid "missing conversion specifier in suffix"
msgstr "пропущений специфікатор перетворення у суфіксі"

#: src/csplit.c:1261
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "неправильний специфікатор перетворення у суфіксі: %c"

#: src/csplit.c:1264
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "неправильний специфікатор перетворення у суфіксі: \\%.3o"

#: src/csplit.c:1269
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "некоректні прапорці у специфікації перетворення: %%%c%c"

#: src/csplit.c:1286
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "надто багато описів перетворення (%%) у суфіксі"

#: src/csplit.c:1300
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "пропущено опис перетворення (%%) у суфіксі"

#: src/csplit.c:1347
#, c-format
msgid "%s: invalid number"
msgstr "%s: неприпустимий число"

#: src/csplit.c:1451
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ ШАБЛОН...\n"

#: src/csplit.c:1455
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"Виводить частини ФАЙЛА, розділені ШАБЛОНОМ (ШАБЛОНАМИ), до файлів 'xx00',\n"
"'xx01', ... та виводить число байт у кожній частині на стандартний вивід.\n"

#: src/csplit.c:1462
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=ФОРМАТ використовувати ФОРМАТ як у sprintf замість "
"%02d\n"
"  -f, --prefix=ПРЕФІКС       використовувати ПРЕФІКС замість 'xx'\n"
"  -k, --keep-files           не вилучати файли виводу при помилках\n"

#: src/csplit.c:1467
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ЦИФРИ         використовувати вказане число ЦИФР замість 2\n"
"  -s, --quiet, --silent      не виводити розміри вихідних файлів\n"
"  -z, --elide-empty-files    вилучати порожні файли виводу\n"

#: src/csplit.c:1474
msgid ""
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказаний як -, читає стандартний ввід.  ШАБЛОН вказується\n"
"наступним чином:\n"

#: src/csplit.c:1478
msgid ""
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"  ЦІЛЕ              копіювати до рядка з вказаним номером, але не включно\n"
"  /REGEXP/[ЗСУВ]    копіювати до відповідного рядка, але не включно\n"
"  %%REGEXP%%[ЗСУВ]  пропустити до відповідного рядка, але не включно\n"
"  {ЦІЛЕ}            повторити попередній шаблон вказане число раз\n"
"  {*}               повторити попередній шаблон максимальну кількість разів\n"
"\n"
"Додатковий ЗСУВ рядків -- це обов'язковий символ '+' або '-' з попереднім\n"
"додатнім цілим числом.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:44 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:64 src/cut.c:372
msgid "fields and positions are numbered from 1"
msgstr "поля та позиції нумеруються з 1"

#: src/cut.c:189
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Використання: %s КЛЮЧ... [ФАЙЛ]...\n"

#: src/cut.c:193
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""
"Виводить вибрані частини рядків з кожного ФАЙЛА на стандартний вивід.\n"

#: src/cut.c:199
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=СПИСОК             вибрати лише вказані байти\n"
"  -c, --characters=СПИСОК        вибрати лише вказані знаки\n"
"  -d, --delimiter=РОЗДІЛЮВАЧ     використовувати РОЗДІЛЮВАЧ для розділення\n"
"                                 полів замість табуляції\n"

#: src/cut.c:204
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=СПИСОК            вибрати лише вказані поля; також виводити\n"
"                                 всі рядки, що не містять розділювачів,\n"
"                                 якщо не вказаний ключ -s\n"
"  -n                             (ігнорується)\n"

#: src/cut.c:210
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        доповнити множину вибраних байтів, знаків "
"або                             полів.\n"

#: src/cut.c:214
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited          не виводити рядки, що не містять "
"розділювачів\n"
"      --output-delimiter=РЯДОК  використовувати РЯДОК для розділення полів\n"
"                                при виводі, типово використовується\n"
"                                розділювач для вводу\n"

#: src/cut.c:221
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Використовуйте один, і лише один, з ключів -b, -c чи -f.  Кожен СПИСОК\n"
"складається з одного діапазону, або кількох діапазонів, розділених комами.\n"
"Вибрані частини вхідного файла виводяться у тому порядку, у якому вони,\n"
"з'являються на вході, та виводяться рівно один раз.\n"

#: src/cut.c:227
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Діапазони вказуються наступним чином:\n"
"\n"
"  Н     Н-ний байт, знак або поле; рахуючи від 1\n"
"  Н-    від Н-го байту, знаку або поля до кінця рядка\n"
"  Н-М   від Н-го до М-го (включно) байту, знаку або поля\n"
"  -М    від першого до М-го (включно) байту, знаку або поля\n"
"\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"

#: src/cut.c:367 src/cut.c:493
msgid "invalid byte, character or field list"
msgstr "некоректний байт, символ або список полів"

#: src/cut.c:387
msgid "invalid range with no endpoint: -"
msgstr "неправильний діапазон без кінцевого значення: -"

#: src/cut.c:403
msgid "invalid decreasing range"
msgstr "неприпустимий спадаючий діапазон"

#: src/cut.c:482
#, c-format
msgid "byte offset %s is too large"
msgstr "байтовий зсув %s надто великий"

#: src/cut.c:485
#, c-format
msgid "field number %s is too large"
msgstr "номер поля %s надто великий"

#: src/cut.c:795 src/cut.c:803
msgid "only one type of list may be specified"
msgstr "можна вказати лише один тип списку"

#: src/cut.c:812 src/numfmt.c:1408
#, c-format
msgid "the delimiter must be a single character"
msgstr "розділювач повинен бути одним символом"

#: src/cut.c:847
msgid "you must specify a list of bytes, characters, or fields"
msgstr "треба вказати список байт, символів або полів"

#: src/cut.c:850
msgid "an input delimiter may be specified only when operating on fields"
msgstr "розділювач для вхідних даних можна вказувати лише при обробці полів"

#: src/cut.c:854
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"заборона виводу рядків, що не містять розділювачів,\n"
"має сенс лише при роботі з полями"

#: src/cut.c:870
msgid "missing list of fields"
msgstr "відсутній список полів"

#: src/cut.c:872
msgid "missing list of positions"
msgstr "відсутній список позицій"

#: src/date.c:123
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [+ФОРМАТ]\n"
"       або:    %s [-u|--utc|--universal] [ММДДррхх[[СС]РР][.сс]]\n"

#: src/date.c:128
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""
"Показати поточний час у вказаному ФОРМАТі або встановити системну дату.\n"

#: src/date.c:134
msgid ""
"  -d, --date=STRING         display time described by STRING, not 'now'\n"
"  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
"  -I[TIMESPEC], --iso-8601[=TIMESPEC]  output date/time in ISO 8601 format.\n"
"                            TIMESPEC='date' for date only (the default),\n"
"                            'hours', 'minutes', 'seconds', or 'ns' for date\n"
"                            and time to the indicated precision.\n"
msgstr ""
"  -d, --date=РЯДОК          показати час, описаний РЯДКОМ, а не теперішній.\n"
"  -f, --file=ФАЙЛ_ДАТИ      подібний до --date для кожного з рядків "
"ФАЙЛ_ДАТИ\n"
"  -I[СПЕЦЧАСУ], --iso-8601[=СПЕЦЧАСУ] вивести дату і час у форматі ISO "
"8601.\n"
"                            СПЕЦЧАСУ='date' визначає лише дату (типово),\n"
"                            'hours', 'minutes', 'seconds' і 'ns' -- дата і\n"
"                            час з відповідною точністю.\n"

#: src/date.c:142
msgid ""
"  -r, --reference=FILE      display the last modification time of FILE\n"
"  -R, --rfc-2822            output date and time in RFC 2822 format.\n"
"                            Example: Mon, 07 Aug 2006 12:34:56 -0600\n"
msgstr ""
"  -r,  --reference=ФАЙЛ     показати час останньої зміни ФАЙЛу\n"
"  -R,  --rfc-2822           виводити час відповідно до RFC-2822\n"
"                            Приклад: Mon, 07 Aug 2006 12:34:56 -0600\n"

#: src/date.c:147
msgid ""
"      --rfc-3339=TIMESPEC   output date and time in RFC 3339 format.\n"
"                            TIMESPEC='date', 'seconds', or 'ns' for\n"
"                            date and time to the indicated precision.\n"
"                            Date and time components are separated by\n"
"                            a single space: 2006-08-07 12:34:56-06:00\n"
"  -s, --set=STRING          set time described by STRING\n"
"  -u, --utc, --universal    print or set Coordinated Universal Time\n"
msgstr ""
"       --rfc-3339[=СПЕЦ]    вивести дату/час у форматі RFC 3339\n"
"                            СПЕЦ='date', 'seconds' або 'ns' для отримання\n"
"                            дати та часу з вказаною точністю.\n"
"  -s,  --set=РЯДОК          встановити час, що описується РЯДКОМ\n"
"  -u, --utc, --universal    показати або встановити універсальний\n"
"                            координований час\n"

#: src/date.c:158
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом.  Розпізнаються послідовності:\n"
"\n"
"  %%   знак %\n"
"  %a   місцева скорочена назва дня тижня (напр., нед)\n"

#: src/date.c:165
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   місцева повна назва дня тижня (напр., понеділок)\n"
"  %b   місцева скорочена назва місяця (напр., січ)\n"
"  %B   місцева повна назва місяця (напр., січень)\n"
"  %c   місцевий час та дата (напр., Чтв 3 Мар 23:05:25 2005)\n"

#: src/date.c:171
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   століття; як %Y, але без двох останніх цифр (наприклад 20)\n"
"  %d   день місяця (наприклад 01)\n"
"  %D   дата; те саме, що і %m/%d/%y\n"
"  %e   день місяця, доповнений пробілами; те саме, що і %_d\n"

#: src/date.c:177
msgid ""
"  %F   full date; same as %Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   повна дата; еквівалентно %Y-%m-%d\n"
"  %g   останні дві цифри року для номера тижня ISO (см. %G)\n"
"  %G   рік для номера тижня ISO (см. %V); звичайно буває корисно лише з %V\n"

#: src/date.c:182
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   те саме, що й %b\n"
"  %H   час (00..23)\n"
"  %I   час (01..12)\n"
"  %j   номер дня у році (001..366)\n"

#: src/date.c:188
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   час з доповненням пробілом ( 0..23); те саме, що і %_H\n"
"  %l   час з доповненням пробілом ( 1..12); те саме, що і %_I\n"
"  %m   місяць (01..12)\n"
"  %M   хвилини (00..59)\n"

#: src/date.c:194
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   новий рядок\n"
"  %N   наносекунди (000000000..999999999)\n"
"  %p   місцевий еквівалент AM або PM; пропускається якщо невідомо\n"
"  %P   як %p, але малими літерами\n"
"  %r   час відповідно до локалі, 12-годинний формат (напр., 11:11:04 PM)\n"
"  %R   години та хвилини відповідно до локалі, 24-годинний формат; аналог %H:"
"%M\n"
"  %s   число секунд, що минули з 1970-01-01 00:00:00  UTC\n"

#: src/date.c:203
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   секунди (00..60)\n"
"  %t   табуляція\n"
"  %T   час, аналог %H:%M:%S\n"
"  %u   день тижня (1..7);  1 означає понеділок\n"

#: src/date.c:209
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   номер тижня у році, якщо перший день тижня -- неділя (00..53)\n"
"  %V   номер тижня по ISO, якщо перший день тижня -- понеділок (01..52)\n"
"  %w   день тижня (0..6), 0 означає неділю\n"
"  %W   номер тижня у році, якщо перший день тижня -- понеділок (00..53)\n"

#: src/date.c:215
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   місцеве представлення дати (напр., дд/мм/рр)\n"
"  %X   місцеве представлення часу (напр.,  23:13:48)\n"
"  %y   останні дві цифри року (00..99)\n"
"  %Y   рік\n"

#: src/date.c:221
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   +ггхх часовий пояс (наприклад -0400)\n"
"  %:z  +гг:хх часовий пояс (наприклад -04:00)\n"
"  %::z +гг:хх:сс часовий пояс (наприклад -04:00:00)\n"
"  %:::z часовий пояс з достатньою кількістю двокрапок (наприклад -04, "
"+05:30)\n"
"  %Z   алфавітне скорочення часового поясу (наприклад EDT)\n"
"\n"
"Типово date доповнює числові поля нулями.\n"

#: src/date.c:230
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"Після '%' можуть йти наступні необов'язкові ознаки:\n"
"\n"
"  - (дефіс) не доповнювати це поле\n"
"  _ (підкреслення) доповнювати пробілами\n"
"  0 (нуль) доповнювати нулями\n"
"  ^ використовувати верхній регістр, якщо можливо\n"
"  # використовувати протилежний регістр, якщо можливо\n"

#: src/date.c:239
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"Після будь-якої з ознак йде необов'язкова ширина поля у вигляді "
"десяткового;\n"
"числа потім необов'язковий модифікатор, один з наступних:\n"
"E -- якщо можливо, вживати альтернативне представлення для поточної локалі\n"
"O -- якщо можливо, використовувати альтернативні числові символи локалі.\n"

#: src/date.c:246
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"Приклади:\n"
"Перетворити секунди з початку епохи (1970-01-01 UTC) у дату\n"
"  $ date --date='@2147483647'\n"
"\n"
"Показати час у Києві США (скористайтеся tzselect(1) для визначення TZ)\n"
"  $ TZ='Europe/Kiev' date\n"
"\n"
"Показати локальний час для 9:00 наступної п'ятниці у Києві\n"
"  $ date --date='TZ=\"Europe/Kiev\" 09:00 next Fri'\n"

#: src/date.c:279 src/dd.c:2201 src/head.c:845 src/md5sum.c:498
#: src/md5sum.c:862 src/od.c:869 src/od.c:1920 src/pr.c:1172 src/pr.c:1362
#: src/pr.c:1484 src/stty.c:851 src/tac.c:562 src/tail.c:342 src/tee.c:126
#: src/tr.c:1945 src/tsort.c:530 src/wc.c:196
#, c-format
msgid "standard input"
msgstr "стандартний ввід"

#: src/date.c:307 src/date.c:527
#, c-format
msgid "invalid date %s"
msgstr "неправильна дата %s"

#: src/date.c:418 src/date.c:452
#, c-format
msgid "multiple output formats specified"
msgstr "задано декілька вихідних форматів"

#: src/date.c:430
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "ключі для виводу дати взаємно виключають друг друга"

#: src/date.c:437
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"ключі для встановлення та для відображення часу не можуть застосовуватись "
"разом"

#: src/date.c:458
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"аргумент %s не починається зі знаку '+';\n"
"При вказуванні дати, кожен аргумент, що не є ключем, повинен мати\n"
"символьний формат та починатись зі знаку '+'."

#: src/date.c:535
#, c-format
msgid "cannot set date"
msgstr "не вдалося встановити дату"

#: src/date.c:558 src/du.c:371
#, c-format
msgid "time %s is out of range"
msgstr "час %s поза допустимим діапазоном"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:109 src/rm.c:41 src/tail.c:69 src/touch.c:41
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:521
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ОПЕРАНД]...\n"
"       або:    %s КЛЮЧ\n"

#: src/dd.c:526
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"Копіює файл, перетворює та форматує залежно від операндів.\n"
"\n"
"  bs=ЧИСЛО        примусово вести запис і читання порціями у ЧИСЛО байтів\n"
"  cbs=ЧИСЛО       перетворювати вказане ЧИСЛО байт за раз\n"
"  conv=СПИСОК     перетворювати файл відповідно до СПИСКУ символів,\n"
"                  елементи має бути розділено комами\n"
"  count=ЧИСЛО     копіювати лише вказане ЧИСЛО вхідних блоків\n"
"  ibs=ЧИСЛО       читати вказане ЧИСЛО байт за раз (типово 512)\n"

#: src/dd.c:535
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=WHICH    WHICH info to suppress outputting to stderr;\n"
"                  'noxfer' suppresses transfer stats, 'none' suppresses all\n"
msgstr ""
"  if=ФАЙЛ         читати ФАЙЛ, а не стандартне введення\n"
"  iflag=СПИСОК    читати відповідно до СПИСКУ символів,\n"
"                  елементи слід розділяти комами\n"
"  obs=ЧИСЛО       записувати вказане ЧИСЛО байт за раз (типово 512)\n"
"  of=ФАЙЛ         записувати у ФАЙЛ, а не у стандартне виведення\n"
"  oflag=СПИСОК    записувати відповідно до списку символів,\n"
"                  елементи слід розділяти комами\n"
"  seek=N          пропустити з початку виводу N блоків розміром obs\n"
"  skip=N          пропустити з початку вводу N блоків розміром ibs\n"
"  status=РЕЖИМ    РЕЖИМ придушення виведення даних до stderr;\n"
"                  «noxfer» — придушити виведення статистики передавання,\n"
"                  «none» — придушити виведення будь-яких даних\n"

#: src/dd.c:546
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"Після ЧИСЛА і БАЙТів може бути вказано один з множників:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n"
"GB =1000*1000*1000, G =1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"\n"
"Кожен елемент СПИСКУ для conv може бути:\n"
"\n"

#: src/dd.c:555
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write the output for NUL input blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     з EBCDIC на ASCII\n"
"  ebcdic    з ASCII на EBCDIC\n"
"  ibm       з ASCII на альтернативну EBCDIC\n"
"  block     заповнювати записи, що закінчуються переносом рядка, пробілами\n"
"            до розміру cbs\n"
"  unblock   замінювати кінцеві пробіли у записах з розміром cbs переносом "
"рядка\n"
"  lcase     змінювати регістр з верхнього на нижній\n"
"  ucase     змінювати регістр з нижнього на верхній\n"
"  sparse    спробувати виконати позиціювання замість запису до виведення для "
"вхідних\n"
"              блоків NUL\n"
"  swab      міняти місцями кожну пару вхідних байтів\n"
"  sync      доповнювати кожен вхідний блок нулями до розміру ibs; якщо\n"
"              вживається разом з block або unblock, доповнювати пробілами\n"

#: src/dd.c:568
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      завершаться помилкою, якщо файл виводу уже існує\n"
"  nocreat   не створювати файл виводу\n"
"  notrunc   не обрізати файл виводу\n"
"  noerror   продовжувати після помилок читання\n"
"  fdatasync фізично записати файл виводу перед завершенням\n"
"  fsync     аналогічно, але записати також метадані\n"

#: src/dd.c:576
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"Символ-ОЗНАКА може бути таким:\n"
"\n"
"  append    режим додавання (має сенс для виводу; рекомендується  "
"conv=notrunc)\n"

#: src/dd.c:583
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio       використовувати конкурентне введення-виведення для дати\n"

#: src/dd.c:585
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    використовувати прямий ввід/вивід для даних\n"

#: src/dd.c:587
msgid "  directory  fail unless a directory\n"
msgstr "  directory  помилка, якщо не є каталогом\n"

#: src/dd.c:589
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     використовувати синхронізований ввід/вивід для даних\n"

#: src/dd.c:591
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      те саме, але також для метаданих\n"

#: src/dd.c:592
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock  акумулювати повні блоки вводу (лише iflag)\n"

#: src/dd.c:595
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  використовувати ввід/вивід без блокування\n"

#: src/dd.c:597
msgid "  noatime   do not update access time\n"
msgstr "  noatime   не оновлювати час останнього доступу\n"

#: src/dd.c:600
msgid "  nocache   discard cached data\n"
msgstr "  nocache   відкинути кешовані дані\n"

#: src/dd.c:603
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    не призначати керівний термінал з файла\n"

#: src/dd.c:606
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  не слідувати за символьним посиланням\n"

#: src/dd.c:608
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   помилка, якщо знайдено декілька посилань\n"

#: src/dd.c:610
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    використовувати двійковий ввід/вивід для даних\n"

#: src/dd.c:612
msgid "  text      use text I/O for data\n"
msgstr "  text      використовувати текстовий ввід/вивід для даних\n"

#: src/dd.c:614
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""
"  count_bytes  вважати «count=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:617
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""
"  skip_bytes  вважати «skip=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:620
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""
"  seek_bytes  вважати «seek=N» визначенням кількості байтів (лише для "
"oflag)\n"

#: src/dd.c:625
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 records in\n"
"  18335302+0 records out\n"
"  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Якщо надіслати запущеному процесу 'dd' сигнал %s, він виведе на\n"
"стандартний потік помилок статистику вводу/виводу та продовжить\n"
"копіювання.\n"
"\n"
"  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
"  $ kill -%s $pid; sleep 1; kill $pid\n"
"  18335302+0 вхідних записів\n"
"  18335302+0 вихідних записів\n"
"  9387674624 байта (9.4 GB) скопійовано, 34.6279 секунди, 271 Мб/с\n"
"\n"
"Ключі:\n"
"\n"

#: src/dd.c:683
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> записів прочитано\n"
"%<PRIuMAX>+%<PRIuMAX> записів записано\n"

#: src/dd.c:689
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> обрізаний запис\n"
msgstr[1] "%<PRIuMAX> обрізані записи\n"
msgstr[2] "%<PRIuMAX> обрізаних записів\n"

#: src/dd.c:701
#, c-format
msgid "%<PRIuMAX> byte (%s) copied"
msgid_plural "%<PRIuMAX> bytes (%s) copied"
msgstr[0] " скопійовано %<PRIuMAX> байт (%s)"
msgstr[1] " скопійовано %<PRIuMAX> байти (%s)"
msgstr[2] " скопійовано %<PRIuMAX> байтів (%s)"

#: src/dd.c:720
msgid "Infinity B"
msgstr "Нескінченість"

#. TRANSLATORS: The two instances of "s" in this string are the SI
#. symbol "s" (meaning second), and should not be translated.
#.
#. This format used to be:
#.
#. ngettext (", %g second, %s/s\n", ", %g seconds, %s/s\n", delta_s == 1)
#.
#. but that was incorrect for languages like Polish.  To fix this
#. bug we now use SI symbols even though they're a bit more
#. confusing in English.
#: src/dd.c:733
#, c-format
msgid ", %g s, %s/s\n"
msgstr ", %g с, %s/s\n"

#: src/dd.c:812
#, c-format
msgid "closing input file %s"
msgstr "закриття вхідного файла %s"

#: src/dd.c:819
#, c-format
msgid "closing output file %s"
msgstr "закриття файла виводу %s"

#: src/dd.c:1022
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "не вдалося вимкнути O_DIRECT: %s"

#: src/dd.c:1093 src/dd.c:1942
#, c-format
msgid "writing to %s"
msgstr "запис у %s"

#: src/dd.c:1207 src/dd.c:1261
#, c-format
msgid "unrecognized operand %s"
msgstr "операнд %s не розпізнаний"

#: src/dd.c:1218
msgid "invalid conversion"
msgstr "неприпустиме перетворення"

#: src/dd.c:1221 src/dd.c:1297
msgid "invalid input flag"
msgstr "неприпустима ознака входу"

#: src/dd.c:1224 src/dd.c:1291 src/dd.c:1303
msgid "invalid output flag"
msgstr "неприпустимий ознака виводу"

#: src/dd.c:1227
msgid "invalid status flag"
msgstr "неприпустимий ознака статусу"

#: src/dd.c:1266 src/truncate.c:310
#, c-format
msgid "invalid number %s"
msgstr "неправильний номер %s"

#: src/dd.c:1348
#, c-format
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "не можна одночасно використовувати будь-які два з {ascii,ebcdic,ibm}"

#: src/dd.c:1350
#, c-format
msgid "cannot combine block and unblock"
msgstr "не можна одночасно використовувати block та unblock"

#: src/dd.c:1352
#, c-format
msgid "cannot combine lcase and ucase"
msgstr "не можна одночасно використовувати lcase та ucase"

#: src/dd.c:1354
#, c-format
msgid "cannot combine excl and nocreat"
msgstr "не можна одночасно використовувати excl та nocreat"

#: src/dd.c:1357
#, c-format
msgid "cannot combine direct and nocache"
msgstr "не можна одночасно використовувати direct і nocache"

#: src/dd.c:1514
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"попередження: обходиться помилка lseek у ядрі для файла (%s)\n"
"  mt_type=0x%0lx -- см. <sys/mtio.h> для списку типів"

#: src/dd.c:1601
#, c-format
msgid "%s: cannot skip"
msgstr "%s: не вдалося пропустити"

#: src/dd.c:1603 src/dd.c:1622 src/dd.c:1683
#, c-format
msgid "%s: cannot seek"
msgstr "%s: не вдалося зсунути вказівник файла"

#: src/dd.c:1663
#, c-format
msgid "offset overflow while reading file %s"
msgstr "переповнення зсуву при читанні файла %s"

#: src/dd.c:1675
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "попередження: некоректний зсув файла після помилки читання"

#: src/dd.c:1679
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "не вдалося обійти помилку ядра"

#: src/dd.c:1822
#, c-format
msgid "setting flags for %s"
msgstr "встановлення ознак для %s"

#: src/dd.c:1875
#, c-format
msgid "memory exhausted by input buffer of size %zu bytes (%s)"
msgstr "пам'ять вичерпано буфером введення даних розміром у %zu байтів (%s)"

#: src/dd.c:1889
#, c-format
msgid "memory exhausted by output buffer of size %zu bytes (%s)"
msgstr "пам'ять вичерпано буфером виведення даних розміром у %zu байтів (%s)"

#: src/dd.c:1922
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: не вдалося перемістити вказівник позиції на вказану кількість"

#: src/dd.c:2133
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIdMAX> у файлі виведення даних %s"

#: src/dd.c:2146
#, c-format
msgid "fdatasync failed for %s"
msgstr "операція fdatasync для %s завершилась помилкою"

#: src/dd.c:2156
#, c-format
msgid "fsync failed for %s"
msgstr "операція fsync для %s завершилась помилкою"

#: src/dd.c:2207 src/dd.c:2236 src/nohup.c:163 src/nohup.c:165
#, c-format
msgid "failed to open %s"
msgstr "не вдалося відкрити %s"

#: src/dd.c:2246
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"зсув надто великий: не вдалося обрізати до величини seek=%<PRIuMAX> (%lu-"
"байтних) блоків"

#: src/dd.c:2267
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIuMAX> у файлі виведення даних %s"

#: src/dd.c:2283 src/dd.c:2289
#, c-format
msgid "failed to discard cache for: %s"
msgstr "помилка під час відкидання кешу для %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:44 src/du.c:55 src/expr.c:153 src/kill.c:33 src/pathchk.c:32
#: src/shuf.c:39 src/sleep.c:35 src/sort.c:67
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:172
msgid "Filesystem"
msgstr "Ф. система"

#: src/df.c:175
msgid "Type"
msgstr "Тип"

#: src/df.c:178 src/df.c:542
msgid "blocks"
msgstr "блоків"

#: src/df.c:181
msgid "Used"
msgstr "Вик"

#: src/df.c:184
msgid "Available"
msgstr "Доступно"

#: src/df.c:187
msgid "Use%"
msgstr "Вик%"

#: src/df.c:190
msgid "Inodes"
msgstr "І-вузлів"

#: src/df.c:193
msgid "IUsed"
msgstr "Викор"

#: src/df.c:196
msgid "IFree"
msgstr "Вільн"

#: src/df.c:199
msgid "IUse%"
msgstr "Вик%"

#: src/df.c:202
msgid "Mounted on"
msgstr "змонтований на"

#: src/df.c:383
#, c-format
msgid "option --output: field '%s' unknown"
msgstr "параметр --output: поле «%s» є невідомим"

#: src/df.c:390
#, c-format
msgid "option --output: field '%s' used more than once"
msgstr "параметр --output: поле «%s» використано декілька разів"

#: src/df.c:410 src/df.c:449
msgid "Size"
msgstr "Розм"

#: src/df.c:414 src/df.c:451
msgid "Avail"
msgstr "Дост"

#: src/df.c:474
msgid "Capacity"
msgstr "Всього"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:545 src/df.c:554
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1210
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"Показати інформацію про файлову систему, на якій розташований кожен\n"
"з ФАЙЛІВ, або, типово, про усі файлові системи.\n"

#: src/df.c:1217
msgid ""
"  -a, --all             include dummy file systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes.\n"
"                           See SIZE format below.\n"
"      --total           produce a grand total\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"  -H, --si              likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -a, --all             включати віртуальні файлові системи\n"
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"\n"
"      --total           виводити підсумок\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                         (наприклад, 1K 234M 2G)\n"
"  -H, --si              те саме, але використовувати ступені 1000, а не "
"1024\n"

#: src/df.c:1227
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          вивести інформацію про індексні дескриптори, а не "
"про\n"
"                        використання блоків\n"
"  -k                    аналог --block-size=1K\n"
"  -l, --local           перерахувати лише локальні файлові системи\n"
"      --no-sync         не викликати sync перед отриманням інформації про\n"
"                        використання блоків (типово)\n"

#: src/df.c:1234
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"      --output[=СПИСОК_ПОЛІВ]  використовувати формат виведення, визначений "
"СПИСКОМ_ПОЛІВ,\n"
"                               або вивести всі поля, якщо СПИСОК_ПОЛІВ не "
"вказано.\n"
"  -P, --portability     виводити у форматі POSIX\n"
"      --sync            викликати sync перед отриманням інформації про\n"
"                        використання блоків\n"
"  -t, --type=ТИП        перерахувати лише файлові системи вказаного ТИПУ\n"
"  -T, --print-type      виводити тип файлової системи\n"
"  -x, --exclude-type=ТИП  виключати файлові системи вказаного ТИПУ\n"
"  -v                    (ігнорується)\n"

#: src/df.c:1248
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent' and 'target' (see info page).\n"
msgstr ""
"\n"
"СПИСОК_ПОЛІВ — відокремлений комами список стовпчиків, які слід включити.\n"
"Можливі назви стовпчиків: 'source', 'fstype', 'itotal', 'iused', 'iavail', "
"'ipcent',\n"
"'size', 'used', 'avail', 'pcent' і 'target' (див. сторінку info).\n"

#: src/df.c:1285
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "параметри %s і %s не можна використовувати одночасно"

#: src/df.c:1335
msgid "warning: "
msgstr "попередження: "

#: src/df.c:1336
msgid "long option '--megabytes' is deprecated and will soon be removed"
msgstr ""
"довга версія параметра «--megabytes» вважається застарілою, скоро її буде "
"вилучено"

#: src/df.c:1442
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "файлова система типа %s і вибрана, і виключена"

#: src/df.c:1500
msgid "Warning: "
msgstr "Попередження: "

#: src/df.c:1502 src/stat.c:814
msgid "cannot read table of mounted file systems"
msgstr "%помилка при читані змонтованих файлових систем"

#: src/df.c:1539
#, c-format
msgid "no file systems processed"
msgstr "не вказана жодна файлова система"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:35
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:97 src/uptime.c:196 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#: src/dircolors.c:98
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Видає команди для встановлення змінної оточення LS_COLORS.\n"
"\n"
"Вказати формат виводу:\n"
"  -b, --sh, --bourne-shell    вивести код для встановлення LS_COLORS у\n"
"                               Bourne shell\n"
"  -c, --csh, --c-shell        вивести код для встановлення LS_COLORS у C "
"shell\n"
"  -p, --print-database        вивести типові параметри\n"
"      --help                  показати довідку та вийти\n"
"      --version               вивести інформацію про версію та вийти\n"

#: src/dircolors.c:108
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"Якщо вказаний FILE, то читати його щоб дізнатись які кольори яким\n"
"розширенням призначені. Інакше використовувати типову базу даних. Для\n"
"докладнішого опису формату FILE запустите dircolors --print-database.\n"

#: src/dircolors.c:286
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: неправильний рядок; пропущена друга лексема"

#: src/dircolors.c:358
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu ключове слово %s не розпізнано"

#: src/dircolors.c:359
msgid "<internal>"
msgstr "<внутрішній>"

#: src/dircolors.c:440
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"ключі для виводу внутрішньої бази даних dircolors та ключі для вибору\n"
"синтаксису оболонки взаємно виключають друг друга"

#: src/dircolors.c:450
msgid "file operands cannot be combined with --print-database (-p)"
msgstr ""
"Операнди-файли не можна одночасно використовувати з --print-database (-p)"

#: src/dircolors.c:473
#, c-format
msgid "no SHELL environment variable, and no shell type option given"
msgstr "або змінна оточення SHELL відсутня, або не вказаний тип інтерпретатору"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Використання: %s [КЛЮЧ] НАЗВА...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"Виводить всі НАЗВИ, вилучаючи компоненту праворуч від останньої похилої "
"риски;\n"
"якщо НАЗВА не містить похилої риски, виводить «.» (тобто поточний каталог).\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     separate output with NUL rather than newline\n"
msgstr ""
"  -z, --zero     завершувати кожен рядок нуль-байтом замість розриву рядка\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/          -> «/usr»\n"
"  %s dir1/str dir2/str  -> «dir1», потім «dir2»\n"
"  %s stdio.h            -> «.»\n"

#: src/du.c:270 src/sort.c:394 src/wc.c:112
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [КЛЮЧ]... --files0-from=Ф\n"

#: src/du.c:274
msgid "Summarize disk usage of each FILE, recursively for directories.\n"
msgstr "Сумарне використання дискового простору кожного ФАЙЛА, з каталогами.\n"

#: src/du.c:280
msgid ""
"  -0, --null            end each output line with 0 byte rather than "
"newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            завершувати кожен рядок виведених даних 0-байтом "
"замість символу\n"
"                          нового рядка\n"
"  -a, --all             виводить обсяг для усіх файлів, а не лише каталогів\n"
"      --apparent-size   виводить дійсні розміри, а не зайнятий дисковий\n"
"                          простір; хоча справжній розмір звичайно менший,\n"
"                          іноді він може бути більшим через дірки у файлах,\n"
"                          внутрішньої фрагментації, непрямих блоків та т.і.\n"

#: src/du.c:289
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them.  E.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes.\n"
"                           See SIZE format below.\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"  -b, --bytes           еквівалент «--apparent-size --block-size=1»\n"
"  -c, --total           підбивати підсумок\n"
"  -D, --dereference-args  розіменовувати символьні посилання у командному\n"
"                          рядку\n"
"  -d, --max-depth=Н     виводити підсумки для каталогу (або файла, якщо "
"вказано --all),\n"
"                          лише, якщо він перебуває на Н-му або нижчому рівні "
"відносно\n"
"                          аргументу командного рядка;  --max-depth=0 — те "
"саме, що і для\n"
"                          --summarize\n"

#: src/du.c:302
msgid ""
"      --files0-from=F   summarize disk usage of the NUL-terminated file\n"
"                          names specified in file F;\n"
"                          If F is - then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
msgstr ""
"      --files0-from=Ф   вивести звіт про файли, чиї назви (завершені\n"
"                          нулем) перераховані у файлі Ф\n"
"                          Якщо Ф вказано - назви беруться зі стандартного "
"вводу\n"
"  -H                    еквівалент ключа --dereference-args (-D)\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                          (наприклад, 1K 234M 2G)\n"

#: src/du.c:310
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    як --block-size=1K\n"
"  -L, --dereference     розіменувати всі символічні посилання\n"
"  -l, --count-links     прочитати кожне жорстке посилання як окремий файл\n"
"  -m                    як --block-size=1M\n"

#: src/du.c:316
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   do not include size of subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  не слідувати за символьним посиланням (типово)\n"
"  -S, --separate-dirs   не включати розмір каталогів\n"
"      --si              подібне до -h, але з використанням мір, кратних до "
"1000, а не 1024\n"
"  -s, --summarize       виводити лише зведення для кожного аргументу\n"

#: src/du.c:322
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using style STYLE:\n"
"                          full-iso, long-iso, iso, +FORMAT\n"
"                          FORMAT is interpreted like 'date'\n"
msgstr ""
"  -t, --threshold=РОЗМІР  виключити записи, менші за РОЗМІР, якщо додатне,\n"
"                          або записи, більші за РОЗМІР, якщо від’ємне\n"
"      --time            виводити час останньої зміни будь-якого файла у\n"
"                          каталозі або усіх його підкаталогів\n"
"      --time=СЛОВО      виводити вказаний у СЛОВО час, а не час \n"
"                          зміни: atime, access, use, ctime або status\n"
"      --time-style=СТИЛЬ виводити час, використовуючи СТИЛЬ:\n"
"                          full-iso, long-iso, iso, +ФОРМАТ\n"
"                          ФОРМАТ інтерпретується як у 'date'\n"

#: src/du.c:333
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=ФАЙЛ  виключити файли, назви яких відповідають зразку з "
"ФАЙЛа\n"
"      --exclude=ЗРАЗОК     виключити файли, назви яких відповідають ЗРАЗКУ\n"
"  -x, --one-file-system    пропускати каталоги на різних файлових системах\n"

#: src/du.c:386
msgid "Infinity"
msgstr "Нескінченість"

#: src/du.c:507
#, c-format
msgid "mount point %s already traversed"
msgstr "обхід точки монтування %s вже здійснено"

#: src/du.c:624
#, c-format
msgid "fts_read failed: %s"
msgstr "помилка fts_read: %s"

#: src/du.c:780
#, c-format
msgid "invalid maximum depth %s"
msgstr "неприпустима максимальна глибина %s"

#: src/du.c:809
#, c-format
msgid "invalid --threshold argument '-0'"
msgstr "некоректний аргумент --threshold «-0»"

#: src/du.c:887
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "не можна одночасно підбивати зведення та виводити всі елементи"

#: src/du.c:894
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "попередження: підбиття зведення це те ж саме, що й --max-depth=0"

#: src/du.c:900
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "попередження: підбиття зведення конфліктує з --max-depth=%lu"

#: src/du.c:966 src/sort.c:4533 src/wc.c:668
msgid "file operands cannot be combined with --files0-from"
msgstr "операнди-файли не можна використовувати разом з --files0-from"

#: src/du.c:1026 src/md5sum.c:608 src/od.c:909 src/tac.c:238 src/tac.c:349
#: src/tac.c:505 src/tac.c:585 src/wc.c:733
#, c-format
msgid "%s: read error"
msgstr "%s: помилка читання"

#: src/du.c:1040 src/sort.c:4562 src/wc.c:747
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "при читанні імен файлів з stdin, не допускаються назви файлів %s"

#: src/du.c:1057 src/du.c:1065 src/wc.c:760 src/wc.c:768
msgid "invalid zero-length file name"
msgstr "неправильна назва файла нульової довжини"

#: src/du.c:1088 src/ls.c:2649 src/wc.c:791
msgid "total"
msgstr "загалом"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:26
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:41
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... [РЯДОК]...\n"
"  або  %s ДОВГИЙ-ПАРАМЕТР\n"

#: src/echo.c:45
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Виводить РЯДОК(РЯДКА) на стандартний вивід.\n"
"\n"
"  -n             не виводити завершальне переведення рядка\n"

#: src/echo.c:51
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності (типово)\n"
"  -E             не інтерпретувати керівні послідовності\n"

#: src/echo.c:54
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності\n"
"  -E             не інтерпретувати керівні послідовності (типово)\n"

#: src/echo.c:60
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"Якщо задіяно -e, розпізнаються такі послідовності:\n"
"\n"

#: src/echo.c:65 src/printf.c:105
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      зворотна риска\n"
"  \\a      дзвінок (BEL)\n"
"  \\b      backspace\n"
"  \\c      не виводити завершальний символ нового рядка\n"
"  \\e      escape\n"
"  \\f      нова сторінка\n"
"  \\n      новий рядок\n"
"  \\r      переведення каретки\n"
"  \\t      горизонтальна табуляція\n"
"  \\v      вертикальна табуляція\n"

#: src/echo.c:77
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xHH    байт з шістнадцятковим значенням HH (від 1 до 2 цифр)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:32 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:52
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-] [НАЗВА=ЗНАЧЕННЯ]... [КОМАНДА [АРГ]...]\n"

#: src/env.c:55
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""
"Встановлює кожній НАЗВІ відповідне ЗНАЧЕННЯ та запускає КОМАНДУ у цьому\n"
"середовищі.\n"

#: src/env.c:61
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with 0 byte rather than newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment   почати з порожнім оточенням\n"
"  -0, --null                 завершувати кожне з виведених рядків 0-байтом, "
"а не розривом рядка\n"
"  -u, --unset=НАЗВА          вилучити з оточення НАЗВИ\n"

#: src/env.c:68
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Просто '-' -- синонім для '-i'.  Якщо не вказана КОМАНДА, виводить отримане\n"
"оточення.\n"

#: src/env.c:124
#, c-format
msgid "cannot unset %s"
msgstr "не вдалося вилучити %s"

#: src/env.c:135
#, c-format
msgid "cannot set %s"
msgstr "не вдалося встановити %s"

#: src/env.c:152
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "не можна вказувати --null (-0) з командою"

#: src/expand.c:107
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Перетворює знаки табуляції у кожному ФАЙЛІ на пробіли та виводить на\n"
"стандартний вивід.  Якщо ФАЙЛ не вказаний або вказаний як -, читає.\n"
"стандартний ввід\n"

#: src/expand.c:114
msgid ""
"  -i, --initial       do not convert tabs after non blanks\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
msgstr ""
"  -i, --initial       не перетворювати знаки табуляції після знаків "
"пробілів\n"
"  -t, --tabs=ЧИСЛО    встановлює ширину табуляції, типово 8\n"

#: src/expand.c:118
msgid ""
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
msgstr ""
"  -t, --tabs=СПИСОК   використовувати розділений комами список позицій "
"табуляції\n"

#: src/expand.c:171 src/unexpand.c:190
#, c-format
msgid "tab stop is too large %s"
msgstr "розмір табуляції надто великий %s"

#: src/expand.c:179 src/unexpand.c:198
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "розмір табуляції містить неприпустимий знак (знаки): %s"

#: src/expand.c:205 src/unexpand.c:224
#, c-format
msgid "tab size cannot be 0"
msgstr "розмір табуляції не може дорівнювати нулю"

#: src/expand.c:207 src/unexpand.c:226
#, c-format
msgid "tab sizes must be ascending"
msgstr "номера позицій табуляції повинні зростати"

#: src/expand.c:325 src/expand.c:344 src/unexpand.c:373 src/unexpand.c:418
#, c-format
msgid "input line is too long"
msgstr "вхідний рядок надто великий"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:41 src/mv.c:41 src/tee.c:34
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:36
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:203
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ВИРАЗ\n"
"       або:    %s КЛЮЧ\n"

#: src/expr.c:211
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Виводить значення ВИРАЗУ на стандартний вивід.  Нижче порожніми рядками\n"
"розділені групи за зростанням пріоритету.  Можливі ВИРАЗИ:\n"
"\n"
"  АРГ1 | АРГ2       АРГ1, якщо він відмінний від нуля, інакше АРГ2\n"
"\n"
"  АРГ1 & АРГ2       АРГ1, якщо обидва відмінні від нуля, інакше 0\n"

#: src/expr.c:220
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  АРГ1 < АРГ2       АРГ1 менше АРГ2\n"
"  АРГ1 <= АРГ2      АРГ1 менше або дорівнює АРГ2\n"
"  АРГ1 = АРГ2       АРГ1 дорівнює АРГ2\n"
"  АРГ1 != АРГ2      АРГ1 не дорівнює АРГ2\n"
"  АРГ1 >= АРГ2      АРГ1 більше або дорівнює АРГ2\n"
"  АРГ1 > АРГ2       АРГ1 більше АРГ2\n"

#: src/expr.c:229
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  АРГ1 + АРГ2       арифметична сума АРГ1 та АРГ2\n"
"  АРГ1 - АРГ2       арифметична різниця АРГ1 та АРГ2\n"

#: src/expr.c:236
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  АРГ1 * АРГ2       арифметичний добуток АРГ1 та АРГ2\n"
"  АРГ1 / АРГ2       арифметична частка від АРГ1 та АРГ2\n"
"  АРГ1 % AРГ2       арифметичний залишок від ділення АРГ1 на АРГ2\n"

#: src/expr.c:242
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  РЯДОК : REGEXP   перевірка відповідності REGEXP початку або кінцю РЯДКА\n"
"\n"
"  match РЯДОК REGEXP        те саме, що та РЯДОК : REGEXP\n"
"  substr РЯДОК ПОЗ ДОВЖИНА  частина РЯДКА, позиція відраховується від 1\n"
"  index РЯДОК СИМВОЛИ       позиція у РЯДКУ, де першим знайдений будь-який\n"
"                            з СИМВОЛІВ, інакше 0\n"
"  length РЯДОК              довжина РЯДКА\n"

#: src/expr.c:251
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + ЛЕКСЕМА                  сприймати ЛЕКСЕМУ як рядок, навіть якщо це\n"
"                             ключове слово, як 'match', або оператор, як "
"'/'\n"
"\n"
"  ( ВИРАЗ )                  значення ВИРАЗУ\n"

#: src/expr.c:257
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"Пам'ятайте, що при використанні у оболонці деякі оператори повинні бути\n"
"взяті у дужки.  Якщо обидва аргументу АРГ є числами, то виконується\n"
"арифметичний порівняння, інакше вони порівнюються як рядки.  При "
"відповідності\n"
"шаблону повертається відповідний рядок рядок між \\( та \\) або порожній "
"рядок;\n"
"якщо \\( та \\) не використовуються, то повертається кількість відповідних "
"символів.\n"

#: src/expr.c:264
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"Статус завершення дорівнює 0, якщо ВИРАЗ не порожній та не 0; 1, якщо\n"
"ВИРАЗ порожній або 0; 2, якщо ВИРАЗ синтаксично неправильний; та 3,\n"
"якщо виникла помилка.\n"

#: src/expr.c:278
#, c-format
msgid "syntax error"
msgstr "синтаксична помилка"

#: src/expr.c:599 src/ptx.c:283
#, c-format
msgid "error in regular expression matcher"
msgstr "помилка у механізмі відповідності регулярних виразів"

#: src/expr.c:791 src/expr.c:828
#, c-format
msgid "non-integer argument"
msgstr "не цілочисловий аргумент"

#: src/expr.c:793 src/truncate.c:314
#, c-format
msgid "division by zero"
msgstr "ділення на нуль"

#: src/expr.c:887 src/sort.c:2044
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: src/expr.c:889
#, c-format
msgid "the strings compared were %s and %s"
msgstr "рядки, що порівнювались %s та %s."

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:111
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1283 src/factor.c:1383 src/factor.c:1459
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr "Не вдалося перевірити простоту за тестом Люка. Цього не мало статися."

#: src/factor.c:2092
#, c-format
msgid "squfof queue overflow"
msgstr "переповнення черги squfof"

#: src/factor.c:2419
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s не є правильним цілим додатнім числом"

#: src/factor.c:2442 src/od.c:1646 src/od.c:1715
#, c-format
msgid "%s is too large"
msgstr "%s надто велике"

#: src/factor.c:2454
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ЧИСЛО]...\n"
"       або:    %s КЛЮЧ\n"

#: src/factor.c:2459
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"Виводить прості множники для кожного вказаного цілого ЧИСЛА. Якщо\n"
"числа не вказано у командному рядку, читати дані зі стандартного джерела.\n"
"\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "поточний каталог недоступний"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "не вдалося змінити каталог на %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "не вдалося виконати stat для поточного каталогу (наразі %s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:38
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:270
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Використання: %s [-ШИРИНА] [ПАРАМЕТР]... [ФАЙЛ]...\n"

#: src/fmt.c:271
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"Переформатує кожен абзац у ФАЙЛІ(ах) та виводить на стандартне виведення.\n"
"Параметр -ШИРИНА є скороченою формою --width=ЧИСЛО.\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin       зберігати відступи двох перших рядків\n"
"  -p, --prefix=РЯДОК       форматувати лише рядки, що починаються з РЯДОК,\n"
"                             зберігаючи при цьому префікс рядків\n"
"  -s, --split-only         розбивати довгі рядки, але не заповнювати\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph   відступ першого рядка, відмінний від другого\n"
"  -u, --uniform-spacing    один пробіл після слова, два після речення\n"
"  -w, --width=ЧИСЛО        максимальна довжина рядка (типово 75 позицій)\n"
"  -g, --goal=ДОВЖИНА       остаточна довжина (типово 93% довжини)\n"

#: src/fmt.c:359
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"неправильний ключ -- %c; -ШИРИНА розпізнається, лише якщо це перший\n"
"аргумент, у іншому випадку вказуйте -w N"

#: src/fmt.c:405 src/fmt.c:416
#, c-format
msgid "invalid width: %s"
msgstr "неприпустима довжина: %s"

#: src/fold.c:70
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
msgstr ""
"Розбиває рядки у ФАЙЛІ(ах) (типово читає стандартний ввід) та виводить\n"
"на стандартний вивід.\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         прочитати байти, а не стовпчики\n"
"  -s, --spaces        розбивати лише на пробілах\n"
"  -w, --width=ЧИСЛО   використовувати вказане ЧИСЛО стовпчиків, а не 80\n"

#: src/fold.c:288 src/pr.c:832
#, c-format
msgid "invalid number of columns: %s"
msgstr "неправильне число стовпчиків: %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:29 src/realpath.c:33 src/stdbuf.c:37 src/timeout.c:78
#: src/truncate.c:37
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:65
#, c-format
msgid "Usage: %s\n"
msgstr "Використання: %s\n"

#: src/getlimits.c:69
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Ліміти платформи виводу обмежені у форматі придатному для використання у "
"сценаріях.\n"
"\n"

#: src/group-list.c:69 src/id.c:365 src/setuidgid.c:184
#, c-format
msgid "failed to get groups for user %s"
msgstr "помилка при отриманні груп користувачів %s"

#: src/group-list.c:74 src/id.c:370
#, c-format
msgid "failed to get groups for the current process"
msgstr "не вдалося отримати групи для поточного процесу"

#: src/group-list.c:114
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "не вдалося визначити назву групи для ID %lu"

#: src/groups.c:53
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/groups.c:54
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"Вивести дані щодо участі у групах для кожного ІМЕНІ КОРИСТУВАЧА, якщо імені "
"не\n"
"вказано, буде показано дані для поточного процесу (може бути іншим, якщо "
"було\n"
"змінено базу даних груп).\n"

#: src/groups.c:105 src/id.c:233
#, c-format
msgid "cannot get real UID"
msgstr "не вдалося встановити справжній UID"

#: src/groups.c:110 src/id.c:241
#, c-format
msgid "cannot get effective GID"
msgstr "не вдалося отримати ефективний GID"

#: src/groups.c:115 src/id.c:246
#, c-format
msgid "cannot get real GID"
msgstr "не вдалося встановити справжній GID"

#: src/groups.c:128 src/id.c:206
#, c-format
msgid "%s: no such user"
msgstr "%s: такого користувача не існує"

#: src/head.c:109
msgid ""
"Print the first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Виводити перші 10 рядків кожного ФАЙЛА на стандартний вивід.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводити заголовок з назвою файла.\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"

#: src/head.c:117
msgid ""
"  -c, --bytes=[-]K         print the first K bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             K bytes of each file\n"
"  -n, --lines=[-]K         print the first K lines instead of the first 10;\n"
"                             with the leading '-', print all but the last\n"
"                             K lines of each file\n"
msgstr ""
"  -c, --bytes=[-]K         вивести перші K байтів кожного файла;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх байтів кожного файла\n"
"  -n, --lines=[-]K         вивести перші K рядків кожного файла, а не 10;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх рядків кожного файла\n"

#: src/head.c:125
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent   не виводити заголовки з назвами файлів\n"
"  -v, --verbose           завжди виводити заголовки з назвами файлів\n"

#: src/head.c:131
msgid ""
"\n"
"K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
msgstr ""
"\n"
"Після ЧИСЛА блоків та байт може стоять один з множників:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"

#: src/head.c:154
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: файл надто скоротився"

#: src/head.c:227 src/head.c:1051
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: число байт надто великий"

#: src/head.c:440
#, c-format
msgid "%s: cannot lseek back to original position"
msgstr "ю%s: не вдалося вернуть вказівник файла на початкову позицію"

#: src/head.c:612 src/head.c:691 src/tail.c:449
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: не вдалося перейти до позиції %s"

#: src/head.c:673
#, c-format
msgid "%s: failed to reset file pointer"
msgstr "%s: не вдалося скинути вказівник на файл"

#: src/head.c:798
#, c-format
msgid "cannot reposition file pointer for %s"
msgstr "не вдалося перемістити вказівник файла для %s"

#: src/head.c:885
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s настільки великий, що його неможливо машинно представити"

#: src/head.c:886
msgid "number of lines"
msgstr "число рядків"

#: src/head.c:886
msgid "number of bytes"
msgstr "число байт"

#: src/head.c:893 src/tail.c:1947
msgid "invalid number of lines"
msgstr "неправильна кількість рядків"

#: src/head.c:894 src/tail.c:1948
msgid "invalid number of bytes"
msgstr "неправильна кількість байт"

#: src/head.c:981 src/head.c:1039
#, c-format
msgid "invalid trailing option -- %c"
msgstr "неправильний завершальний ключ -- '%c'"

#: src/hostid.c:42
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]\n"
"Вивести числовий ідентифікатор (шістнадцяткове) для поточного вузла.\n"
"\n"

#: src/hostname.c:56
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Використання: %s [НАЗВА]\n"
"       або:    %s КЛЮЧ\n"
"Виводить або встановлює назву цієї системи.\n"
"\n"

#: src/hostname.c:94
#, c-format
msgid "cannot set name to %s"
msgstr "не вдалося встановити назву у %s"

#: src/hostname.c:97
#, c-format
msgid "cannot set hostname; this system lacks the functionality"
msgstr "не вдалося встановити основну назву -- ця система не має такої функції"

#: src/hostname.c:105
#, c-format
msgid "cannot determine hostname"
msgstr "не вдалося визначити назву машини"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:38 src/touch.c:42
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:81
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]\n"

#: src/id.c:82
msgid ""
"Print user and group information for the specified USERNAME,\n"
"or (when USERNAME omitted) for the current user.\n"
"\n"
"  -a              ignore, for compatibility with other versions\n"
"  -Z, --context   print only the security context of the current user\n"
"  -g, --group     print only the effective group ID\n"
"  -G, --groups    print all group IDs\n"
"  -n, --name      print a name instead of a number, for -ugG\n"
"  -r, --real      print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user      print only the effective user ID\n"
msgstr ""
"Виводить відомості про ім'я та групу КОРИСТУВАЧА або (якщо не\n"
"вказано КОРИСТУВАЧА) для поточного користувача.\n"
"\n"
"  -a              ігнорувати, визначено лише для сумісності\n"
"  -Z, --context   виводити лише контекст безпеки поточного користувача\n"
"  -g, --group     виводити лише ID групи\n"
"  -G, --groups    виводити лише додаткові групи\n"
"  -n, --name      виводити назва замість номера, для ключів -ugG\n"
"  -r, --real      виводити дійсні, а не ефективні ID, для ключів -ugG\n"
"  -u, --user      виводити лише ID користувача\n"

#: src/id.c:96
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Якщо КЛЮЧІ не вказані, виводить стандартний набір корисних відомостей.\n"

#: src/id.c:140
#, c-format
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) працює, якщо ядро має підтримку SELinux"

#: src/id.c:175
#, c-format
msgid "cannot print security context when user specified"
msgstr "не можна виводити контекст безпеки, коли вказано користувача"

#: src/id.c:178
#, c-format
msgid "cannot print \"only\" of more than one choice"
msgstr "не можна виводити \"only\" для більш ніж одного варіанту"

#: src/id.c:185
#, c-format
msgid "cannot print only names or real IDs in default format"
msgstr "не можна виводити лише назви або дійсні ID у типовому форматі"

#: src/id.c:199
#, c-format
msgid "can't get process context"
msgstr "не можна отримати контекст процесу"

#: src/id.c:224
#, c-format
msgid "cannot get effective UID"
msgstr "не вдалося отримати ефективний UID"

#: src/id.c:311
#, c-format
msgid "cannot find name for user ID %s"
msgstr "не вдалося визначити ім'я користувача для ID %s"

#: src/id.c:329
#, c-format
msgid "uid=%s"
msgstr "uid=%s"

#: src/id.c:334
#, c-format
msgid " gid=%s"
msgstr " gid=%s"

#: src/id.c:341
#, c-format
msgid " euid=%s"
msgstr " euid=%s"

#: src/id.c:349
#, c-format
msgid " egid=%s"
msgstr " egid=%s"

#: src/id.c:377
msgid " groups="
msgstr " групи="

#: src/id.c:393
#, c-format
msgid " context=%s"
msgstr " контекст=%s"

#: src/install.c:373
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "попередження: %s: не вдалося змінити контекст у %s"

#: src/install.c:414
#, c-format
msgid "creating directory %s"
msgstr "створення каталогу %s"

#: src/install.c:482
#, c-format
msgid "cannot change ownership of %s"
msgstr "не вдалося змінити власника %s"

#: src/install.c:506
#, c-format
msgid "cannot set time stamps for %s"
msgstr "не вдалося встановити мітки часу для %s"

#: src/install.c:527 src/split.c:426 src/timeout.c:439
#, c-format
msgid "fork system call failed"
msgstr "системний виклик fork завершився помилкою"

#: src/install.c:531
#, c-format
msgid "cannot run %s"
msgstr "не вдалося запустити %s"

#: src/install.c:535
#, c-format
msgid "waiting for strip"
msgstr "очікування strip"

#: src/install.c:537
#, c-format
msgid "strip process terminated abnormally"
msgstr "процес strip завершився помилкою"

#: src/install.c:558
#, c-format
msgid "invalid user %s"
msgstr "неправильний користувач %s"

#: src/install.c:594
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ПРИЗНАЧЕННЯ\n"
"       або    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"
"       або    %s [КЛЮЧ]... -d КАТАЛОГ...\n"

#: src/install.c:601
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"Ця програма для встановлення копіює файли (часто щойно зібрані) до "
"вказаного\n"
"вами місця призначення. Якщо вам потрібно отримати і встановити готовий до\n"
"використання пакунок у системі GNU/Linux, вам краще скористатися програмою\n"
"для керування пакунками, зокрема yum(1) або apt-get(1).\n"
"\n"
"У перших трьох формах копіює ДЖЕРЕЛО до ПРИЗНАЧЕННЯ або декілька\n"
"ДЖЕРЕЛ до вже створеного КАТАЛОГу, встановлюючи режими доступу та\n"
"власника/групу.  В четвертій формі створює всі компоненти вказаних\n"
"КАТАЛОГІВ.\n"

#: src/install.c:615
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]  створити резервну копію перед вилученням\n"
"  -b                  те саме, що і --backup, але без аргументу\n"
"  -c                  (ігнорується)\n"
"  -C, --compare       порівняти кожну пару файлів джерела і призначення і,\n"
"                        за певних умов, не змінювати призначення\n"
"  -d, --directory     вважати всі аргументи каталогами; створювати всі\n"
"                        компоненти вказаних каталогів\n"

#: src/install.c:624
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  створювати всі початкові складові ЦІЛІ крім\n"
"                        останньої, потім копіювати ДЖЕРЕЛО у ЦІЛЬ\n"
"  -g, --group=ГРУПА   встановлювати ГРУПУ, а не групу поточного процесу\n"
"  -m, --mode=РЕЖИМ    встановлювати РЕЖИМ (як chmod), а не rwxr-xr-x\n"
"  -o, --owner=ВЛАСНИК встановлювати ВЛАСНИКА (лише для суперкористувача)\n"

#: src/install.c:631
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps встановлювати цільовим файлам час\n"
"                        доступу/зміни як у їх файлів-ДЖЕРЕЛ\n"
"  -s, --strip         вилучати таблиці символів\n"
"      --strip-program=ПРОГРАМА  програма, що використовується для вилучення\n"
"  -S, --suffix=СУФІКС використовувати для резервних копій заданий СУФІКС\n"
"  -t, --target-directory=КАТАЛОГ копіювати всі аргументи-ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory вважати ЦІЛЬ звичайним файлом\n"
"  -v, --verbose       виводити назву кожного створюваного каталогу\n"

#: src/install.c:641
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z, --context=CONTEXT  set SELinux security context of files and "
"directories\n"
msgstr ""
"      --preserve-context  зберегти контекст безпеки SELinux\n"
"  -Z, --context=CONTEXT  встановити контекст безпеки SELinux для файлів та "
"каталогів\n"

#: src/install.c:859
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"Попередження: --preserve-context ігнорується; ядро не підтримує SELinux."

#: src/install.c:869
#, c-format
msgid "WARNING: ignoring --context (-Z); this kernel is not SELinux-enabled"
msgstr "Попередження: --context (-Z) ігнорується; ядро не підтримує SELinux."

#: src/install.c:886
#, c-format
msgid "the strip option may not be used when installing a directory"
msgstr "при встановленні каталогу не можна вживати ключ strip"

#: src/install.c:889
#, c-format
msgid "target directory not allowed when installing a directory"
msgstr "при встановленні каталогу не можна вказувати цільовий каталог"

#: src/install.c:893
#, c-format
msgid "cannot force target context to %s and preserve it"
msgstr "не можна примусово вказувати контекст та %s зберігати його "

#: src/install.c:947 src/mkdir.c:201 src/stdbuf.c:326
#, c-format
msgid "invalid mode %s"
msgstr "неправильний режим %s"

#: src/install.c:954
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""
"ПОПЕРЕДЖЕННЯ: ігноруємо параметр --strip-program, оскільки параметр -s не "
"вказано"

#: src/install.c:959
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr ""
"параметри --compare (-C) і --preserve-timestamps не можна використовувати "
"одночасно"

#: src/install.c:966
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "параметри --compare (-C) і --strip не можна використовувати одночасно"

#: src/install.c:972
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""
"параметр --compare (-C) пропускається, якщо ви вкажете режим з заборонними "
"бітами"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:40 src/sort.c:66
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:191
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"Для кожної пари вхідних рядків з однаковими полями виводить рядок\n"
"до стандартного виведення. Типово спільне поле вважається першим, поля\n"
"розділюються знаками пробілів. Якщо один з ФАЙЛІВ вказано як -, читає\n"
"стандартний потік введення.\n"
"\n"
"  -a НОМЕР           виводити рядки що не мають пари з файла з вказаним\n"
"                       номером (1 або 2)\n"
"  -e РЯДОК           замінювати при виводі порожні рядки вказаним РЯДКОМ\n"

#: src/join.c:200
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case  ігнорувати регістр літер при порівнянні полів\n"
"  -j ПОЛЕ            еквівалентно '-1 ПОЛЕ -2 ПОЛЕ'\n"
"  -o ФОРМАТ          виводити відповідно до ФОРМАТУ\n"
"  -t ЗНАК            використовувати ЗНАК розділення полів вводу та виводу\n"

#: src/join.c:206
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v НОМЕР          як -а НОМЕР, але не виводити наявні пари рядків\n"
"  -1 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 1\n"
"  -2 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 2\n"
"  --check-order     перевірити, чи впорядковано належним чином введення,\n"
"                      навіть якщо для всіх вхідних рядків є пари\n"
"  --nocheck-order   не перевіряти, чи впорядковано вхідні дані\n"
"  --header          вважати перший рядок кожного файла заголовками полів,\n"
"                      вивести їх без спроб знайти для них пари\n"

#: src/join.c:218
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"Якщо не вказано -t ЗНАК, початкові знаки пробілів розділяють поля та\n"
"ігноруються, у іншому випадку поля розділюються ЗНАКОМ. ПОЛЕ — це\n"
"номер поля, що відраховується від 1. ФОРМАТ — це один або декілька\n"
"розділених комами або знаками пробілів описів формату:\n"
"«НОМЕР_ФАЙЛА.ПОЛЕ» або «0». Типово ФОРМАТ виводить спільне поле,\n"
"інші поля з ФАЙЛА1 та інші поля з ФАЙЛА2, розділені ЗНАКом.\n"
"Якщо ФОРМАТом є ключове слово «auto», перший рядок кожного з файлів\n"
"визначає кількість полів виведення для кожного рядка.\n"
"\n"
"Важливе: ФАЙЛ1 та ФАЙЛ2 має бути впорядковано за спільними полями.\n"
"Наприклад, скористайтеся командою « sort -k 1b,1 » якщо «join» вказано без\n"
"параметрів, або « join -t '' », якщо «sort» вказано без параметрів.\n"
"Зауважте, що під час порівняння буде використано правила, вказані за\n"
"допомогою змінної LC_COLLATE. Якщо вхідні дані не впорядковано і\n"
"якісь з рядків не може бути об'єднано, буде показано повідомлення\n"
"з попередженням про це.\n"

#: src/join.c:403
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>: не впорядковано: %.*s"

#: src/join.c:840 src/join.c:1038
#, c-format
msgid "invalid field number: %s"
msgstr "неправильний номер поля: %s"

#: src/join.c:861 src/join.c:870
#, c-format
msgid "invalid field specifier: %s"
msgstr "неправильна специфікація поля: %s"

#: src/join.c:877
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "неправильний номер файла у специфікації поля: %s"

#: src/join.c:920
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "поля об'єднання %lu, %lu несумісні"

#: src/join.c:1049
#, c-format
msgid "conflicting empty-field replacement strings"
msgstr "конфліктуючі рядки заміни для порожнього поля"

#: src/join.c:1101 src/sort.c:4468
#, c-format
msgid "multi-character tab %s"
msgstr "багатознакова табуляція %s"

#: src/join.c:1105 src/sort.c:4473
#, c-format
msgid "incompatible tabs"
msgstr "несумісна табуляція"

#: src/join.c:1174
#, c-format
msgid "both files cannot be standard input"
msgstr "замість обох файлів не можна вказувати одночасно стандартний ввід"

#: src/kill.c:76
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Використання: %s [-s СИГНАЛ | -СИГНАЛ] PID...\n"
"      або:  %s -l [СИГНАЛ]...\n"
"      або:  %s -t [СИГНАЛ]...\n"

#: src/kill.c:82
msgid "Send signals to processes, or list signals.\n"
msgstr "Надсилає процесам сигнали або виводить сигнали.\n"

#: src/kill.c:88
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=СИГНАЛ, -СИГНАЛ\n"
"              вказує назву або номер сигналу, що надсилається\n"
"  -l, --list  виводить назви сигналів або переводить назви у номери та "
"назад\n"
"  -t, --table виводить таблицю з інформацією про сигнали\n"

#: src/kill.c:96
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"СИГНАЛ може бути назвою сигналу, як HUP, або номером сигналу, як\n"
"'1', або кодом завершення процесу, перерваного сигналом.\n"
"PID є цілим числом; якщо воно є від'ємним, то означає групу\n"
"процесів.\n"

#: src/kill.c:205
#, c-format
msgid "%s: invalid process id"
msgstr "%s: неправильний ідентифікатор процесу"

#: src/kill.c:259
#, c-format
msgid "invalid option -- %c"
msgstr "неправильний ключ -- '%c'"

#: src/kill.c:268
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: задано декілька сигналів"

#: src/kill.c:282
#, c-format
msgid "multiple -l or -t options specified"
msgstr "задано декілька ключів -l або -t"

#: src/kill.c:299
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "не можна об'єднувати сигнал з -l або -t"

#: src/kill.c:305
#, c-format
msgid "no process ID specified"
msgstr "не вказаний ідентифікатор процесу"

#: src/libstdbuf.c:109
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "не вдалося розмістити буфер stdio у %<PRIuMAX> байтів\n"

#: src/libstdbuf.c:116
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "некоректний режим буферизації %s для %s\n"

#: src/libstdbuf.c:124
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "не вдалося змінити режим буферизації %s у значення %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:50
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ1 ФАЙЛ2\n"
"       або:    %s КЛЮЧ\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Викликає функцію link для створення посилання з назвою ФАЙЛ2 на існуючий "
"ФАЙЛ1.\n"
"\n"

#: src/link.c:90
#, c-format
msgid "cannot create link %s to %s"
msgstr "не вдалося створити посилання %s на %s"

#: src/ln.c:190
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: не допускається створювати жорсткі посилання на каталоги"

#: src/ln.c:255
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: не вдалося перезаписати каталог"

#: src/ln.c:260
#, c-format
msgid "%s: replace %s? "
msgstr "%s: замінити %s? "

#: src/ln.c:345
#, c-format
msgid "failed to create symbolic link %s"
msgstr "не вдалося створити символічне посилання %s"

#: src/ln.c:346
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "не вдалося створити символічне посилання %s -> %s"

#: src/ln.c:348
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "не вдалося створити жорстке посилання на %.0s%s"

#: src/ln.c:351
#, c-format
msgid "failed to create hard link %s"
msgstr "не вдалося створити жорстке посилання %s"

#: src/ln.c:352
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "не вдалося створити жорстке посилання %s => %s"

#: src/ln.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME   (1st form)\n"
"  or:  %s [OPTION]... TARGET                  (2nd form)\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY     (3rd form)\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...  (4th form)\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ПРИЗНАЧЕННЯ ПОСИЛАННЯ  (1-а форма)\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ                 (2-а форма)\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ... КАТАЛОГ      (3-я форма)\n"
"         або  %s [КЛЮЧ]... -t КАТАЛОГ ПРИЗНАЧЕННЯ...   (4-а форма)\n"

#: src/ln.c:381
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"У першій формі створюється посилання на ПРИЗНАЧЕННЯ з назвою ПОСИЛАННЯ.\n"
"У другий формі створюється посилання на ПРИЗНАЧЕННЯ у поточному каталозі.\n"
"У третій та четвертій формах створюється посилання на кожне ПРИЗНАЧЕННЯ у\n"
"вказаному КАТАЛОЗІ. Типово створюються жорсткі посилання, а з ключем --"
"symbolic\n"
"— символічні. Типово, кожне призначення (назва нового посилання) не повинно\n"
"існувати. У разі створення жорстких посилань кожне ПРИЗНАЧЕННЯ має "
"існувати.\n"
"Символічні посилання можуть містити довільний текст. Під час пізнішого\n"
"визначення ПРИЗНАЧЕННЯ відносне посилання визначатиметься на основі\n"
"батьківського каталогу посилання.\n"

#: src/ln.c:394
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]     робити резервну копію кожного цільового файла\n"
"  -b                          те ж, що й --backup, але не приймає аргумент\n"
"  -d, -F, --directory         дозволяє суперкористувачу створювати жорсткі\n"
"                              посилання на каталоги (примітка: ймовірно, це\n"
"                              не вийде через системні обмеження, навіть для\n"
"                              суперкористувача)\n"
"  -f, --force                 вилучати вже створені цільові файли\n"

#: src/ln.c:402
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           запитувати, чи слід вилучати призначення\n"
"  -L, --logical               розіменувати призначення, які є символічними\n"
"                                посиланнями\n"
"  -n, --no-dereference        вважати посилання звичайним файлом, якщо воно\n"
"                                є символічним посиланням на каталог\n"
"  -P, --physical              створювати жорсткі посилання безпосередньо на\n"
"                                символічні посилання\n"
"  -r, --relative              створювати символічні посилання відносно "
"розташування\n"
"                                посилання\n"
"  -s, --symbolic              створювати символічні посилання, замість "
"жорстких\n"

#: src/ln.c:411
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=СУФІКС         вказує СУФІКС для резервних копій\n"
"  -t, --target-directory=КАТАЛОГ  вказує КАТАЛОГ, у якому створювати\n"
"                                 посилання\n"
"  -T, --no-target-directory   завжди вважати НАЗВУ_ПОСИЛАННЯ звичайним "
"файлом\n"
"  -v, --verbose               виводити назву кожного файла перед створенням "
"посилання\n"

#: src/ln.c:433
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"Використання -s призводить до ігнорування -L і -P. Інакше, останній "
"параметр\n"
"визначає роботу програми, якщо призначенням є символічне посилання.\n"
"Типове значення: %s.\n"

#: src/ln.c:554
#, c-format
msgid "cannot combine --target-directory and --no-target-directory"
msgstr ""
"не можна одночасно використовувати --target-directory і --no-target-directory"

#: src/ln.c:588
#, c-format
msgid "cannot do --relative without --symbolic"
msgstr "не можна виконувати --relative без --symbolic"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME: невідомо"

#: src/logname.c:39 src/sync.c:40
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Використання: %s [КЛЮЧ]\n"

#: src/logname.c:40
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Виводить ім'я поточного користувача.\n"
"\n"

#: src/logname.c:84
#, c-format
msgid "no login name"
msgstr "реєстраційне ім'я відсутнє"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:732
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:745
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1580
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "проігноровано неправильне значення змінної оточення QUOTING_STYLE: %s"

#: src/ls.c:1599
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "проігноровано неправильну довжину змінної середовища COLUMNS: %s"

#: src/ls.c:1629
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"проігноровано неправильний розмір табуляції змінної оточення TABSIZE: %s"

#: src/ls.c:1750 src/ptx.c:1975
#, c-format
msgid "invalid line width: %s"
msgstr "неправильна довжина рядка: %s"

#: src/ls.c:1824
#, c-format
msgid "invalid tab size: %s"
msgstr "неправильний розмір табуляції: %s"

#: src/ls.c:2033
#, c-format
msgid "invalid time style format %s"
msgstr "неправильний формат часу %s"

#: src/ls.c:2057
msgid "Valid arguments are:\n"
msgstr "Коректні аргументи:\n"

#: src/ls.c:2061
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  - +ФОРМАТ (наприклад +%H:%M) для формату у стилі 'date'\n"

#: src/ls.c:2096
#, c-format
msgid "error initializing month strings"
msgstr "помилка під час ініціалізації рядків місяців"

#: src/ls.c:2407
#, c-format
msgid "unrecognized prefix: %s"
msgstr "не розпізнаний префікс: %s"

#: src/ls.c:2437
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "незрозуміле значення змінної оточення LS_COLORS"

#: src/ls.c:2514 src/pwd.c:161
#, c-format
msgid "cannot open directory %s"
msgstr "не вдалося відкрити каталог %s"

#: src/ls.c:2529
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "не вдалося визначити пристрій та inode для %s"

#: src/ls.c:2538
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: пропущено вже перелічений каталогу"

#: src/ls.c:2615 src/pwd.c:229
#, c-format
msgid "reading directory %s"
msgstr "читання каталогу %s"

#: src/ls.c:2630
#, c-format
msgid "closing directory %s"
msgstr "закриття каталогу %s"

#: src/ls.c:3302
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "не вдалося порівняти назви файлів %s та %s"

#: src/ls.c:4721
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"Виводить дані щодо ФАЙЛів (типово у поточному каталозі).\n"
"Впорядковує у алфавітному порядку, якщо не вказано ні --sort, ні один з\n"
"параметрів -cftuSUX.\n"

#: src/ls.c:4728
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  не ігнорувати записи, що починаються з .\n"
"  -A, --almost-all           не виводити неявні . і ..\n"
"      --author               разом з -l, виводити автора кожного файла\n"
"  -b, --escape               виводити вісімкові керівні послідовності\n"
"                             замість неграфічних знаків\n"

#: src/ls.c:4734
msgid ""
"      --block-size=SIZE      scale sizes by SIZE before printing them.  E."
"g.,\n"
"                               '--block-size=M' prints sizes in units of\n"
"                               1,048,576 bytes.  See SIZE format below.\n"
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information)\n"
"                               with -l: show ctime and sort by name\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"      --block-size=РОЗМІР    використовувати блоки розміром РОЗМІР.\n"
"\n"
"                               Наприклад, «--block-size=M» виводить розміри "
"у\n"
"                               одиницях 1.048.576 байтів. Формат РОЗМІРу "
"наведено\n"
"                               нижче.\n"
"  -B, --ignore-backups       не виводити файли, що закінчуються на ~\n"
"  -c                         з -lt: сортувати за часом зміни; з -l:\n"
"                              виводити час зміни та впорядкувати за назвою,\n"
"                              у іншому випадку впорядкувати за часом зміни,\n"
"                              найновіші — перші\n"

#: src/ls.c:4744
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output.  WHEN defaults to "
"'always'\n"
"                               or can be 'never' or 'auto'.  More info "
"below\n"
"  -d, --directory            list directory entries instead of contents,\n"
"                               and do not dereference symbolic links\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         виводити список у декілька колонок\n"
"      --color[=КОЛИ]         вказує, чи позначати типи файлів кольором.\n"
"                               КОЛИ може бути «never» (не позначати),\n"
"                               «always» (виділяти) або «auto» (залежить від\n"
"                               термінала)\n"
"  -d, --directory            виводити назви каталогів, а не їх зміст, а\n"
"                               також не слідувати за символічним посиланням\n"
"  -D, --dired                створити виведені дані у режимі Emacs dired\n"

#: src/ls.c:4752
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         не сортувати, вмикає -aU, вимикає -lst\n"
"  -F, --classify             додавати до назви індикатор (один з */=>@|)\n"
"      --file-type            аналогічно, але не додавати '*'\n"
"      --format=СЛОВО         across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            виводити повну дату та час\n"

#: src/ls.c:4760
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g                         як і -l, але не виводити власника\n"

#: src/ls.c:4763
msgid ""
"      --group-directories-first\n"
"                             group directories before files.\n"
"                               augment with a --sort option, but any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             показувати каталоги перед файлами.\n"
"                               розширюється за допомогою параметра --sort,\n"
"                               але використання --sort=none (-U) вимикає\n"
"                               групування\n"

#: src/ls.c:4769
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
"  -h, --human-readable       with -l, print sizes in human readable format\n"
"                               (e.g., 1K 234M 2G)\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -G, --no-group             у довгому списку, не виводити назви груп\n"
"  -h, --human-readable       виводити розміри у зручному для людини вигляді\n"
"                               (наприклад, 1K 234M 2G)\n"
"  -H, --si                   те саме, але виводити ступені 1000, а не 1024\n"

#: src/ls.c:4775
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                             that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             слідувати за символьними посиланнями у "
"командному\n"
"                             рядку\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             слідувати за усіма символьними посиланнями у\n"
"                             командному рядку, які вказують на каталог\n"
"      --hide=ШАБЛОН          не виводити файли, що відповідають ШАБЛОНУ\n"
"                             оболонки (скасовується ключами -a або -A)\n"

#: src/ls.c:4785
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
"  -k, --kibibytes            use 1024-byte blocks\n"
msgstr ""
"      --indicator-style=СТИЛЬ додавати до назв елементів індикатор з\n"
"                               вказаним СТИЛЕМ: none (типово), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                з -l, виводити номер i-вузла кожного файла\n"
"  -I, --ignore=ШАБЛОН        не виводити файли, що відповідають ШАБЛОНУ\n"
"  -k, --kibibytes            використовувати 1024-байтові блоки\n"

#: src/ls.c:4795
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         використовувати широкий формат\n"
"  -L, --dereference          показувати інформацію про символьні посилання,\n"
"                               виводити інформацію про файл, на який\n"
"                               посилається посилання\n"
"  -m                         виводити список на всю ширину через кому\n"

#: src/ls.c:4803
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print raw entry names (don't treat e.g. "
"control\n"
"                               characters specially)\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      як -l, але виводити числові UID та GID\n"
"  -N, --literal              виводити назви як є (не обробляти особливим\n"
"                               чином, наприклад, керівні знаки)\n"
"  -o                         як -l, але не виводити інформацію про групу\n"
"  -p,  --indicator-style=slash  додавати індикатор / до каталогів\n"

#: src/ls.c:4811
msgid ""
"  -q, --hide-control-chars   print ? instead of non graphic characters\n"
"      --show-control-chars   show non graphic characters as-is (default\n"
"                             unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always, c, "
"escape\n"
msgstr ""
"  -q, --hide-control-chars   виводити ? замість не графічних символів\n"
"      --show-control-chars   виводити недруковані символи (типово\n"
"                              якщо програма не 'ls' та вивід йде не на\n"
"                              термінал).\n"
"  -Q, --quote-name           взяти назву файла у дужки\n"
"      --quoting-style=СЛОВО  використовувати вид оточення дужками СЛОВО:\n"
"                               literal, shell, shell-always, c, escape\n"

#: src/ls.c:4820
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              зворотний порядок сортування\n"
"  -R, --recursive            рекурсивно виводити каталоги\n"
"  -s, --size                 виводити розмір кожного файла, у блоках\n"

#: src/ls.c:4825
msgid ""
"  -S                         sort by file size\n"
"      --sort=WORD            sort by WORD instead of name: none -U,\n"
"                             extension -X, size -S, time -t, version -v\n"
"      --time=WORD            with -l, show time as WORD instead of "
"modification\n"
"                             time: atime -u, access -u, use -u, ctime -c,\n"
"                             or status -c; use specified time as sort key\n"
"                             if --sort=time\n"
msgstr ""
"  -S                         сортувати за розміром файла\n"
"      --sort=СЛОВО           extension -X, none -U, size -S, time -t,\n"
"                             version -v, status -c, time -t, atime -u,\n"
"                             access -u, use -u\n"
"      --time=СЛОВО           з -l, виводити замість часу зміни час,\n"
"                             вказаний СЛОВОМ: atime, access, use, ctime або\n"
"                             status; якщо --sort=time, використовувати\n"
"                             вказаний час як ключ сортування\n"

#: src/ls.c:4835
msgid ""
"      --time-style=STYLE     with -l, show times using style STYLE:\n"
"                             full-iso, long-iso, iso, locale, +FORMAT.\n"
"                             FORMAT is interpreted like 'date'; if FORMAT "
"is\n"
"                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
"                             non-recent files and FORMAT2 to recent files;\n"
"                             if STYLE is prefixed with 'posix-', STYLE\n"
"                             takes effect only outside the POSIX locale\n"
msgstr ""
"      --time-style=СТИЛЬ     з -l, виводити час використовуючи СТИЛЬ:\n"
"                             full-iso, long-iso, iso, locale, +ФОРМАТ.\n"
"                             ФОРМАТ інтерпретується як у 'date'; якщо\n"
"                             ФОРМАТ - це ФОРМАТ1<переведення-рядка>ФОРМАТ2,\n"
"                             ФОРМАТ1 застосовується до старих файлів, а\n"
"                             ФОРМАТ2 до нових; якщо до СТИЛЮ доданий "
"префікс\n"
"                             'posix-', то він діє лише не у POSIX локалі\n"

#: src/ls.c:4844
msgid ""
"  -t                         sort by modification time, newest first\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         впорядковувати за часом зміни, найновіші "
"спочатку\n"
"  -T, --tabsize=ЧИСЛО        крок табуляції дорівнює ЧИСЛУ замість 8\n"

#: src/ls.c:4848
msgid ""
"  -u                         with -lt: sort by, and show, access time\n"
"                               with -l: show access time and sort by name\n"
"                               otherwise: sort by access time\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         з -lt: сортувати та виводити час доступу\n"
"                              з -l: виводити час доступу та впорядкувати\n"
"                              за назвою\n"
"                              інакше: впорядкувати за часом доступу\n"
"  -U                         не впорядковувати; виводити відповідно до\n"
"                              фізичного розташування\n"
"  -v                         впорядкувати за номерами (версією) у "
"текстовому\n"
"                              форматі\n"

#: src/ls.c:4855
msgid ""
"  -w, --width=COLS           assume screen width instead of current value\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any SELinux security context of each "
"file\n"
"  -1                         list one file per line\n"
msgstr ""
"  -w, --width=ЧИСЛО          задає ширину екрана замість поточного значення\n"
"  -x                         вивід списку рядками, а не стовпчиками\n"
"  -X                         сортувати за розширенням у алфавітному порядку\n"
"  -Z, --context              виводити контекст безпеки SELinux для кожного "
"файла\n"
"  -1                         виводити по одному файлу у рядку\n"

#: src/ls.c:4865
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Використання кольорів для позначення типів файлів вимкнено типово і за\n"
"допомогою --color=never. Якщо визначено --color=auto, ls видаватиме\n"
"коди кольорів, лише якщо стандартне виведення пов'язано з терміналом.\n"
"Змінити параметри можна за допомогою змінної середовища LS_COLORS.\n"
"Для встановлення цієї змінної скористайтеся командою dircolors.\n"

#: src/ls.c:4872
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"Коди виходу:\n"
" 0  все добре,\n"
" 1  незначні проблеми (наприклад, не вдалося отримати доступ до "
"підкаталогу),\n"
" 2  значні проблеми (наприклад, не вдалося отримати доступ до аргументу "
"командного рядка).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:94 src/seq.c:39
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:95
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:96
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:164
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] [ФАЙЛ]...\n"
"Виводить або перевіряє контрольні суми %s (%d-бітові).\n"
"Якщо ФАЙЛ не вказано або вказано як «-», читає стандартне джерело даних.\n"
"\n"

#: src/md5sum.c:174
msgid ""
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"  -b, --binary         читати у двійковому режимі (типово, якщо\n"
"                        читається не термінальне введення)\n"

#: src/md5sum.c:178
msgid "  -b, --binary         read in binary mode\n"
msgstr "  -b, --binary         читати у двійковому режимі\n"

#: src/md5sum.c:181
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check          читати суми %s з ФАЙЛІВ та порівняти їх\n"

#: src/md5sum.c:184
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            створити контрольну суму у форматі BSD\n"

#: src/md5sum.c:188
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text           читати у текстовому режимі (типово, якщо\n"
"                          читається термінальний ввід)\n"

#: src/md5sum.c:192
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text           читати у текстовому режимі (типово)\n"

#: src/md5sum.c:195
msgid ""
"\n"
"The following three options are useful only when verifying checksums:\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"Три наведених нижче параметра використовуються лише при перевірці "
"контрольних сум:\n"
"      --quiet          не виводити підтвердження для кожного успішно "
"перевіреного\n"
"                         файла\n"
"      --status         не виконувати вивід, код завершення показує\n"
"                         успіх перевірки\n"
"  -w, --warn           попереджувати про неправильно сформовані рядки у\n"
"                         списку контрольних сум\n"
"\n"

#: src/md5sum.c:203
msgid ""
"      --strict         with --check, exit non-zero for any invalid input\n"
msgstr ""
"      --strict         з --check вийти з ненульовим кодом для будь-якого "
"некоректного\n"
"                       джерела вхідних даних\n"

#: src/md5sum.c:208
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating input mode ('*' for binary,\n"
"space for text), and name for each FILE.\n"
msgstr ""
"\n"
"Метод обчислення контрольних сум описано у %s. Вхідними даними при\n"
"перевірці мають бути отримані раніше дані виводу цієї програми.\n"
"Типово виводить рядок з контрольною сумою, символ, що вказує на\n"
"тип файла («*» для двійкових, « » для текстових), та назву кожного ФАЙЛа.\n"

#: src/md5sum.c:523
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: надто багато рядків контрольних сум"

#: src/md5sum.c:547
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: неправильно складений рядок контрольної суми %s"

#: src/md5sum.c:572
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: не вдалося відкрити або прочитати\n"

#: src/md5sum.c:595
msgid "FAILED"
msgstr "ПОМИЛКА"

#: src/md5sum.c:597
msgid "OK"
msgstr "Гаразд"

#: src/md5sum.c:621
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: не знайдено правильно складених рядків контрольних сум %s"

#: src/md5sum.c:631
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядок має помилкове форматування"
msgstr[1] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядки мають помилкове форматування"
msgstr[2] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядків мають помилкове форматування"

#: src/md5sum.c:639
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаний файл"
msgstr[1] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказані файли"
msgstr[2] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаних файлів"

#: src/md5sum.c:647
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "ПОПЕРЕДЖЕННЯ: НЕ збіглась %<PRIuMAX> обчислена контрольна сума"
msgstr[1] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислені контрольні суми"
msgstr[2] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислених контрольних сум"

#: src/md5sum.c:760
#, c-format
msgid "--tag does not support --text mode"
msgstr "підтримки --tag у режимі --text не передбачено"

#: src/md5sum.c:766
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "ключ --tag не має сенсу під час перевірки контрольних сум"

#: src/md5sum.c:773
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "ключі --binary та --text не мають сенсу при перевірці контрольних сум"

#: src/md5sum.c:781
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "ключ --status має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:788
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "ключ --warn має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:795
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "ключ --quiet має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:802
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "ключ --strict має сенс лише при перевірці контрольних сум"

#: src/mkdir.c:56 src/rmdir.c:164
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Використання: %s [КЛЮЧ]... КАТАЛОГ...\n"

#: src/mkdir.c:57
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr "Створює DIRECTORY, якщо він ще не існує.\n"

#: src/mkdir.c:63
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
"  -Z, --context=CTX  set the SELinux security context of each created\n"
"                      directory to CTX\n"
msgstr ""
"  -m, --mode=MODE   встановити код доступу (як у chmod)\n"
"  -p, --parents     не виводити помилок якщо каталог існує,\n"
"                     при потребі створювати батьківські каталоги\n"
"  -v, --verbose     виводити повідомлення про кожен створений каталог\n"
"  -Z, --context=CTX  встановити контекст безпеки SELinux кожного створеного\n"
"                      каталогу на CTX\n"

#: src/mkdir.c:168
#, c-format
msgid "created directory %s"
msgstr "створений каталог %s"

#: src/mkfifo.c:51 src/pathchk.c:89
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА...\n"

#: src/mkfifo.c:52
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "Створює іменовані канали (FIFO) для вказаного NAME.\n"

#: src/mkfifo.c:58 src/mknod.c:60
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=РЕЖИМ   встановити права доступу у РЕЖИМ, а не  a=rw - umask\n"

#: src/mkfifo.c:61
msgid ""
"  -Z, --context=CTX  set the SELinux security context of each NAME to CTX\n"
msgstr ""
"  -Z, --context=КОН  встановити контекст безпеки SELinux для кожної НАЗВИ у "
"КОН\n"

#: src/mkfifo.c:121 src/mknod.c:127
#, c-format
msgid "invalid mode"
msgstr "неправильний режим"

#: src/mkfifo.c:126 src/mknod.c:132
#, c-format
msgid "mode must specify only file permission bits"
msgstr "режим повинен визначати лише біти прав доступу до файла"

#: src/mknod.c:52
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА ТИП [ОСНОВНИЙ ДРУГОРЯДНИЙ]\n"

#: src/mknod.c:54
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "Створює спеціальній файл з назвою NAME та типом TYPE.\n"

#: src/mknod.c:63
msgid "  -Z, --context=CTX  set the SELinux security context of NAME to CTX\n"
msgstr ""
"  -Z, --context=КОН  встановити контекст безпеки SELinux для НАЗВА у КОН\n"

#: src/mknod.c:68
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Якщо ТИП -- це b, c або u, необхідно вказувати як ОСНОВНИЙ, так і\n"
"ДРУГОРЯДНИЙ, а якщо ТИП дорівнює p, їх не можна вказувати.  Якщо ОСНОВНИЙ\n"
"або ДРУГОРЯДНИЙ починаються з 0x або 0X, вони інтерпретуються як\n"
"шістнадцяткові числа; якщо починаються з 0 - як вісімкові;\n"
"інакше як десяткові.  ТИП може приймати наступні значення:\n"

#: src/mknod.c:75
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      створити файл блочного пристрою (буферизований)\n"
"  c, u   створити файл символьного пристрою (не буферизований)\n"
"  p      створити іменований канал\n"

#: src/mknod.c:150
msgid "Special files require major and minor device numbers."
msgstr ""
"Для спеціального файла повинні бути вказані основний та другорядний номери "
"пристрою."

#: src/mknod.c:160
msgid "Fifos do not have major and minor device numbers."
msgstr "У файлів-черг немає основного та другорядного числа пристрою."

#: src/mknod.c:176
#, c-format
msgid "block special files not supported"
msgstr "блочні спеціальні файли не підтримуються"

#: src/mknod.c:185
#, c-format
msgid "character special files not supported"
msgstr "знакові спеціальні файли не підтримуються"

#: src/mknod.c:201
#, c-format
msgid "invalid major device number %s"
msgstr "неправильне основне число пристрою %s"

#: src/mknod.c:206
#, c-format
msgid "invalid minor device number %s"
msgstr "неправильне другорядне число пристрою %s"

#: src/mknod.c:211
#, c-format
msgid "invalid device %s %s"
msgstr "неправильний пристрій %s %s"

#: src/mknod.c:225
#, c-format
msgid "invalid device type %s"
msgstr "неправильний тип пристрою %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:68
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ШАБЛОН]\n"

#: src/mktemp.c:69
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"Створити у безпечний спосіб файл або каталог і вивести їхню назву.\n"
"ШАБЛОН має складатися принаймні з трьох «X» поспіль у останньому\n"
"компоненті. Якщо ШАБЛОН не вказано, використовується tmp.XXXXXXXXXX і\n"
"додається параметр --tmpdir.\n"

#: src/mktemp.c:74
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""
"Файли буде створено з правами u+rw, каталоги — u+rwx, мінус обмеження "
"umask.\n"

#: src/mktemp.c:78
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     створити каталог, а не файл\n"
"  -u, --dry-run       не створювати нічого; лише вивести назву (не є "
"безпечним)\n"
"  -q, --quiet         вимкнути діагностику щодо помилок створення файлів і "
"каталогів\n"

#: src/mktemp.c:83
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE.  SUFF must not contain "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X.\n"
msgstr ""
"      --suffix=СУФФ   додавати СУФФ до ШАБЛОНу. СУФФ не повинен містити "
"символів\n"
"                      похилої риски.\n"
"                        Цей параметр буде використано, якщо ШАБЛОН не "
"завершується на X.\n"

#: src/mktemp.c:87
msgid ""
"      --tmpdir[=DIR]  interpret TEMPLATE relative to DIR.  If DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name.\n"
"                        Unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  --tmpdir[=КАТ]   інтерпретувати ШАБЛОН відносно КАТ. Якщо КАТ не\n"
"                     вказано, використовується $TMPDIR, якщо значення не\n"
"                     задане, використовується /tmp., ШАБЛОН не повинен бути\n"
"                     абсолютною назвою. На відміну від -t, ШАБЛОН може\n"
"                     містити похилі риски, але mktemp створюватиме лише\n"
"                     останній компонент таких записів.\n"

#: src/mktemp.c:95
msgid ""
"  -p DIR              use DIR as a prefix; implies -t [deprecated]\n"
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -p КАТАЛОГ          використовувати КАТАЛОГ як префікс; додає -t "
"[застарілий]\n"
"  -t                  вважати ШАБЛОН одиночним компонентом назви файла,\n"
"                        відносно каталогу: $TMPDIR, якщо встановлено; у "
"іншому\n"
"                        разі каталог вказується у -p; інакше /tmp "
"[застаріло]\n"

#: src/mktemp.c:223
#, c-format
msgid "failed to redirect stderr to /dev/null"
msgstr "не вдалося переспрямувати stderr до /dev/null"

#: src/mktemp.c:229
#, c-format
msgid "too many templates"
msgstr "надто багато шаблонів"

#: src/mktemp.c:249
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "у разі визначення --suffix, шаблон %s має завершувати на X"

#: src/mktemp.c:274 src/split.c:1130
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "некоректний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:279
#, c-format
msgid "too few X's in template %s"
msgstr "надто мало символів X у шаблоні %s"

#: src/mktemp.c:292
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "неправильний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:306
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "неправильний шаблон, %s; з --tmpdir, він не може бути абсолютним"

#: src/mktemp.c:326
#, c-format
msgid "failed to create directory via template %s"
msgstr "не вдалося створити каталог через шаблон %s"

#: src/mktemp.c:336
#, c-format
msgid "failed to create file via template %s"
msgstr "не вдалося створити файл через шаблон %s"

#: src/mv.c:292
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"Перейменовує ДЖЕРЕЛО у ПРИЗНАЧЕННЯ, або переміщує ДЖЕРЕЛА до КАТАЛОГУ.\n"

#: src/mv.c:298
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]      створювати резервні копії цільових файлів\n"
"  -b                           те саме, що та --backup, але без аргументу\n"
"  -f, --force                  переписувати існуючі файли без підтвердження\n"
"  -i, --interactive            запитувати підтвердження, перш ніж\n"
"                                 переписувати\n"
"  -n, --no-clobber             не переписувати вже створені файли\n"
"Якщо буде вказано декілька -i, -f, -n, братиметься до уваги лише останній\n"
"параметр.\n"

#: src/mv.c:307
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes вилучає всі кінцеві косі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"
"  -S, --suffix=СУФІКС          перевизначає суфікс для резервних копій\n"

#: src/mv.c:312
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
msgstr ""
"  -t, --target-directory=КАТАЛОГ перемістити всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"
"  -u, --update                 переміщувати лише тоді коли файл ДЖЕРЕЛО\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати виконувані дії\n"

#: src/nice.c:72
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Використання: %s [КЛЮЧ] [КОМАНДА [АРГ]...]\n"

#: src/nice.c:73
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"Запускає КОМАНДУ зі зміненим значенням поступливості, що впливає на "
"пріоритет\n"
"для планувальника.  Якщо КОМАНДУ не вказано, виводиться поточне значення\n"
"поступливості. Допустимі межі: від %d (найбільший пріоритет) до %d\n"
"(найменший).\n"

#: src/nice.c:82
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=N   збільшити поступливість на ціле число N (типово 10)\n"

#: src/nice.c:172
#, c-format
msgid "invalid adjustment %s"
msgstr "неправильна поправка %s"

#: src/nice.c:181
#, c-format
msgid "a command must be given with an adjustment"
msgstr "якщо вказана поправка, треба вказати команду"

#: src/nice.c:188 src/nice.c:199
#, c-format
msgid "cannot get niceness"
msgstr "не вдалося дізнатись поступливість"

#: src/nice.c:205
#, c-format
msgid "cannot set niceness"
msgstr "не вдалося встановити значення поступливості"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:40
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:179
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Виводить кожен ФАЙЛ на стандартний вивід, додаючи номери рядків.\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читається стандартний ввід.\n"

#: src/nl.c:186
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=СТИЛЬ      використовувати СТИЛЬ нумерації рядків "
"тіла\n"
"  -d, --section-delimiter=СС      використовувати СС для розділення\n"
"                                  логічних сторінок\n"
"  -f, --footer-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  нижнього колонтитулу\n"

#: src/nl.c:191
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  верхнього колонтитула\n"
"  -i, --page-increment=ЧИСЛО      крок збільшення номерів рядків\n"
"  -l, --join-blank-lines=ЧИСЛО    вказане ЧИСЛО порожніх рядків вважати\n"
"                                  одним\n"
"  -n, --number-format=ФОРМАТ      використовувати ФОРМАТ для номерів рядків\n"
"  -p, --no-renumber               не починати нумерацію з початку після\n"
"                                  кожної логічної сторінки\n"
"  -s, --number-separator=РЯДОК    додавати РЯДОК після номера\n"

#: src/nl.c:199
msgid ""
"  -v, --starting-line-number=NUMBER  first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=ЧИСЛО перший номер рядка для кожної логічної\n"
"                                  сторінки\n"
"  -w, --number-width=ЧИСЛО        використовувати вказане ЧИСЛО стовпчиків\n"
"                                  для номерів рядків\n"

#: src/nl.c:205
msgid ""
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
msgstr ""
"\n"
"Типово використовуються -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn. СС - це два\n"
"знаки, що розділяють логічні сторінки; якщо вказаний лише один, то я якості\n"
"іншого використовується :.  Вводьте \\\\ щоб отримати \\.  СТИЛЬ вказується\n"
"як один з наступних:\n"

#: src/nl.c:211
msgid ""
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pBRE      number only lines that contain a match for the basic regular\n"
"            expression, BRE\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"  a         нумерувати всі рядки\n"
"  t         нумерувати лише не порожні рядки\n"
"  n         не нумерувати рядки\n"
"  pБРВ      нумерувати лише рядки, частина яких збігається з базовим\n"
"            регулярним виразом БРВ\n"
"\n"
"ФОРМАТ вказується як один з наступних:\n"
"\n"
"  ln   вирівнювати по лівому краю, не виводити початкові нулі\n"
"  rn   вирівнювати по правому краю, не виводити початкові нулі\n"
"  rz   вирівнювати по правому краю, виводити початкові нулі\n"
"\n"

#: src/nl.c:278
#, c-format
msgid "line number overflow"
msgstr "переповнення номера рядка"

#: src/nl.c:478
#, c-format
msgid "invalid header numbering style: %s"
msgstr "неправильний стиль нумерації заголовка: %s"

#: src/nl.c:486
#, c-format
msgid "invalid body numbering style: %s"
msgstr "неправильний стиль нумерації тіла: %s"

#: src/nl.c:494
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "неправильний стиль нумерації нижнього колонтитула: %s"

#: src/nl.c:503
#, c-format
msgid "invalid starting line number: %s"
msgstr "неправильний номер початкового рядка: %s"

#: src/nl.c:512
#, c-format
msgid "invalid line number increment: %s"
msgstr "неправильний приріст номеру рядка: %s"

#: src/nl.c:524
#, c-format
msgid "invalid number of blank lines: %s"
msgstr "неправильна кількість порожніх рядків: %s"

#: src/nl.c:538
#, c-format
msgid "invalid line number field width: %s"
msgstr "неправильна ширина поля для номера рядка: %s"

#: src/nl.c:557
#, c-format
msgid "invalid line numbering format: %s"
msgstr "неправильний формат нумерації рядків: %s"

#: src/nohup.c:53
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/nohup.c:59
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ ігноруючи сигнали обриву термінальної лінії.\n"
"\n"

#: src/nohup.c:65
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from /dev/null.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Якщо стандартний ввід відбувається з терміналу, перенаправте його з /dev/"
"null.\n"
"Якщо стандартний вивід відбувається на термінал, якщо можливо, додайте\n"
" 'ohup.out' або '$HOME/nohup.out'.\n"
"Якщо стандартний потік помилок виводиться на екран, перенаправте його у\n"
"стандартний потік виводу. Щоб зберегти вивід до ФАЙЛа, вкажіть '%s КОМАНДА > "
"ФАЙЛ'.\n"

#: src/nohup.c:127
#, c-format
msgid "failed to render standard input unusable"
msgstr ""
"не вдалося обробити, не вдалося використати стандартне джерело введення"

#: src/nohup.c:131
#, c-format
msgid "ignoring input"
msgstr "всі аргументи проігноровані"

#: src/nohup.c:175
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "вивід додається у %s"

#: src/nohup.c:176
#, c-format
msgid "appending output to %s"
msgstr "виведення додається до %s"

#: src/nohup.c:193
#, c-format
msgid "failed to set the copy of stderr to close on exec"
msgstr ""
"не вдалося зробити так, щоб копія стандартного потоку помилок закрилась на "
"початку виконання"

#: src/nohup.c:198
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "ігнорується ввід та перенаправлення stderr на stdout"

#: src/nohup.c:199
#, c-format
msgid "redirecting stderr to stdout"
msgstr "переспрямування stderr до stdout"

#: src/nohup.c:203
#, c-format
msgid "failed to redirect standard error"
msgstr "не вдалося перенаправити стандартний потік помилок"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:56 src/tty.c:64 src/uname.c:120 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Використання: %s [КЛЮЧ]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"Виводить кількість модулів обробки, доступних поточному процесу,\n"
"може бути меншим за кількість процесорів, які працюватимуть.\n"
"\n"

#: src/nproc.c:63
msgid ""
"     --all       print the number of installed processors\n"
"     --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"     --all       вивести кількість встановлених процесорів\n"
"     --ignore=N  якщо можна, виключити N модулів обробки\n"

#: src/nproc.c:107
#, c-format
msgid "%s: invalid number to ignore"
msgstr "%s: некоректне число для виключення"

#. This is a proper name. See the gettext manual, section Names.
#: src/numfmt.c:35
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/numfmt.c:676
#, c-format
msgid "value too large to be converted: '%s'"
msgstr "значення є надто великим для перетворення: «%s»"

#: src/numfmt.c:680
#, c-format
msgid "invalid number: '%s'"
msgstr "некоректне число: «%s»"

#: src/numfmt.c:684
#, c-format
msgid "rejecting suffix in input: '%s' (consider using --from)"
msgstr ""
"відкидаємо суфікс «%s» у вхідних даних (варто використовувати --from для "
"його збереження)"

#: src/numfmt.c:688
#, c-format
msgid "invalid suffix in input: '%s'"
msgstr "некоректний суфікс у вхідних даних: «%s»"

#: src/numfmt.c:692
#, c-format
msgid "missing 'i' suffix in input: '%s' (e.g Ki/Mi/Gi)"
msgstr "у вхідних даних не вистачає суфікса «i»: «%s» (наприклад Ki/Mi/Gi)"

#: src/numfmt.c:723
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "не вдалося приготувати значення «%Lf» для виводу"

#: src/numfmt.c:787
#, c-format
msgid "invalid unit size: '%s'"
msgstr "некоректна одиниця розміру: «%s»"

#: src/numfmt.c:802 src/numfmt.c:1025 src/numfmt.c:1032
#, c-format
msgid "out of memory (requested %zu bytes)"
msgstr "переповнення пам’яті (запитано %zu байтів)"

#: src/numfmt.c:813
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "Користування: %s [ПАРАМЕТР]... [ЧИСЛО]...\n"

#: src/numfmt.c:816
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"Виконати переформатування числа ЧИСЛО або чисел зі стандартного джерела "
"даних, якщо ЧИСЛО не вказано.\n"

#: src/numfmt.c:820
msgid "      --debug          print warnings about invalid input\n"
msgstr ""
"      --debug          виводити попередження щодо некоректних вхідних даних\n"

#: src/numfmt.c:823
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""
"  -d, --delimiter=X    використовувати X замість пробілу для відокремлення "
"полів\n"

#: src/numfmt.c:826
msgid ""
"      --field=N        replace the number in input field N (default is 1)\n"
msgstr ""
"      --field=N        замісити число у полі N вхідних даних (типове поле -- "
"1)\n"

#: src/numfmt.c:829
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=ФОРМАТ  використовувати форматування у стилі printf;\n"
"                         див. докладний опис форматів нижче\n"

#: src/numfmt.c:833
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=ОДИНИЦЯ   автоматично масштабувати вхідні числа за ОДИНИЦЕЮ; "
"типове значення -- 'none';\n"
"                         див. опис одиниць нижче\n"

#: src/numfmt.c:837
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""
"      --from-unit=N    вказати розмірність одиниці у вхідних даних (замість "
"типової 1)\n"

#: src/numfmt.c:840
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       групувати цифри відповідно до правил локалі, "
"наприклад 1.000.000\n"
"                         (не працюватиме у локалі C/POSIX)\n"

#: src/numfmt.c:844
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=N]     вивести (без перетворення) перші N рядків заголовка;\n"
"                         якщо не вказано, типовим значенням є 1\n"

#: src/numfmt.c:848
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
"                  abort (перервати обробку, типовий), fail (обробити з "
"помилками),\n"
"                  warn (попередити), ignore (ігнорувати).\n"

#: src/numfmt.c:852
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""
"      --padding=N     доповнити виведені дані до N символів.\n"
"                      Використання додатного N призведе до вирівнювання "
"праворуч\n"
"                      Від’ємні N вирівнюватимуть дані ліворуч.\n"
"                      Зауваження: якщо виведені дані будуть довшими за N,\n"
"                      доповнення не відбуватиметься. Типовим є автоматичне "
"доповнення,\n"
"                      якщо буде виявлено пробіли.\n"

#: src/numfmt.c:859
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
"                         up (до більшого), down (до меншого), from-zero (до "
"дальшого\n"
"                         до нуля, типовий), towards-zero (до ближчого до "
"нуля),\n"
"                         nearest (до найближчого цілого\n"

#: src/numfmt.c:863
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
"СУФІКС\n"
"                         у вхідних даних.\n"

#: src/numfmt.c:867
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=ОДИНИЦЯ     автоматично масштабувати виведені числа за ОДИНИЦЕЮ; "
"див. опис одиниць нижче\n"

#: src/numfmt.c:870
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""
"      --to-unit=N      розмірність одиниці у виведених даних (замість "
"типової 1)\n"

#: src/numfmt.c:877
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"Параметри одиниць:\n"

#: src/numfmt.c:880
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""
"  none       без автоматичного масштабування; використання суфіксів призведе "
"до повідомлення про помилку\n"

#: src/numfmt.c:883
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       приймати додаткові одно-/дволітерні суфікси:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"

#: src/numfmt.c:889
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         приймати додаткові однолітерні суфікси:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"

#: src/numfmt.c:894
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        приймати додаткові однолітерні суфікси:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"

#: src/numfmt.c:899
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      приймати додаткові дволітерні суфікси:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"

#: src/numfmt.c:905
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional negative width values\n"
"(%-10f) will left-pad output.\n"
msgstr ""
"\n"
"ФОРМАТ має відповідати виведенню одного аргументу з рухомою крапкою -- "
"«%f».\n"
"Використання лапки (%'f) увімкне параметр --grouping (якщо він підтримується "
"поточною локаллю).\n"
"Додаткове визначення довжини (%10f) призведе до доповнення виведених даних. "
"Додаткові від’ємні\n"
"значення довжини (%-10f) вирівнюватимуть виведення ліворуч.\n"

#: src/numfmt.c:912
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""
"\n"
"Станом виходу буде 0, якщо всі числа у вхідних даних було успішно "
"перетворено.\n"
"Типово, %s припинить обробку після першої ж помилки зі станом виходу 2.\n"
"Якщо буде вказано --invalid='fail', для кожної помилки перетворення буде\n"
"виведено попередження, а станом виходу буде 2. Якщо буде вказано\n"
"--invalid='warn', буде виявлено всіх помилки перетворення, але станом "
"виходу\n"
"буде 0. Якщо буде вказано --invalid='ignore', про помилки перетворення не\n"
"повідомлятиметься, а станом виходу буде 0.\n"

#: src/numfmt.c:921
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df | %s --header --field 2 --to=si\n"
"  $ ls -l | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"Прикладиs:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df | %s --header --field 2 --to=si\n"
"  $ ls -l | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:974 src/seq.c:212
#, c-format
msgid "format %s has no %% directive"
msgstr "формат %s не містить директиву %%"

#: src/numfmt.c:990
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "некоректний формат %s (переповнення ширини)"

#: src/numfmt.c:1007 src/seq.c:229
#, c-format
msgid "format %s ends in %%"
msgstr "формат %s закінчується у %%"

#: src/numfmt.c:1010
#, c-format
msgid "invalid format %s, directive must be %%['][-][N]f"
msgstr "некоректний формат %s, інструкцією має бути %%['][-][N]f"

#: src/numfmt.c:1018 src/seq.c:236
#, c-format
msgid "format %s has too many %% directives"
msgstr "формат %s має надто багато директив %%"

#: src/numfmt.c:1070
#, c-format
msgid "invalid suffix in input '%s': '%s'"
msgstr "некоректний суфікс у вхідних даних «%s»: «%s»"

#: src/numfmt.c:1092
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (варто скористатися --to)"

#: src/numfmt.c:1100
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (обробка значень більше 999Y "
"неможлива)"

#: src/numfmt.c:1184
#, c-format
msgid "large input value '%s': possible precision loss"
msgstr "занадто велике вхідне значення, «%s», можлива втрата точності"

#: src/numfmt.c:1293
#, c-format
msgid "input line is too short, no numbers found to convert in field %ld"
msgstr ""
"надто короткий рядок вхідних даних, у полі %ld не виявлено чисел для "
"форматування"

#: src/numfmt.c:1388
#, c-format
msgid "invalid padding value '%s'"
msgstr "некоректне значення доповнення «%s»"

#: src/numfmt.c:1401
#, c-format
msgid "invalid field value '%s'"
msgstr "некоректне значення поля, «%s»"

#: src/numfmt.c:1430
#, c-format
msgid "invalid header value '%s'"
msgstr "некоректне значення заголовка, «%s»"

#: src/numfmt.c:1456
#, c-format
msgid "--grouping cannot be combined with --format"
msgstr "--grouping не можна використовувати разом з --format"

#: src/numfmt.c:1458
#, c-format
msgid "--padding cannot be combined with --format"
msgstr "--padding не можна використовувати разом з --format"

#: src/numfmt.c:1463
#, c-format
msgid "no conversion option specified"
msgstr "не вказано параметра перетворення"

#: src/numfmt.c:1471
#, c-format
msgid "grouping cannot be combined with --to"
msgstr "grouping не можна використовувати разом з --to"

#: src/numfmt.c:1473
#, c-format
msgid "grouping has no effect in this locale"
msgstr "групування не діє у цій локалі"

#: src/numfmt.c:1486
#, c-format
msgid "--header ignored with command-line input"
msgstr ""
"--header проігноровано, оскільки вхідні дані надходять з командного рядка"

#: src/numfmt.c:1511
#, c-format
msgid "error reading input"
msgstr "помилка під час спроби читання вхідних даних"

#: src/numfmt.c:1520
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "не вдалося перетворити деякі з вхідних чисел"

#: src/od.c:294
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [-abcdfilosx]... [ФАЙЛ] [[+]ЗСУВ[.][b]]\n"
"       або:    %s --traditional [КЛЮЧ]... [ФАЙЛ] [[+]ЗСУВ[.][b] [+][МІТКА][.]"
"[b]]\n"

#: src/od.c:300
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"\n"
"Виводить однозначне (типово байтове вісімкове) представлення ФАЙЛА\n"
"на стандартний вивід.  Якщо ФАЙЛ не вказаний або вказаний як -, читається\n"
"стандартний ввід.\n"
"\n"

#: src/od.c:307
msgid ""
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"Якщо застосовуються й перша, й друга форми виклику, вважається друга\n"
"форма, якщо останній операнд починається на + або (якщо вказані два\n"
"операнда) на цифру.  Операнд ЗСУВ означає -j ЗСУВ.  МІТКА --\n"
"це псевдоадреса першого виведеного байту, збільшується у процесі\n"
"виводу.  Префікс 0x або 0X задає ЗСУВ або МІТКУ як\n"
"шістнадцяткові числа, суфікс . -- як вісімкові, а суфікс b\n"
"помножує на 512.\n"

#: src/od.c:318
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets.  RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=ОСНОВА  виводити зсув у файлах використовуючи\n"
"                              вказану систему числення\n"
"\n"
"                              ОСНОВОЮ може бути одна з літер [doxn],\n"
"                              десяткова, вісімкова, шістнадцяткова або\n"
"                              ніяка\n"
"  -j, --skip-bytes=Н          пропустить перші Н байт\n"

#: src/od.c:323
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars.\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line.\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=N          читати лише N байтів у кожному файлі\n"
"  -S, --strings[=N]           виводити рядки довжиною принаймні N байтів\n"
"                              графічних знаків\n"
"                                Якщо N не вказано, буде використано 3\n"
"  -t, --format=ТИП            вибір формату або форматів виводу\n"
"  -v, --output-duplicates     не позначати знаком * рядки, що не виводяться\n"
"  -w[N], --width[=N]          виводити N байтів у кожному рядку виводу\n"
"                                Якщо N не вказано, буде використано 32\n"
"      --traditional           приймати аргументи у традиційній формі\n"

#: src/od.c:336
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"\n"
"Традиційні специфікації формату можна змішувати, вони акумулюються:\n"
"  -a   синонім -t a,  іменовані знаки\n"
"  -b   синонім -t o1, вісімкові байти\n"
"  -c   синонім -t c,  ASCII-знаки або керівні послідовності з '\\'\n"
"  -d   синонім -t u2, беззнакові десяткові двобайтові одиниці\n"

#: src/od.c:345
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   синонім -t fF, числа з плаваючою комою\n"
"  -i   синонім -t dI, десяткові цілі\n"
"  -l   синонім -t dL, десяткові довгі цілі\n"
"  -o   синонім -t o2, вісімкові двобайтові одиниці\n"
"  -s   синонім -t d2, десяткові двобайтові одиниці\n"
"  -x   синонім -t x2, шістнадцяткові двобайтові одиниці\n"

#: src/od.c:353
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          ASCII character or backslash escape\n"
msgstr ""
"\n"
"\n"
"ТИП може складатись з одного або більше наступних описів:\n"
"  a          іменований знак\n"
"  c          ASCII-знак або керівна послідовність з '\\'\n"

#: src/od.c:360
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[ЧИСЛО]   знакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  f[ЧИСЛО]   число з плаваючою точкою розміром вказане ЧИСЛО байт\n"
"  o[ЧИСЛО]   вісімкове ціле розміром вказане ЧИСЛО байт\n"
"  u[ЧИСЛО]   беззнакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  x[ЧИСЛО]   шістнадцяткове ціле розміром вказане ЧИСЛО байт\n"

#: src/od.c:367
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"Якщо ТИП -- одна з літер [doux], ЧИСЛО можна вказувати як C (char), S "
"(short),\n"
"I (int) або L (long), якщо ТИП дорівнює f, ЧИСЛО може бути F (float),\n"
"D (double) або L (long double).\n"

#: src/od.c:374
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""
"\n"
"Додавання суфікса z до будь-якого типу призведе до виведення видимих "
"символів\n"
"наприкінці кожного рядка виведених даних.\n"

#: src/od.c:379
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
msgstr ""
"\n"
"\n"
"Після ЧИСЛА блоків та байт може стояти один з суфіксів-множників:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"тощо для G, T, P, E, Z, Y.\n"

#: src/od.c:639 src/od.c:759
#, c-format
msgid "invalid type string %s"
msgstr "неправильний рядок типу %s"

#: src/od.c:649
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"неправильно вказаний рядок типу %s;\n"
"ця система не підтримує %lu-байтове цілого типу"

#: src/od.c:770
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"неправильно вказаний тип %s;\n"
"ця система не підтримує %lu-байтове типу з плаваючою комою"

#: src/od.c:828
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "неправильний знак '%c' у рядку типу %s"

#: src/od.c:1053
#, c-format
msgid "cannot skip past end of combined input"
msgstr "неможливо перейти за межу останнього вхідного файла"

#: src/od.c:1609
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""
"неправильно вказана основа системи числення '%c', повинна бути одним з "
"символів [doxn]"

#: src/od.c:1735
#, c-format
msgid "no type may be specified when dumping strings"
msgstr "при дампі рядків не можна вказувати тип"

#: src/od.c:1810
msgid "compatibility mode supports at most one file"
msgstr "у режимі сумісності підтримується не більше одного файла."

#: src/od.c:1831
#, c-format
msgid "skip-bytes + read-bytes is too large"
msgstr "значення skip-bytes + read-bytes надто велике"

#: src/od.c:1874
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "попередження: неправильна ширина %lu; буде використана %d"

#: src/operand2sig.c:69
#, c-format
msgid "%s: invalid signal"
msgstr "%s: неправильний сигнал"

#: src/paste.c:220
#, c-format
msgid "standard input is closed"
msgstr "стандартний ввід закритий"

#: src/paste.c:439
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Виводить на стандартний вивід рядки, складені з відповідних рядків\n"
"вхідних ФАЙЛІВ, що розділяються табуляцією.\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читається стандартний ввід.\n"

#: src/paste.c:447
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=СПИСОК  використовувати замість табуляції знаки зі "
"СПИСКУ\n"
"  -s, --serial             обробляти файли послідовно\n"

#: src/paste.c:508
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "список роздільників завершується неекранованою зворотною рискою: %s"

#: src/pathchk.c:90
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Виявляє некоректні та непереносні конструкції у назвах файлів.\n"
"\n"
"  -p                  перевірка для більшості POSIX-систем\n"
"  -P                  перевірка на порожні назви та початковий «-»\n"
"      --portability   перевірка для усіх POSIX-систем (еквівалентно до -p -"
"P)\n"

#: src/pathchk.c:170
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "початковий '-' у компоненті назві файла %s"

#: src/pathchk.c:196
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "непереносний знак %s у назві файла %s"

#: src/pathchk.c:272
#, c-format
msgid "empty file name"
msgstr "порожня назва файла"

#: src/pathchk.c:314
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: не вдалося визначити максимальну довжину назви файла"

#: src/pathchk.c:325
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "межу %lu перевищено довжиною %lu у назві файла %s"

#: src/pathchk.c:411
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "перевищено обмеження %lu довжиною %lu у компоненті імені файла %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:36 src/uptime.c:45 src/users.c:35 src/who.c:48
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:38 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:242
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:266
msgid "?????"
msgstr "?????"

#: src/pinky.c:314
#, c-format
msgid "Login name: "
msgstr "Реєстраційна назва: "

#: src/pinky.c:317
#, c-format
msgid "In real life: "
msgstr "У реальному житті: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:321
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:341
#, c-format
msgid "Directory: "
msgstr "Каталог: "

#: src/pinky.c:343
#, c-format
msgid "Shell: "
msgstr "Оболонка: "

#: src/pinky.c:362
#, c-format
msgid "Project: "
msgstr "Проект: "

#: src/pinky.c:386
#, c-format
msgid "Plan:\n"
msgstr "План:\n"

#: src/pinky.c:405
msgid "Login"
msgstr "Реєстраційне ім'я'"

#: src/pinky.c:407
msgid "Name"
msgstr "Назва"

#: src/pinky.c:408
msgid " TTY"
msgstr " Термінал"

#: src/pinky.c:410
msgid "Idle"
msgstr "Неактивний"

#: src/pinky.c:411
msgid "When"
msgstr "Коли"

#: src/pinky.c:414
msgid "Where"
msgstr "Де"

#: src/pinky.c:493
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/pinky.c:494
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              використовувати докладний формат виводу\n"
"  -b              опустити у докладному форматі початковий каталог та\n"
"                  оболонку цього користувача\n"
"  -h              опустити у докладному форматі файл проекту цього\n"
"                  користувача\n"
"  -p              опустити у докладному форматі файл плану цього\n"
"                  користувача\n"
"  -s              короткий формат виводу, типово використовується\n"

#: src/pinky.c:502
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              опустити у короткому форматі рядок з заголовками колонок\n"
"  -w              опустити у короткому форматі повне ім'я користувача\n"
"  -i              опустити у короткому форматі повне ім'я користувача та\n"
"                  назву віддаленої машини\n"
"  -q              опустити у короткому форматі повне ім'я користувача,\n"
"                  назву віддаленої машини та час неактивності\n"

#: src/pinky.c:511
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Спрощена програма 'finger';  виводить відомості про користувача.\n"
"У складі файла utmp буде використовуватися %s.\n"

#: src/pinky.c:595
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"не вказано ім'я користувача; при використанні ключа -l треба вказати хоча б "
"одне"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:330
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:331
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:908
#, c-format
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "'--pages=ПЕРША_СТОР[:ОСТАННЯ_СТОР]' пропущений аргумент"

#: src/pr.c:910
#, c-format
msgid "invalid page range %s"
msgstr "некоректний діапазон сторінок %s"

#: src/pr.c:975
#, c-format
msgid "'-l PAGE_LENGTH' invalid number of lines: %s"
msgstr "'-l ДОВЖИНА_СТОРІНКИ' неправильна кількість рядків: %s"

#: src/pr.c:999
#, c-format
msgid "'-N NUMBER' invalid starting line number: %s"
msgstr "'-N НОМЕР' неправильний номер початкового рядка: %s"

#: src/pr.c:1011
#, c-format
msgid "'-o MARGIN' invalid line offset: %s"
msgstr "'-o ПОЛЕ' неправильний зсув: %s"

#: src/pr.c:1052
#, c-format
msgid "'-w PAGE_WIDTH' invalid number of characters: %s"
msgstr "«-w ШИРИНА_СТОРІНКИ» неправильна кількість знаків: %s"

#: src/pr.c:1066
#, c-format
msgid "'-W PAGE_WIDTH' invalid number of characters: %s"
msgstr "«-W ШИРИНА_СТОРІНКИ» неправильна кількість знаків: %s"

#: src/pr.c:1096
#, c-format
msgid "cannot specify number of columns when printing in parallel"
msgstr "неможливо вказати кількість позицій під час паралельного друку"

#: src/pr.c:1100
#, c-format
msgid "cannot specify both printing across and printing in parallel"
msgstr "не можна одночасно вказувати друк вздовж і паралельно."

#: src/pr.c:1196
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "'-%c' зайві знаки або неправильне число у аргументі: %s"

#: src/pr.c:1293
#, c-format
msgid "page width too narrow"
msgstr "сторінка надто вузька"

#: src/pr.c:2353
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"номер початкової сторінки %<PRIuMAX> перевищує загальну кількість сторінок "
"%<PRIuMAX>"

#: src/pr.c:2380
#, c-format
msgid "page number overflow"
msgstr "переповнення номеру сторінок"

#: src/pr.c:2385
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Сторінка %<PRIuMAX>"

#: src/pr.c:2757
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "Розбиває ФАЙЛ(и) на сторінки або колонки під час виведення.\n"

#: src/pr.c:2763
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +ПЕРША_СТОРІНКА[:ОСТАННЯ_СТОРІНКА], --pages=ПЕРША_СТОРІНКА[:"
"ОСТАННЯ_СТОРІНКА]\n"
"                    почати [завершити] друк на ПЕРШІЙ_[ОСТАННІЙ_]СТОРІНЦІ\n"
"  -КІЛЬКІСТЬ, --columns=КІЛЬКІСТЬ\n"
"                    виводити вказану КІЛЬКІСТЬ колонок та виводити їх вниз,\n"
"                    лише коли не вказаний ключ -a.  Балансувати кількість\n"
"                    рядків у колонці на кожній сторінці.\n"

#: src/pr.c:2771
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      виводити колонки поперек, а не вниз; використовується\n"
"                    разом з ключем -ЧИСЛО\n"
"  -c, --show-control-chars\n"
"                    використовувати запис з шапочкою (^G) або зворотною\n"
"                    косою рискою (та вісімковим кодом)\n"
"  -d,  --double-space\n"
"                    вставляти порожній рядок після кожного виведеного рядка\n"

#: src/pr.c:2779
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=ФОРМАТ\n"
"                    використовувати для дати у заголовку вказаний ФОРМАТ\n"
"  -e[ЗНАК[ЧИСЛО]], --expand-tabs[=ЗНАК[ЧИСЛО]]\n"
"                    перетворювати вхідні ЗНАКИ (табуляцію) у вказане ЧИСЛО\n"
"                    пробілів (8)\n"
"  -F, -f, --form-feed\n"
"                    для розділення сторінок вживати знак переносу сторінки,\n"
"                    а не нового рядка (з трьохрядковим заголовком, якщо є\n"
"                    ключ -F, та п'ятирядковим заголовком та кінцівкою, якщо\n"
"                    ключ -F не вказаний)\n"

#: src/pr.c:2789
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h ЗАГОЛОВОК, --header=ЗАГОЛОВОК\n"
"                   використовувати для сторінок центрований ЗАГОЛОВОК, а не\n"
"                   назву файла;  -h \"\" виводить порожній рядок; не\n"
"                   використовуйте -h \"\"\n"
"  -i[ЗНАК[ШИРИНА]], --output-tabs[=ЗНАК[ШИРИНА]]\n"
"                   замінити пробіли ЗНАКАМИ (табуляцію) вказаної ШИРИНИ (8)\n"
"  -J, --join-lines об'єднувати повні рядки, вимкнути урізання рядків (-W),\n"
"                   не вирівнювати колонки, --sep-string[=РЯДОК]\n"
"                   задає розділювачі\n"

#: src/pr.c:2798
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -l, --length=ДОВЖИНА_СТОРІНКИ\n"
"                    встановити ДОВЖИНУ_СТОРІНКИ (66)\n"
"                    (типово кількість рядків тексту рівно 56, а з -F 63)\n"
"  -m, --merge       виводити всі файли паралельно, по одному у стовпчику,\n"
"                    урізати рядка, але з'єднувати повні рядки при -J\n"

#: src/pr.c:2805
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[РОЗД[ЧИСЛО]], --number-lines[=РОЗД[ЧИСЛО]]\n"
"                    нумерувати рядки, використовуючи вказане ЧИСЛО (5) цифр\n"
"                    та РОЗДілювач (табуляцію); типово нумерація починається\n"
"                    з першого вхідного рядка\n"
"  -N, --first-line-number=НОМЕР\n"
"                    почати нумерацію з НОМЕРА з першого рядка першої\n"
"                    сторінки, що виводиться (дивіться +ПЕРША_СТОРІНКА)\n"

#: src/pr.c:2813
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=ПОЛЕ\n"
"                    зсувати кожен рядок на ПОЛЕ (нуль) пробілів (не впливає\n"
"                    на -w або -W); ПОЛЕ додається до ШИРИНА_СТОРІНКИ\n"
"  -r, --no-file-warnings\n"
"                    не попереджати про неможливість відкриття файла\n"

#: src/pr.c:2820
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ЗНАК],--separator[=ЗНАК]\n"
"                    розділяти колонки одним знаком, типово ЗНАК дорівнює\n"
"                    табуляції, без ключа -w, та порожній, якщо є ключ -w\n"
"                    -s[ЗНАК] вимикає урізання рядків для усіх трьох ключів\n"
"                    для колонок (-ЧИСЛО |-a -ЧИСЛО|-m), якщо немає ключа -w\n"

#: src/pr.c:2827
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header  omit page headers and trailers\n"
msgstr ""
"  -S[РЯДОК], --sep-string[=РЯДОК]\n"
"                    розділяти колонки необов'язковим РЯДКОМ;\n"
"                    без -S: розділювач — табуляція, якщо вказано\n"
"                    ключ -J, інакше пробіл (те саме, що -S\" \"); не "
"впливає\n"
"                    на ключі для колонок\n"
"  -t, --omit-header не виводити заголовки\n"

#: src/pr.c:2834
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    не виводити заголовки, ігнорувати символи розриву\n"
"                    сторінки у вхідних файлах\n"
"  -v, --show-nonprinting\n"
"                    використовувати запис з «\\» та вісімковим кодом\n"
"  -w, --width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) у стовпчиках для\n"
"                    виводу у декілька колонок, -s[знак] вимикає (72)\n"

#: src/pr.c:2844
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) символи, усікати рядки,\n"
"                    якщо не вказаний ключ -J; не змінюється ключами -S чи -"
"s\n"

#: src/pr.c:2852
msgid ""
"\n"
"-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE is -, read\n"
"standard input.\n"
msgstr ""
"\n"
"додається -t, якщо PAGE_LENGTH <= 10. Якщо ФАЙЛ не вказано\n"
"або вказаний як -, читає стандартне джерело введення.\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]... [ЗМІННА]...\n"
"Виводить значення вказаних змінних середовища.\n"
"Якщо параметр ЗМІННА не вказано, виводить пари назва-значення для всіх.\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with 0 byte rather than newline\n"
msgstr ""
"  -0, --null     завершувати кожен рядок 0-байтом замість розриву рядка\n"

#: src/printf.c:79
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"попередження: %s: знаки, наступні за знаковою константою, проігноровані"

#: src/printf.c:88
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФОРМАТ [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/printf.c:93
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Виводить АРГУМЕНТ(и) відповідно до ФОРМАТ, або або виконати відповідно до "
"OPTION:\n"
"\n"

#: src/printf.c:99
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом так само, як у функції C printf.\n"
"Приймаються наступні послідовності:\n"
"\n"
"  \\\"     подвійні лапки\n"

#: src/printf.c:117
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xНН    байт з шістнадцятковим кодом НН (від 1 до 2 цифр)\n"
"  \\uНННН  знак Unicode (ISO/IEC 10646) з шістнадцятковим кодом НННН (4 "
"цифри)\n"
"  \\UНННННННН  знак Unicode з шістнадцятковим кодом НННННННН (8 цифр)\n"

#: src/printf.c:123
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%     один знак %\n"
"  %b     інтерпретувати escape-послідовності у АРГУМЕНТІ,\n"
"           крім вісімкових у формі \\0 або \\0ННН\n"
"\n"
"а також всі специфікації формату у стилі C, що закінчуються одним з\n"
"знаків diouxXfeEgGcs; АРГУМЕНТ приводиться до відповідного типу.\n"
"Обробляються також знаки змінної ширини.\n"

#: src/printf.c:148
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: очікується числове значення"

#: src/printf.c:150
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: значення перетворене не повністю"

#: src/printf.c:247 src/printf.c:274
#, c-format
msgid "missing hexadecimal number in escape"
msgstr "неправильна шістнадцяткове число у escape-послідовності"

#: src/printf.c:286
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "неправильна універсальна назва знаку \\%c%0*x"

#: src/printf.c:547
#, c-format
msgid "invalid field width: %s"
msgstr "неправильна ширина поля: %s"

#: src/printf.c:582
#, c-format
msgid "invalid precision: %s"
msgstr "неправильна точність: %s"

#: src/printf.c:609
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: неправильна специфікація перетворення"

#: src/printf.c:692
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "попередження: зайві аргументи проігноровані, починаючи з %s"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "Ф. Пінард"

#: src/ptx.c:419
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (для регулярного виразу %s)"

#: src/ptx.c:1817
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВХІД]... (без -G)\n"
"       або:    %s -G [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/ptx.c:1821
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"Виводить переставлений алфавітний вказівник слів вхідних файлів, включаючи "
"контекст.\n"

#: src/ptx.c:1827
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
msgstr ""
"  -A, --auto-reference           виводити автоматично згенеровані посилання\n"
"  -G, --traditional              увімкнути режим сумісності з System V\n"
"  -F, --flag-truncation=РЯДОК    використовувати РЯДОК для позначення "
"обрізаних рядків\n"

#: src/ptx.c:1832
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=РЯДОК         назва макросу, яку слід використовувати\n"
"                                 замість 'xx'\n"
"  -O, --format=roff              генерувати вивід у вигляді директив roff\n"
"  -R, --right-side-refs          поміщати посилання справа, не діє при -w\n"
"  -S, --sentence-regexp=REGEXP   для кінця рядків або кінця речень\n"
"  -T, --format=tex               генерувати вивід у вигляді директив TeX\n"

#: src/ptx.c:1839
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       регулярний вираз для ключових слів\n"
"  -b, --break-file=ФАЙЛ          ФАЙЛ з символами-розділювачами слів\n"
"  -f, --ignore-case              перетворювати до верхнього регістру при\n"
"                                 сортуванні\n"
"  -g, --gap-size=ЧИСЛО           розмір проміжку між полями виводу,\n"
"                                 виражений у стовпчиках\n"
"  -i, --ignore-file=ФАЙЛ         прочитати перелік ігнорованих слів з ФАЙЛА\n"
"  -o, --only-file=ФАЙЛ           лише прочитати список слів з заданого "
"ФАЙЛА\n"

#: src/ptx.c:1847
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               перше поле у кожній рядку є посиланням\n"
"  -t, --typeset-mode               - не реалізовано -\n"
"  -w, --width=ЧИСЛО              ширина виводу у стовпчиках, без урахування "
"посилань\n"

#: src/ptx.c:1854
msgid ""
"\n"
"With no FILE or if FILE is -, read Standard Input.  '-F /' by default.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"
"Типово вважається вказаним '-F /'.\n"

#: src/ptx.c:1948
#, c-format
msgid "invalid gap width: %s"
msgstr "неправильна ширина інтервалу: %s"

#: src/pwd.c:57
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Виводить повну назву поточного робочого каталогу.\n"
"\n"

#: src/pwd.c:61
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   використовувати PWD з середовища, навіть якщо там "
"містяться символічні посилання\n"
"  -P, --physical  пропустити всі символічні посилання\n"

#: src/pwd.c:166
#, c-format
msgid "failed to chdir to %s"
msgstr "помилка зміни каталогу на %s"

#: src/pwd.c:170 src/pwd.c:277 src/split.c:373
#, c-format
msgid "failed to stat %s"
msgstr "помилка отримання атрибутів %s"

#: src/pwd.c:235
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "у %s не знайдено запис каталогу з відповідним i-node"

#: src/pwd.c:362
#, c-format
msgid "ignoring non-option arguments"
msgstr "аргументи, що не є ключами проігноровані"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/rm.c:135 src/shred.c:147
#: src/stat.c:1349 src/touch.c:212
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Виводить значення символічного посилання або канонічну назву файла\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                всі компоненти пути, крім останнього,\n"
"                                повинні існувати\n"
"  -e, --canonicalize-existing   отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням у кожній компоненті вказаного "
"пути;\n"
"                                всі компоненти шляху повинні існувати\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet,\n"
"  -s, --silent                  suppress most error messages\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    separate output with NUL rather than "
"newline\n"
msgstr ""
"  -m, --canonicalize-missing    отримати канонічну назва файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                компоненти не обов'язково мають існувати\n"
"  -n, --no-newline              не виводити кінцевий роздільник\n"
"  -q, --quiet,\n"
"  -s, --silent                  не виводити повідомлення про помилки\n"
"  -v, --verbose                 повідомляти про помилки\n"
"  -z, --zero                    відокремлювати виведені рядки нуль-байтом,\n"
"                                 а не символом нового рядка\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "ігноруємо --no-newline з декількома аргументами"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"Вивести визначену абсолютну назву файла;\n"
"всі компоненти, окрім останньої, має бути вже створено\n"
"\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no components of the path need exist\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=FILE       print the resolved path relative to FILE\n"
"      --relative-base=FILE     print absolute paths unless paths below FILE\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   separate output with NUL rather than newline\n"
"\n"
msgstr ""
"  -e, --canonicalize-existing  всі компоненти шляху мають існувати\n"
"  -m, --canonicalize-missing   не повинно існувати жодного компонента\n"
"  -L, --logical                обробляти компоненти '..' до символічних "
"посилань\n"
"  -P, --physical               обробляти символічні посилання (типово)\n"
"  -q, --quiet                  придушити більшість повідомлень про помилки\n"
"      --relative-to=ФАЙЛ       вивести визначений шлях відносно ФАЙЛа\n"
"      --relative-base=ФАЙЛ     вивести абсолютні шляхи, якщо вони не є "
"підлеглими ФАЙЛ\n"
"  -s, --strip, --no-symlinks   не розгортати символічні посилання\n"
"  -z, --zero                   відокремлювати частини результату NUL, а не "
"символом нового рядка\n"
"\n"

#: src/relpath.c:130
msgid "generating relative path"
msgstr "створення відносного шляху"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: спуститься у захищений від запису каталог %s? "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: спуститься у каталог %s? "

#. TRANSLATORS: You may find it more convenient to
#. translate "%s: remove %s (write-protected) %s? "
#. instead.  It should avoid grammatical problems
#. with the output of file_type.
#: src/remove.c:290
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: вилучити захищений від запису %s %s? "

#: src/remove.c:291
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: вилучити %s %s? "

#: src/remove.c:374
#, c-format
msgid "removed directory: %s\n"
msgstr "вилучено каталог: %s\n"

#: src/remove.c:444
#, c-format
msgid "cannot remove directory: %s"
msgstr "не вдалося вилучити каталог: %s"

#: src/remove.c:500
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "припущено %s, оскільки він розташований на іншому пристрої"

#: src/remove.c:520
#, c-format
msgid "traversal failed: %s"
msgstr "помилка під час обходу: %s"

#: src/remove.c:526
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"неочікувана помилка: fts_info=%d: %s\n"
"повідомте %s"

#: src/rm.c:119
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "Спробуйте «%s ./%s», щоб вилучити файл %s.\n"

#: src/rm.c:136
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Вилучення ФАЙЛІВ (символічних посилань).\n"
"\n"
"  -f, --force           ігнорувати файли і аргументи, яких не існує, ніколи "
"не питати\n"
"  -i                    питати перед кожним вилученням\n"

#: src/rm.c:142
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively.  Less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i).  Without WHEN, prompt always\n"
msgstr ""
"  -I                    питати перед вилученням більш ніж трьох файлів або\n"
"                          при рекурсивному вилученні.  Менш набридливий ніж\n"
"                          -i, хоча забезпечує захист від більшості помилок\n"
"      --interactive[=КОЛИ]  питати КОЛИ: never, once (-I), \n"
"                          always (-i).  Без значення КОЛИ — питати завжди\n"

#: src/rm.c:149
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  при вилученні ієрархії рекурсивно, пропускати\n"
"                          каталоги, що лежать на інших файлових системах,\n"
"                          ніж вказані аргументами командного рядку\n"

#: src/rm.c:154
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root   do not remove '/' (default)\n"
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"      --no-preserve-root не обробляти / особливим чином\n"
"      --preserve-root   не вилучати / (типова поведінка)\n"
"  -r, -R, --recursive   рекурсивно вилучати каталоги та їх вміст\n"
"  -d, --dir             вилучати порожні каталоги\n"
"  -v, --verbose         пояснювати дії, що виконуються\n"

#: src/rm.c:163
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"Зазвичай rm не вилучає каталоги.  Використовуйте ключ --recursive (-r\n"
"або -R), щоб вилучити всі перелічені каталоги разом з їхнім\n"
"змістом.\n"

#: src/rm.c:168
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"Для вилучення файла, що починається з «-» (приклад: «-foo»),\n"
"використовуйте одну з наступних команд:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:177
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Зауважте, що при використанні rm для вилучення файла його вміст\n"
"зазвичай можна відновити. Використовуйте shred, якщо потрібна більша\n"
"впевненість у неможливості відновлення вмісту.\n"

#: src/rm.c:342
#, c-format
msgid "%s: remove all arguments recursively? "
msgstr "%s: вилучити усі аргументи рекурсивно? "

#: src/rm.c:343
#, c-format
msgid "%s: remove all arguments? "
msgstr "%s: вилучити усі аргументи? "

#: src/rmdir.c:134 src/rmdir.c:233
#, c-format
msgid "removing directory, %s"
msgstr "вилучення каталогу, %s"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "помилка при вилученні каталогу %s"

#: src/rmdir.c:165
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Вилучає КАТАЛОГИ, якщо вони порожні.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ігнорувати всі помилки, коли каталог не порожній\n"

#: src/rmdir.c:172
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   вилучити КАТАЛОГ і підлеглі каталоги. Наприклад, «rmdir -p "
"a/b/c»\n"
"                  робить те ж саме, що й «rmdir a/b/c a/b a».\n"
"  -v, --verbose   виводити повідомлення для кожного обробленого каталогу\n"

#: src/rmdir.c:242
#, c-format
msgid "failed to remove %s"
msgstr "не вдалося вилучити %s"

#: src/runcon.c:83
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"Використання: %s КОНТЕКСТ КОМАНДА [аргументи]\n"
"  або:  %s [ -c ] [-u КОРИСТУВАЧ] [-r РОЛЬ] [-t ТИП] [-l ДІАПАЗОН] КОМАНДА "
"[аргументи]\n"

#: src/runcon.c:87
msgid ""
"Run a program in a different security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"Запустити програму з іншим контекстом безпеки.\n"
"якщо не вказано ні КОНТЕКСТ, ані КОМАНДА, виводиться поточний контекст "
"безпеки.\n"

#: src/runcon.c:94
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"  КОНТЕКСТ              Повний контекст безпеки\n"
"  -c, --compute         обчислити процес переходу контексту перед зміною\n"
"  -t, --type=ТИП        тип (для тієї ж ролі, що й у батьківському)\n"
"  -u, --user=КОРИСТУВАЧ користувач\n"
"  -r, --role=РОЛЬ       роль\n"
"  -l, --range=ДІАПАЗОН  діапазон рівня\n"
"\n"

#: src/runcon.c:144
#, c-format
msgid "multiple roles"
msgstr "множинні ролей"

#: src/runcon.c:149
#, c-format
msgid "multiple types"
msgstr "множинні типи"

#: src/runcon.c:154
#, c-format
msgid "multiple users"
msgstr "множинні користувачі"

#: src/runcon.c:159
#, c-format
msgid "multiple levelranges"
msgstr "множинні діапазони"

#: src/runcon.c:177 src/runcon.c:213
#, c-format
msgid "failed to get current context"
msgstr "помилка при отриманні поточного контексту"

#: src/runcon.c:187
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "слід вказати -c, -t, -u, -l, -r, або контекст"

#: src/runcon.c:195
#, c-format
msgid "no command specified"
msgstr "не вказано команду"

#: src/runcon.c:201
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s можна використовувати лише у середовищі з підтримкою SELinux у ядрі"

#: src/runcon.c:227
#, c-format
msgid "failed to compute a new context"
msgstr "помилка при обчисленні нового контексту"

#: src/runcon.c:241
#, c-format
msgid "failed to set new user %s"
msgstr "помилка при встановленні нового користувача %s"

#: src/runcon.c:243
#, c-format
msgid "failed to set new type %s"
msgstr "помилка при встановленні нового типу %s"

#: src/runcon.c:245
#, c-format
msgid "failed to set new range %s"
msgstr "помилка при встановленні нового діапазону %s"

#: src/runcon.c:247
#, c-format
msgid "failed to set new role %s"
msgstr "помилка при встановленні нової ролі %s"

#: src/runcon.c:255
#, c-format
msgid "unable to set security context %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/seq.c:68
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ПРИРІСТ ОСТАННЄ\n"

#: src/seq.c:73
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr "Виводить числа від ПЕРШОГО до ОСТАННЬОГО з кроком ПРИРІСТ.\n"

#: src/seq.c:79
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format ФОРМАТ      використовувати ФОРМАТ у стилі printf\n"
"  -s, --separator РЯДОК    використовувати РЯДОК як розділювач (типово \\n)\n"
"  -w, --equal-width        вирівнювати за шириною з додаванням початкових "
"нулів\n"

#: src/seq.c:86
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
msgstr ""
"\n"
"Якщо не вказані ПЕРШЕ або ПРИРІСТ, типово використовується 1.  Тобто\n"
"ПРИРІСТ типово приймається за 1, навіть якщо ОСТАННІЙ менше\n"
"ПЕРШОГО.  ПЕРШИЙ, ОСТАННІЙ та ПРИРІСТ вважаються числами з рухомою\n"
"комою.  ПРИРІСТ повинен бути додатнім, якщо ПЕРШИЙ менше\n"
"ОСТАННЬОГО, та від'ємним у іншому випадку.\n"

#: src/seq.c:94
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"ФОРМАТ повинен бути придатний для друку одного аргументу типу 'double';\n"
"типове значення %.PRECf якщо ПЕРШЕ, ПРИРІСТ, та ОСТАННЄ є числами \n"
"з плаваючою комою з максимальною точністю ТОЧН, та %g у іншому випадку.\n"

#: src/seq.c:140
#, c-format
msgid "invalid floating point argument: %s"
msgstr "неправильний аргумент з плаваючою комою: %s"

#: src/seq.c:232
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "формат містить %s невідому директиву %%%c"

#: src/seq.c:555
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "при виводі рядків однакової ширини формат можна не вказувати"

#: src/setuidgid.c:49
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... КОРИСТУВАЧ КОМАНДА [АРГУМЕНТ]...\n"
"  або  %s ПАРАМЕТР-ПОВНІСТЮ\n"

#: src/setuidgid.c:55
msgid ""
"Drop any supplemental groups, assume the user-ID and group-ID of the "
"specified\n"
"USER (numeric ID or user name), and run COMMAND with any specified "
"ARGUMENTs.\n"
"Exit with status 111 if unable to assume the required user and group ID.\n"
"Otherwise, exit with the exit status of COMMAND.\n"
"This program is useful only when run by root (user ID zero).\n"
"\n"
msgstr ""
"Скидає всі додаткові групи, встановлює ідентифікатори\n"
"користувача та групи як у вказаного КОРИСТУВАЧА та запускає КОМАНДУ\n"
"з вказаними АРГУМЕНТАМИ.  Завершується зі статусом 111, якщо \n"
"не вдалося встановити потрібні ідентифікатори користувача та групи.  У\n"
"іншому випадку повертається вихідний статус КОМАНДИ.  Ця програма\n"
"має сенс лише для root (UID=0).\n"
"\n"

#: src/setuidgid.c:64
msgid ""
"  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, and\n"
"                    (if specified) supplemental group IDs to GID1, ...\n"
msgstr ""
"  -g GID[,GID1...]  також встановити головний ідентифікатор групи у значення "
"GID, та\n"
"                    (якщо вказано) ідентифікатори додаткових груп ID у "
"GID1, ...\n"

#: src/setuidgid.c:162
#, c-format
msgid "unknown user-ID: %s"
msgstr "невідомий ідентифікатор користувача: %s"

#: src/setuidgid.c:173
#, c-format
msgid "to use user-ID %s you need to use -g too"
msgstr ""
"для використання ідентифікатора користувача %s слід використовувати -g too"

#: src/setuidgid.c:190
#, c-format
msgid "failed to set supplemental group(s)"
msgstr "не вдалося встановити додаткові групи"

#: src/setuidgid.c:200
#, c-format
msgid "cannot set group-ID to %lu"
msgstr "не вдалося встановити ідентифікатор групи рівним %lu"

#: src/setuidgid.c:204
#, c-format
msgid "cannot set user-ID to %lu"
msgstr "не вдалося встановити ідентифікатор користувача рівним %lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:148
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"Перезаписує декілька раз вказані файли, щоб ускладнити відновлення\n"
"навіть з використанням дуже коштовного обладнання.\n"

#: src/shred.c:155
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    змінювати права, дозволяючи запис, якщо потрібно\n"
"  -n, --iterations=N  переписати N разів замість (%d) типово\n"
"      --random-source=ФАЙЛ  брати випадкові дані з ФАЙЛа\n"
"  -s, --size=N   очистити N байт (можливі суфікси, подібні до K, M, G)\n"

#: src/shred.c:161
msgid ""
"  -u, --remove   truncate and remove file after overwriting\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u, --remove   обрізати та вилучати файл після перезаписи\n"
"  -v, --verbose  виводити поступ\n"
"  -x, --exact    не округляти розміри файлів до наступного цілого блоку;\n"
"                   типово для незвичних файлів\n"
"  -z, --zero     перезаписати у конці нулями, щоб сховати змішування\n"

#: src/shred.c:170
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.  When operating on regular\n"
"files, most people use the --remove option.\n"
"\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказаний як -, змішувати стандартний вивід.\n"
"\n"
"Вилучає ФАЙЛИ, якщо вказаний --remove (-u).  Типово файли не\n"
"вилучаються, оскільки часто обробляються файли-пристрої на зразок\n"
"/dev/hda, а такі файли не треба вилучати.  При обробці звичайних\n"
"файлів більшість людей використовує ключ --remove.\n"
"\n"

#: src/shred.c:180
msgid ""
"CAUTION: Note that shred relies on a very important assumption:\n"
"that the file system overwrites data in place.  This is the traditional\n"
"way to do things, but many modern file system designs do not satisfy this\n"
"assumption.  The following are examples of file systems on which shred is\n"
"not effective, or is not guaranteed to be effective in all file system "
"modes:\n"
"\n"
msgstr ""
"УВАГА: Пам'ятайте, що shred покладається на дуже важливе припущення:\n"
"що ваша файлова система перезаписує файли \"на місці\".\n"
"Зазвичай це так, але багато сучасних файлових системи\n"
"не задовольняють цьому припущенню.  Ось приклади файлових систем, на\n"
"яких shred не ефективний або не дає гарантії ефективності в усіх\n"
"режимах файлової системи:\n"
"\n"

#: src/shred.c:188
msgid ""
"* log-structured or journaled file systems, such as those supplied with\n"
"AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
"\n"
"* file systems that write redundant data and carry on even if some writes\n"
"fail, such as RAID-based file systems\n"
"\n"
"* file systems that make snapshots, such as Network Appliance's NFS server\n"
"\n"
msgstr ""
"* файлові системи з журналом, наприклад які йдуть у комплекті\n"
"  AIX та Solaris (та JFS, ReiserFS, XFS, Ext3 та ін.)\n"
"\n"
"* файлові системи, які записують надлишкові дані та зберігають\n"
"  працездатність навіть якщо виникають невдалі записи, наприклад\n"
"  файлові системи, що побудовані на технології RAID\n"
"\n"
"* файлові системи, які створюють копії стану, наприклад\n"
"  NFS-сервер від Network Appliance\n"
"\n"

#: src/shred.c:198
msgid ""
"* file systems that cache in temporary locations, such as NFS\n"
"version 3 clients\n"
"\n"
"* compressed file systems\n"
"\n"
msgstr ""
"* файлові системи, які кешують файли у тимчасових сховищах, наприклад \n"
"  клієнти NFS версії 3\n"
"\n"
"* стиснені файлові системи\n"
"\n"

#: src/shred.c:205
msgid ""
"In the case of ext3 file systems, the above disclaimer applies\n"
"(and shred is thus of limited effectiveness) only in data=journal mode,\n"
"which journals file data in addition to just metadata.  In both the\n"
"data=ordered (default) and data=writeback modes, shred works as usual.\n"
"Ext3 journaling modes can be changed by adding the data=something option\n"
"to the mount options for a particular file system in the /etc/fstab file,\n"
"as documented in the mount man page (man mount).\n"
"\n"
msgstr ""
"В випадку файлових систем ext3 наведене вище обмеження вірне (тож,\n"
"shred не такий ефективний), лише у режимі\n"
"data=journal, коли окрім метаданих у журнал заносяться також самі дані\n"
"файлів.  В режимах data=ordered (типово) та data=writeback\n"
"програма shred працює у звичайному режимі.  Режими журналу ext3 можна\n"
"змінити, додавши ключ data=щось до параметрів підключення\n"
"конкретної файлової системи у файлі /etc/fstab, згідно документації на\n"
"сторінці man для mount (man mount).\n"

#: src/shred.c:215
msgid ""
"In addition, file system backups and remote mirrors may contain copies\n"
"of the file that cannot be removed, and that will allow a shredded file\n"
"to be recovered later.\n"
msgstr ""
"Окрім того, резервні копії та вилучені дзеркала файлової системи можуть\n"
"містити копії файла, які не можна вилучити, і які пізніше надають змогу\n"
"відновити знищений файл.\n"

#: src/shred.c:295
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: операція fdatasync завершилась невдало"

#: src/shred.c:306
#, c-format
msgid "%s: fsync failed"
msgstr "%s: операція fsync завершилась невдало"

#: src/shred.c:383
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: не вдалося відкотитись"

#: src/shred.c:402
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: прохід %lu/%lu (%s)..."

#: src/shred.c:452
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: помилка записи за зсувом %s"

#: src/shred.c:470
#, c-format
msgid "%s: lseek failed"
msgstr "%s: операція lseek завершилась помилкою"

#: src/shred.c:481
#, c-format
msgid "%s: file too large"
msgstr "%s: файл надто великий"

#: src/shred.c:504
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: прохід %lu/%lu (%s)...%s"

#: src/shred.c:520
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: прохід %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:767
#, c-format
msgid "%s: fstat failed"
msgstr "%s: операція fstat завершилась помилкою"

#: src/shred.c:778
#, c-format
msgid "%s: invalid file type"
msgstr "%s: неправильний тип файла"

#: src/shred.c:797
#, c-format
msgid "%s: file has negative size"
msgstr "%s: файл має від'ємний розмір"

#: src/shred.c:864 src/sort.c:932 src/split.c:378
#, c-format
msgid "%s: error truncating"
msgstr "%s: помилка при скороченні"

#: src/shred.c:880
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: операція fcntl завершилась помилкою"

#: src/shred.c:885
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: не вдалося нарізати файловий дескриптор з лише з правом додавання"

#: src/shred.c:967
#, c-format
msgid "%s: removing"
msgstr "%s:  вилучення"

#: src/shred.c:991
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: перейменований на %s"

#: src/shred.c:1013
#, c-format
msgid "%s: failed to remove"
msgstr "%s: не вдалося вилучити"

#: src/shred.c:1017
#, c-format
msgid "%s: removed"
msgstr "%s: вилучено"

#: src/shred.c:1024 src/shred.c:1067
#, c-format
msgid "%s: failed to close"
msgstr "%s: не вдалося закрити"

#: src/shred.c:1060
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: не вдалося відкрити для читання"

#: src/shred.c:1125
#, c-format
msgid "%s: invalid number of passes"
msgstr "%s: неправильна кількість проходів"

#: src/shred.c:1134 src/shuf.c:290 src/sort.c:4441
#, c-format
msgid "multiple random sources specified"
msgstr "вказано декілька форматів виводу"

#: src/shred.c:1148
#, c-format
msgid "%s: invalid file size"
msgstr "%s: неправильний розмір файла"

#: src/shuf.c:48
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"
"  або:  %s -e [КЛЮЧ]... [АРГУМЕНТ]...\n"
"  або:  %s -i НИЖ-ВИЩ [КЛЮЧ]...\n"

#: src/shuf.c:54
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "Виводить випадково переставлені вхідні рядки на стандартний вивід.\n"

#: src/shuf.c:60
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -e, --echo                вважати кожен АРГУМЕНТ вхідним рядком\n"
"  -i, --input-range=НИЖ-ВИЩ вважати числа від НИЖ до ВИЩ вхідним рядком\n"
"  -n, --head-lines=РЯДКІВ   виводити принаймні кількість РЯДКІВ\n"
"  -o, --output=ФАЙЛ         вивести результат у ФАЙЛ, а не стандартний "
"вивід\n"
"      --random-source=ФАЙЛ  випадкові дані з ФАЙЛа\n"
"  -z, --zero-terminated     завершувати рядки нульовим байтом, а не "
"символом\n"
"                            нового рядка\n"

#: src/shuf.c:244
#, c-format
msgid "multiple -i options specified"
msgstr "задано декілька ключів -i"

#: src/shuf.c:264
#, c-format
msgid "invalid input range %s"
msgstr "неприпустимий вхідний діапазон %s"

#: src/shuf.c:277
#, c-format
msgid "invalid line count %s"
msgstr "неправильна кількість рядків %s"

#: src/shuf.c:284 src/sort.c:4435
#, c-format
msgid "multiple output files specified"
msgstr "задано декілька файлів для виводу"

#: src/shuf.c:310
#, c-format
msgid "cannot combine -e and -i options"
msgstr "не можна одночасно використовувати ключі -e та -i"

#: src/sleep.c:44
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  Unlike most "
"implementations\n"
"that require NUMBER be an integer, here NUMBER may be an arbitrary floating\n"
"point number.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Використання: %s ЧИСЛО[СУФІКС]\n"
"       або:    %s КЛЮЧ\n"
"Призупиняє виконання на вказане ЧИСЛО секунд.  СУФІКС може\n"
"приймати значення 's', що означає секунди (типове значення),\n"
"'m' -- хвилини, 'h' -- години та 'd' -- дні. На відміну від\n"
"інших реалізацій, які вимагають, щоб ЧИСЛО було цілим, тут воно\n"
"може бути довільним числом з плаваючою комою.\n"
"\n"

#: src/sleep.c:135 src/timeout.c:320
#, c-format
msgid "invalid time interval %s"
msgstr "неправильний інтервал часу %s"

#: src/sleep.c:146 src/tail.c:1219
#, c-format
msgid "cannot read realtime clock"
msgstr "не вдалося прочитати значення таймеру реального часу"

#: src/sort.c:399
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr "Вивести сортоване сполучення усіх ФАЙЛ(ів) на стандартний вивід.\n"

#: src/sort.c:405
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Ключі, що вказують порядок:\n"
"\n"

#: src/sort.c:409
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ігнорувати початкові пробіли\n"
"  -d, --dictionary-order      розглядати лише пропуски, літери та цифри\n"
"  -f, --ignore-case           ігнорувати регістр літер\n"

#: src/sort.c:415
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  порівнювати числа у загальному форматі\n"
"  -i, --ignore-nonprinting    розглядати лише друковані знаки\n"
"  -M, --month-sort            порівнювати (невідомо) < 'JAN' < ... < 'DEC'\n"

#: src/sort.c:420
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""
"  -h, --human-numeric-sort    порівнювати значення у зручному для читання "
"форматі (приклад: 2к 1Г)\n"

#: src/sort.c:423
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           sort by random hash of keys\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          порівнювати числові значення рядків\n"
"  -R, --random-sort           сортувати за випадковими хешами ключів\n"
"      --random-source=ФАЙЛ    випадкові дані з ФАЙЛА\n"
"  -r, --reverse               зворотний порядок порівняння\n"

#: src/sort.c:429
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=СЛОВО            сортувати відповідно до СЛОВО:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          сортувати за номером версії\n"
"\n"

#: src/sort.c:437
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Інші параметри:\n"
"\n"

#: src/sort.c:441
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE   об'єднувати не більше NMERGE джерел введення "
"одразу;\n"
"                            для решти використовувати тимчасові файли\n"

#: src/sort.c:445
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first перевіряти, чи сортовані вхідні\n"
"                   файли; не сортувати\n"
"  -C, --check=quiet, --check=silent як -c, але не повідомляти про перший\n"
"                   помилковий рядок\n"
"      --compress-program=ПРОГ  стискати тимчасові файли командою ПРОГ;\n"
"                   розпаковувати командою ПРОГ -d\n"

#: src/sort.c:452
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               коментувати частину рядка, використану для\n"
"                              впорядковування, попереджати щодо сумнівного\n"
"                              використання до stderr\n"
"      --files0-from=Ф       читати вхідні дані з файлів, вказаних за "
"допомогою\n"
"                            назв, відокремлених нуль-символом, у файлі Ф;\n"
"                            Якщо Ф — -, читати назви зі стандартного "
"джерела\n"
"                            вхідних даних\n"

#: src/sort.c:459
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=ВИЗНКЛ          впорядкувати за ключем, ВИЗНКЛ визначає місце і "
"тип\n"
"  -m, --merge               об'єднати вже впорядковані файли; не "
"впорядковувати\n"

#: src/sort.c:463
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=ФАЙЛ  виводити у ФАЙЛ, а не на стандартний вивід\n"
"  -s, --stable     стабілізувати сортування, виключивши перевірку на "
"рівність\n"
"  -S, --buffer-size=РОЗМІР\n"
"                   використовувати в пам'яті буфер вказаного РОЗМІРУ\n"

#: src/sort.c:469
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=РОЗДІЛЮВАЧ\n"
"                   використовувати при пошуку ключових полів РОЗДІЛЮВАЧ, а "
"не\n"
"                   перехід від непробільних знаків до пробільних\n"
"  -T, --temporary-directory=КАТАЛОГ\n"
"                   використовувати для тимчасових файлів КАТАЛОГ, а не "
"$TMPDIR\n"
"                   або %s; декілька таких ключів задають декілька каталогів\n"
"  -u, --unique     з -c, суворо перевіряти порядок;\n"
"                     без -c, виводити лише перше з кількох рівних\n"

#: src/sort.c:478
msgid "  -z, --zero-terminated     end lines with 0 byte, not newline\n"
msgstr ""
"  -z, --zero-terminated     завершувати рядки нульовим байтом, а не символом "
"нового рядка\n"

#: src/sort.c:483
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"ВИЗНКЛ вказується як П[.З][ПАРАМ][П[.З][ПАРАМ]] для початкової і\n"
"кінцевої позицій, де П -- номер поля, а З -- позиція\n"
"символу у цьому поле, відлік обох ведеться з 1, типовою кінцевою\n"
"позицією є позиція кінця рядка. Якщо не використано ні -t, ні -b,\n"
"відлік символів у полі вестиметься з початку попереднього полю пробілу.\n"
"ПАРАМ визначається одним або декількома параметрами впорядковування з\n"
"набору [bdfgiMhnRrV]. ПАРАМ перевизначає загальні параметри впорядковування\n"
"для відповідного ключа. Якщо поле ключа не вказано, як ключ буде\n"
"використано увесь рядок.\n"
"\n"
"Після РОЗМІРУ можна вказувати такі суфікси-мультиплікатори:\n"

#: src/sort.c:496
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% пам'яті, b 1, k 1024 (типово), та так далі для M, G, T, P, E, Z, Y.\n"
"\n"
"Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"
"\n"
"*** ПОПЕРЕДЖЕННЯ ***\n"
"Встановлена в середовищі локаль впливає на порядок сортування.\n"
"Щоб отримати традиційний порядок, що використовує системні значення байт,\n"
"встановіть LC_ALL=C.\n"

#: src/sort.c:697
#, c-format
msgid "waiting for %s [-d]"
msgstr "очікування %s [-d]"

#: src/sort.c:702
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] аварійно завершений"

#: src/sort.c:856
#, c-format
msgid "cannot create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/sort.c:950 src/sort.c:2025 src/sort.c:3071 src/sort.c:3713
#: src/sort.c:3804 src/sort.c:3807
msgid "open failed"
msgstr "операція відкриття завершилась помилкою"

#: src/sort.c:970
msgid "fflush failed"
msgstr "операція fflush завершилась помилкою"

#: src/sort.c:975 src/sort.c:2028 src/sort.c:4706
msgid "close failed"
msgstr "помилка закриття"

#: src/sort.c:986
#, c-format
msgid "dup2 failed"
msgstr "помилка dup2"

#: src/sort.c:1103
#, c-format
msgid "couldn't execute %s"
msgstr "неможливо виконати %s"

#: src/sort.c:1110
msgid "couldn't create temporary file"
msgstr "не вдалося створити тимчасовий файл"

#: src/sort.c:1149
#, c-format
msgid "couldn't create process for %s -d"
msgstr "неможливо створити процес для %s -d"

#: src/sort.c:1161
#, c-format
msgid "couldn't execute %s -d"
msgstr "неможливо виконати %s -d"

#: src/sort.c:1220
#, c-format
msgid "warning: cannot remove: %s"
msgstr "попередження, не вдалося вилучити: %s"

#: src/sort.c:1306
#, c-format
msgid "invalid --%s argument %s"
msgstr "некоректний аргумент --%s %s"

#: src/sort.c:1309
#, c-format
msgid "minimum --%s argument is %s"
msgstr "мінімальним аргументом --%s є %s"

#: src/sort.c:1324
#, c-format
msgid "--%s argument %s too large"
msgstr "аргумент --%s %s є занадто великим"

#: src/sort.c:1327
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "максимум --%s аргумент з поточним rlimit що дорівнює %s"

#: src/sort.c:1409
#, c-format
msgid "number in parallel must be nonzero"
msgstr "кількість паралельних впорядкувань має бути ненульовою"

#: src/sort.c:1494
msgid "stat failed"
msgstr "операція stat завершилась помилкою"

#: src/sort.c:1755
msgid "read failed"
msgstr "помилка читання"

#: src/sort.c:2043
#, c-format
msgid "string transformation failed"
msgstr "помилка перетворення рядків"

#: src/sort.c:2046
#, c-format
msgid "the untransformed string was %s"
msgstr "Рядок до перетворення %s"

#: src/sort.c:2209
#, c-format
msgid "^ no match for key\n"
msgstr "^ не знайдено збігів з ключем\n"

#: src/sort.c:2389
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "використано застарілий ключ «%s»; вам варто скористатися ключем «%s»"

#: src/sort.c:2395
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "ключ %lu має нульову ширину, його буде проігноровано"

#: src/sort.c:2406
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr "початкові пробіли у ключі %lu буде враховано; варто також вказати «b»"

#: src/sort.c:2419
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "ключ %lu є числовим, він охоплює декілька полів"

#: src/sort.c:2451
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "параметр «-%s» проігноровано"
msgstr[1] "параметри «-%s» проігноровано"
msgstr[2] "параметри «-%s» проігноровано"

#: src/sort.c:2457
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "параметр «-r» застосовується лише у разі, якщо збігів не виявлено"

#: src/sort.c:2731 src/sort.c:2740
msgid "write failed"
msgstr "запис завершився помилкою"

#: src/sort.c:2783
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: неправильний порядок: "

#: src/sort.c:2786
msgid "standard error"
msgstr "стандартна помилка"

#: src/sort.c:3698
msgid "cannot read"
msgstr "не вдалося прочитати"

#: src/sort.c:3976
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: неправильна специфікація поля %s"

#: src/sort.c:3987
#, c-format
msgid "options '-%s' are incompatible"
msgstr "несумісні параметри '-%s'"

#: src/sort.c:4038
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: неправильний лічильник на початку %s"

#: src/sort.c:4295
msgid "invalid number after '-'"
msgstr "неправильне число після '-'"

#: src/sort.c:4302 src/sort.c:4388 src/sort.c:4416
msgid "invalid number after '.'"
msgstr "неправильне число після '.'"

#: src/sort.c:4315 src/sort.c:4421
msgid "stray character in field spec"
msgstr "зайвий знак у специфікації поля"

#: src/sort.c:4362
#, c-format
msgid "multiple compress programs specified"
msgstr "вказано декілька програм стискання"

#: src/sort.c:4379
msgid "invalid number at field start"
msgstr "неправильне число на початку поля"

#: src/sort.c:4383 src/sort.c:4411
msgid "field number is zero"
msgstr "нульовий номер поля"

#: src/sort.c:4392
msgid "character offset is zero"
msgstr "нульовий знаковий зсув"

#: src/sort.c:4407
msgid "invalid number after ','"
msgstr "неправильне число після ','"

#: src/sort.c:4457
#, c-format
msgid "empty tab"
msgstr "порожня табуляція"

#: src/sort.c:4550 src/wc.c:692
#, c-format
msgid "cannot read file names from %s"
msgstr "не вдалося прочитати назви файлів з %s"

#: src/sort.c:4572
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s:%lu: некоректна нульова довжина назви файла"

#: src/sort.c:4578
#, c-format
msgid "no input from %s"
msgstr "немає вхідних даних з %s"

#: src/sort.c:4624
#, c-format
msgid "using %s sorting rules"
msgstr "використовуються правила впорядковування %s"

#: src/sort.c:4627
#, c-format
msgid "using simple byte comparison"
msgstr "використовується просте порівняння байтів"

#: src/sort.c:4658
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "додатковий операнд %s не припустимий з -%c"

#: src/split.c:187
#, c-format
msgid "the suffix length needs to be at least %zu"
msgstr "довжина суфікса не повинна бути меншою за %zu"

#: src/split.c:204
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [PREFIX]]\n"
msgstr "Використання: %s [ПАРАМЕТР]... [ВХІДНІ_ДАНІ [ПРЕФІКС]]\n"

#: src/split.c:208
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"size is 1000 lines, and default PREFIX is 'x'.  With no INPUT, or when "
"INPUT\n"
"is -, read standard input.\n"
msgstr ""
"Виводить фіксовані за розміром частини ВХІДНІ_ДАНІ до файлів ПРЕФІКСaa,\n"
"ПРЕФІКСab, ...; типово розмір частини дорівнює 1000 рядків, а ПРЕФІКС\n"
"дорівнює 'x'.  Якщо ВХІДНІ_ДАНІ не вказано або вказано як -, читає\n"
"дані зі стандартного джерела даних.\n"

#: src/split.c:216
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file "
"names.\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -d, --numeric-suffixes[=FROM]  use numeric suffixes instead of "
"alphabetic.\n"
"                                   FROM changes the start value (default "
"0).\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files.  See below\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"  -a, --suffix-length=Н   використовувати суфікси довжини Н (типово %d)\n"
"  -b, --bytes=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО байт\n"
"  -C, --line-bytes=ЧИСЛО  записувати не більше вказаного ЧИСЛА байт з рядка\n"
"  -d, --numeric-suffixes  використовувати числові, а не алфавітні суфікси\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=КОМАНДА    записувати КОМАНДУ до оболонки; назвою файла є "
"$FILE\n"
"  -l, --lines=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО "
"рядків\n"
"  -n, --number=КІЛЬКІСТЬ  створити КІЛЬКІСТЬ фрагментів виведення. Див. "
"нижче.\n"
"  -u, --unbuffered        копіювати вхідні дані безпосередньо до виведення з "
"«-n r/...»\n"

#: src/split.c:229
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           виводити діагностичні повідомлення\n"
"                          перед відкриттям кожного файла виводу\n"

#: src/split.c:236
msgid ""
"\n"
"CHUNKS may be:\n"
"N       split into N files based on size of input\n"
"K/N     output Kth of N to stdout\n"
"l/N     split into N files without splitting lines\n"
"l/K/N   output Kth of N to stdout without splitting lines\n"
"r/N     like 'l' but use round robin distribution\n"
"r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"ФРАГМЕНТИ можна задавати у форматі:\n"
"N       розділити на N файлів на основі розміру вхідних даних\n"
"K/N     вивести K-ий з N до stdout\n"
"l/N     розділити на N файлів без поділу на рядки\n"
"l/K/N   вивести K-ий з N до stdout без поділу на рядки\n"
"r/N     подібно до «l», але з використанням циклічного перебирання\n"
"r/K/N   те саме, але вивести лише K-ий з N до stdout\n"

#: src/split.c:354
#, c-format
msgid "output file suffixes exhausted"
msgstr "вичерпано суфікси для вихідних файлів"

#: src/split.c:366
#, c-format
msgid "creating file %s\n"
msgstr "створюється файл %s\n"

#: src/split.c:375
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "%s перепише вхідні дані; перериваємо роботу"

#: src/split.c:391
#, c-format
msgid "failed to set FILE environment variable"
msgstr "не вдалося встановити змінну середовища FILE"

#: src/split.c:393
#, c-format
msgid "executing with FILE=%s\n"
msgstr "виконання з FILE=%s\n"

#: src/split.c:395
#, c-format
msgid "failed to create pipe"
msgstr "не вдалося створити канал"

#: src/split.c:409
#, c-format
msgid "closing prior pipe"
msgstr "закриття попереднього каналу"

#: src/split.c:411
#, c-format
msgid "closing output pipe"
msgstr "закриття каналу виведення"

#: src/split.c:415
#, c-format
msgid "moving input pipe"
msgstr "пересування каналу введення"

#: src/split.c:417
#, c-format
msgid "closing input pipe"
msgstr "закриття каналу введення"

#: src/split.c:422
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "не вдалося виконати команду: «%s -c %s»"

#: src/split.c:428
#, c-format
msgid "failed to close input pipe"
msgstr "не вдалося закрити канал вхідних даних"

#: src/split.c:464
#, c-format
msgid "waiting for child process"
msgstr "очікування на дочірній процес"

#: src/split.c:474
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "при FILE=%s, сигнал %s від команди: %s"

#: src/split.c:482
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "при FILE=%s, код виходу %d від команди: %s"

#: src/split.c:489 src/timeout.c:494
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "невідомий стан від команди (0x%X)"

#: src/split.c:1052
#, c-format
msgid "cannot split in more than one way"
msgstr "не можна розбивати одразу кількома методами"

#: src/split.c:1065 src/split.c:1205 src/split.c:1376
#, c-format
msgid "%s: invalid number of chunks"
msgstr "%s: некоректна кількість фрагментів"

#: src/split.c:1069
#, c-format
msgid "%s: invalid chunk number"
msgstr "%s: некоректний номер фрагмента"

#: src/split.c:1119
#, c-format
msgid "%s: invalid suffix length"
msgstr "%s: неправильна довжина суфіксу"

#: src/split.c:1144 src/split.c:1152 src/split.c:1175 src/split.c:1180
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: неправильна кількість байт"

#: src/split.c:1163 src/split.c:1310
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: неправильна кількість рядків"

#: src/split.c:1236
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "ключ кількості рядків -%s%c... надто великий"

#: src/split.c:1248
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: некоректне початкове значення у числовому суфіксі"

#: src/split.c:1276
#, c-format
msgid "%s: invalid IO block size"
msgstr "%s: некоректний розмір блоку введення-виведення"

#: src/split.c:1297
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr "--filter не обробляє фрагменти, видобуті до stdout"

#: src/split.c:1334
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""
"початкове значення числового суфікса є занадто великим для довжини суфікса"

#: src/split.c:1369
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: не вдалося визначити розмір файла"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:173
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:857
#, c-format
msgid "failed to canonicalize %s"
msgstr "не вдалося перетворити у канонічну форму %s"

#: src/stat.c:1069
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "попередження: керівна послідовність '\\%c' не розпізнана"

#: src/stat.c:1124
#, c-format
msgid "%s: invalid directive"
msgstr "%s: неправильна директива"

#: src/stat.c:1170
#, c-format
msgid "warning: backslash at end of format"
msgstr "попередження: зворотна похила риска наприкінці формату"

#: src/stat.c:1201
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""
"використання %s для позначення стандартного введення не працює у режимі "
"файлової системи"

#: src/stat.c:1208
#, c-format
msgid "cannot read file system information for %s"
msgstr "не вдалося прочитати інформацію файлової системи для %s"

#: src/stat.c:1228
#, c-format
msgid "cannot stat standard input"
msgstr "не вдалося виконати stat для стандартного джерела вхідних даних"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1264
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  Файл: «%n»\n"
"   Ід.: %-8i Довжина назви: %-7l Тип: %T\n"
"Розмір блоку: %-10s Базовий розмір блоку: %S\n"
"Блоки: загалом: %-10b вільних: %-10f доступних: %a\n"
"Inode: загалом: %-10c вільних: %d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1287
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  Файл: %N\n"
"  Розмір: %-10s\tБлоків: %-10b Блок в/в: %-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1297
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %-5h Тип пристрою: %t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1305
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1314
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "Доступ: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1324
#, c-format
msgid "Context: %C\n"
msgstr "Контекст: %C\n"

#: src/stat.c:1332
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"Доступ: %x\n"
"Модиф.: %y\n"
" Зміна: %z\n"
"Створ.: %w\n"

#: src/stat.c:1350
msgid "Display file or file system status.\n"
msgstr "Показати файл або стан файлової системи.\n"

#: src/stat.c:1356
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     слідувати за посиланням\n"
"  -f, --file-system     показати стан файлової системи, а не файла\n"

#: src/stat.c:1360
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline.\n"
"                          If you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=ФОРМАТ   використовувати вказаний ФОРМАТ, а не типовий;\n"
"                          переводити рядок після кожного використання "
"ФОРМАТУ\n"
"      --printf=ФОРМАТ   як --format, але інтерпретувати керівні\n"
"                          послідовності і не переводити рядок наприкінці.\n"
"                          Якщо потрібно переведення рядка, вставте у ФОРМАТ "
"\\n.\n"
"  -t, --terse           виводити дані у компактній формі\n"

#: src/stat.c:1371
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   access rights in octal\n"
"  %A   access rights in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Можливі форматні послідовності для файлів (без --file-system):\n"
"\n"
"  %a   права доступу у вісімковій формі\n"
"  %A   права доступу у текстовій формі\n"
"  %b   кількість виділених блоків (дивіться %B)\n"
"  %B   розмір блоку, що повідомляється %b, у байтах\n"
"  %C   рядок з контекстом безпеки SELinux\n"

#: src/stat.c:1380
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d   номер пристрою, десятковий\n"
"  %D   номер пристрою, шістнадцятковий\n"
"  %f   низькорівневий режим, шістнадцятковий\n"
"  %F   тип файла\n"
"  %g   ідентифікатор групи-власника\n"
"  %G   назва групи-власника\n"

#: src/stat.c:1388
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex\n"
"  %T   minor device type in hex\n"
msgstr ""
"  %h   кількість жорстких посилань\n"
"  %i   кількість inode\n"
"  %m   точка монтування\n"
"  %n   назва файла\n"
"  %N   екранована назва файла, символьні посилання розіменовуються\n"
"  %o   оптимальний розмір блоку введення-виведення\n"
"  %s   повний розмір, у байтах\n"
"  %t   основний тип пристрою, шістнадцятковий\n"
"  %T   другорядний тип пристрою, шістнадцятковий\n"

#: src/stat.c:1399
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last modification, human-readable\n"
"  %Y   time of last modification, seconds since Epoch\n"
"  %z   time of last change, human-readable\n"
"  %Z   time of last change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u   ідентифікатор користувача-власника\n"
"  %U   ім'я користувача-власника\n"
"  %w   час створення файла у зручному для читання форматі; - якщо невідомий\n"
"  %W   час створення файла у секундах від початку Епохи; 0 якщо невідомий\n"
"  %x   час останньої доступу\n"
"  %X   час останньої доступу у секундах з початку Епохи\n"
"  %y   час останньої зміни\n"
"  %Y   час останньої зміни у секундах з початку Епохи\n"
"  %z   час останньої зміни\n"
"  %Z   час останньої зміни у секундах з початку Епохи\n"
"\n"

#: src/stat.c:1413
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"Можливі послідовності форматування для файлових систем:\n"
"\n"
"  %a   кількість вільних блоків, доступних для звичайного користувача\n"
"  %b   повна кількість блоків даних у файловій системі\n"
"  %c   повна кількість вузлів у файловій системі\n"
"  %d   кількість вільних файлових вузлів у файловій системі\n"
"  %f   кількість вільних блоків у файловій системі\n"

#: src/stat.c:1422
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i   Ідентифікатор файлової системи, шістнадцятковий\n"
"  %l   Максимальна довжина назви файла\n"
"  %n   Назва файла\n"
"  %s   Розмір блоку (для швидшої передачі)\n"
"  %S   Фундаментальний розмір блоку (для обліку блоків)\n"
"  %t   Тип, шістнадцятковий\n"
"  %T   Тип у текстовій формі\n"

#: src/stdbuf.c:90
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Використання: %s ПАРАМЕТР... КОМАНДА\n"

#: src/stdbuf.c:91
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr ""
"Запускає КОМАНДУ зі зміненими діями з буферизації для стандартних потоків.\n"

#: src/stdbuf.c:97
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=РЕЖИМ  скоригувати буферизацію для потоку стандартного "
"введення\n"
"  -o, --output=РЕЖИМ скоригувати буферизацію для потоку стандартного "
"виведення\n"
"  -e, --error=РЕЖИМ  скоригувати буферизацію для потоку стандартних помилок\n"

#: src/stdbuf.c:104
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює L, для відповідного потоку буде використано рядкову "
"буферизацію.\n"
"Цей параметр є некоректним для стандартного джерела даних.\n"

#: src/stdbuf.c:107
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює 0, відповідний потік не буферизується.\n"

#: src/stdbuf.c:110
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"РЕЖИМ може бути числом, за яким вказано один з таких суфіксів:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
"У такому разі відповідний потік буде повністю буферизовано зі встановленням\n"
"розміру буфера у РЕЖИМ байтів.\n"

#: src/stdbuf.c:116
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for e.g.) then that will override corresponding settings changed by "
"'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"ЗАУВАЖЕННЯ: якщо КОМАНДА сама коригує буферизацію стандартних потоків даних\n"
"(наприклад tee), перевизначає відповідні параметри, змінені stdbuf.\n"
"Крім того, деякі фільтри (зокрема dd і cat) не використовують потоки для\n"
"введення/виведення, отже параметри stdbuf на них не впливають.\n"

#: src/stdbuf.c:226
#, c-format
msgid "failed to find %s"
msgstr "не вдалося знайти %s"

#: src/stdbuf.c:246 src/stdbuf.c:278
#, c-format
msgid "failed to update the environment with %s"
msgstr "не вдалося оновити середовища за допомогою %s"

#: src/stdbuf.c:320
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "рядкова буферизація stdin не має сенсу"

#: src/stty.c:513
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Використання: %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [ПАРАМЕТР]...\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-a|--all]\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-g|--save]\n"

#: src/stty.c:519
msgid "Print or change terminal characteristics.\n"
msgstr "Виводить або змінює характеристики термінала.\n"

#: src/stty.c:525
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all       вивести поточні параметри у текстовій формі\n"
"  -g, --save      вивести поточні параметри у формі, що зрозуміла програмі\n"
"                  stty\n"
"  -F, --file=ПРИСТРІЙ\n"
"                  відкрити та використовувати вказаний пристрій замість\n"
"                  стандартного вводу\n"

#: src/stty.c:532
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Необов'язковий знак мінус перед ПАРАМЕТРом означає зміну знаку.  Зірочкою\n"
"позначені параметри, не описані у стандарті POSIX.  Доступність того чи\n"
"іншого параметру визначається системою, що використовується.\n"

#: src/stty.c:537
msgid ""
"\n"
"Special characters:\n"
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"Спеціальні символи:\n"
"* dsusp СИМВОЛ    СИМВОЛ буде надсилати терміналу сигнал зупинки при\n"
"                  завершенні вводу\n"
"  eof СИМВОЛ      СИМВОЛ буде означати кінець файла (припинення вводу)\n"
"  eol СИМВОЛ      СИМВОЛ буде означати кінець рядка\n"

#: src/stty.c:544
msgid ""
" * eol2 CHAR     alternate CHAR for ending the line\n"
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"* eol2 СИМВОЛ     інший СИМВОЛ для кінця рядка\n"
"  erase СИМВОЛ    СИМВОЛ буде стирати останній введений до нього\n"
"  intr СИМВОЛ     СИМВОЛ буде надсилати сигнал переривання\n"
"  kill СИМВОЛ     СИМВОЛ буде стирати поточний рядок\n"

#: src/stty.c:550
msgid ""
" * lnext CHAR    CHAR will enter the next character quoted\n"
"   quit CHAR     CHAR will send a quit signal\n"
" * rprnt CHAR    CHAR will redraw the current line\n"
"   start CHAR    CHAR will restart the output after stopping it\n"
msgstr ""
"* lnext СИМВОЛ    СИМВОЛ буде вводити наступний символ, скасовуючи його\n"
"                  спеціальну дію\n"
"  quit СИМВОЛ     СИМВОЛ буде надсилати сигнал виходу\n"
"* rprnt СИМВОЛ    СИМВОЛ буде перерисовувати поточний рядок\n"
"  start СИМВОЛ    СИМВОЛ буде відновлювати ввід\n"

#: src/stty.c:556
msgid ""
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
" * swtch CHAR    CHAR will switch to a different shell layer\n"
" * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""
"  stop СИМВОЛ     СИМВОЛ буде призупиняти ввід\n"
"  susp СИМВОЛ     СИМВОЛ буде надсилати терміналу сигнал зупинки\n"
"* swtch СИМВОЛ    СИМВОЛ буде перемикати рівень складності оболонки\n"
"* werase СИМВОЛ   СИМВОЛ буде стирати останнє введене слово\n"

#: src/stty.c:562
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"Спеціальні параметри:\n"
"\n"
"  Н             встановити швидкість введення та виведення у Н бод\n"
"* cols Н        повідомити ядру, що термінал має Н стовпчиків\n"
"* columns Н     синонім cols\n"

#: src/stty.c:569
msgid ""
"   ispeed N      set the input speed to N\n"
" * line N        use line discipline N\n"
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"  ispeed Н      встановити швидкість вводу\n"
"* line Н        використовувати протокол лінії Н\n"
"  min Н         використовується з -icanon, встановити Н мінімальним числом\n"
"                символів для завершення операції читання\n"
"  ospeed Н      встановити швидкість виводу\n"

#: src/stty.c:575
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"* rows Н        повідомити ядру, що термінал має Н рядків\n"
"* size          вивести числа стовпчиків та рядків, відомі ядру\n"
"  speed         вивести швидкість терміналу\n"
"  time Н        використовується з -icanon, встановити часову межу для\n"
"                операції читання рівним Н десятим секунди\n"

#: src/stty.c:581
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
" * [-]crtscts    enable RTS/CTS handshaking\n"
" * [-]cdtrdsr    enable DTR/DSR handshaking\n"
"   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"\n"
"Параметри керування:\n"
"   [-]clocal     скасувати керівні сигнали модему\n"
"   [-]cread      дозволити ввід\n"
" * [-]crtscts    дозволити керування потоком RTS/CTS\n"
" * [-]cdtrdsr    дозволити керування потоком DTR/DSR\n"
"   csН           встановити розмір символу рівним Н біт, Н від 5 до 8\n"

#: src/stty.c:590
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"  [-]cstopb     два біти розділення у символі (один, якщо з '-')\n"
"  [-]hup        надсилати сигнал обриву термінальної лінії, коли останній\n"
"                процес закриває термінал\n"
"  [-]hupcl      синонім [-]hup\n"
"  [-]parenb     генерувати при виводі біт парності та очікувати біт "
"парності\n"
"                на вводі\n"
"  [-]parodd     встановити перевірку на непарність (або парність, якщо з "
"'-')\n"

#: src/stty.c:597
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
msgstr ""
"\n"
"Параметри вводу:\n"
"  [-]brkint     символ break буде викликати сигнал переривання\n"
"  [-]icrnl      перетворювати переведення каретки у переведення рядка\n"
"  [-]ignbrk     ігнорувати символи переривання\n"
"  [-]igncr      ігнорувати символи переведення каретки\n"

#: src/stty.c:605
msgid ""
"   [-]ignpar     ignore characters with parity errors\n"
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"  [-]ignpar     ігнорувати символи з помилками парності\n"
"* [-]imaxbel    при переповненні буферу вводу подавати звуковий сигнал та\n"
"                не скидати буфер, ігноруючи подальший ввід\n"
"  [-]inlcr      перетворювати переведення рядка у переведення каретки\n"
"  [-]inpck      використовувати перевірку парності вводу\n"
"  [-]istrip     очищати старший (восьмий) біт символів, що вводяться\n"

#: src/stty.c:612
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8      вважати, що вхідні знаки у кодуванні UTF-8\n"

#: src/stty.c:615
msgid ""
" * [-]iuclc      translate uppercase characters to lowercase\n"
" * [-]ixany      let any character restart output, not only start character\n"
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"* [-]iuclc      перетворювати великі літери на малі\n"
"* [-]ixany      дозволити будь-якому символу відновити ввід\n"
"  [-]ixoff      дозволити надсилання символів призупинення/відновлення\n"
"  [-]ixon       дозволити керування потоком даних\n"
"  [-]parmrk     відмічати помилки парності (послідовністю з 255 нулів)\n"
"  [-]tandem     синонім [-]xioff\n"

#: src/stty.c:623
msgid ""
"\n"
"Output settings:\n"
" * bsN           backspace delay style, N in [0..1]\n"
" * crN           carriage return delay style, N in [0..3]\n"
" * ffN           form feed delay style, N in [0..1]\n"
" * nlN           newline delay style, N in [0..1]\n"
msgstr ""
"\n"
"Параметри виводу:\n"
"* bsН           пауза після забою, діапазон Н [0..1]\n"
"* crН           пауза після переведення каретки, діапазон Н [0..3]\n"
"* ffН           пауза після переведення сторінки, діапазон Н [0..1]\n"
"* nlН           пауза після нового рядка, діапазон Н [0..1]\n"

#: src/stty.c:631
msgid ""
" * [-]ocrnl      translate carriage return to newline\n"
" * [-]ofdel      use delete characters for fill instead of null characters\n"
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
" * [-]olcuc      translate lowercase characters to uppercase\n"
" * [-]onlcr      translate newline to carriage return-newline\n"
" * [-]onlret     newline performs a carriage return\n"
msgstr ""
"* [-]ocrnl      перетворювати переведення каретки у переведення рядка\n"
"* [-]ofdel      заповнювати символами затирання замість нулів\n"
"* [-]ofill      використовувати символи заповнення для затримок\n"
"* [-]olcuc      перетворювати маленькі літери на великі\n"
"* [-]onlcr      перетворювати переведення рядка у переведення каретки\n"
"* [-]onlret     переведення рядка призводить до переведення каретки\n"

#: src/stty.c:639
msgid ""
" * [-]onocr      do not print carriage returns in the first column\n"
"   [-]opost      postprocess output\n"
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
" * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
"* [-]onocr      не виводити переведення каретки у першому стовпчику\n"
"  [-]opost      форматувати вивід\n"
"* tabН          значення паузи після горизонтальної табуляції,\n"
"                допустимі Н [0..3]\n"
"* tabs          синонім tab0\n"
"* -tabs         синонім tab3\n"
"* vtН           пауза після вертикальної табуляції, діапазон Н [0..1]\n"

#: src/stty.c:647
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"Локальні параметри:\n"
"  [-]crterase   стирати символи як забиття-пробіл-забиття\n"
"* crtkill       стирати весь рядок, згідно з параметрами echoprt та echoe\n"
"* -crtkill      стирати весь рядок, згідно з параметрами echoctl та echok\n"

#: src/stty.c:654
msgid ""
" * [-]ctlecho    echo control characters in hat notation ('^c')\n"
"   [-]echo       echo input characters\n"
" * [-]echoctl    same as [-]ctlecho\n"
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"* [-]ctlecho    відображати керівні символи з шапкою ('^c')\n"
"  [-]echo       відображати символи, що вводяться\n"
"* [-]echoctl    синонім [-]ctlecho\n"
"  [-]echoe      синонім [-]crterase\n"
"  [-]echok      відображати переведення рядка після символу знищення\n"

#: src/stty.c:661
msgid ""
" * [-]echoke     same as [-]crtkill\n"
"   [-]echonl     echo newline even if not echoing other characters\n"
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
"   [-]icanon     enable erase, kill, werase, and rprnt special characters\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"* [-]echoke     синонім [-]crtkill\n"
"  [-]echonl     відображати переведення рядка, навіть якщо інші символи не\n"
"                відображаються\n"
"* [-]echoprt    виводити стерті символи у зворотному порядку, між '\\' та "
"'/'\n"
"  [-]icanon     використовувати спецсимволи erase, kill, werase, та rprnt\n"
"  [-]iexten     використовувати спецсимволи, не описані у стандарті POSIX\n"

#: src/stty.c:668
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
" * [-]prterase   same as [-]echoprt\n"
" * [-]tostop     stop background jobs that try to write to the terminal\n"
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""
"  [-]isig       використовувати спецсимволи interrupt, quit, та suspend\n"
"  [-]noflsh     заборонити скидання буферу після прийому спецсимволів\n"
"                interrupt та quit\n"
"* [-]prterase   синонім [-]echoprt\n"
"* [-]tostop     призупиняти фонові програми, що намагаються виконати запис\n"
"                на термінал\n"
"* [-]xcase      відображати '\\' для великих літер, вживається з icanon\n"

#: src/stty.c:675
msgid ""
"\n"
"Combination settings:\n"
" * [-]LCASE      same as [-]lcase\n"
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"\n"
"Об'єднані параметри:\n"
"* [-]LCASE      синонім [-]lcase\n"
"  cbreak        синонім -icanon\n"
"  -cbreak       синонім icanon\n"

#: src/stty.c:682
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
"   crt           same as echoe echoctl echoke\n"
msgstr ""
"  cooked        синонім brkint ignpar istrip icrnl ixon opost isig icanon,\n"
"                символи eof та eol мають типове значення\n"
"  -cooked       синонім raw\n"
"  crt           синонім echoe echoctl echoke\n"

#: src/stty.c:688
msgid ""
"   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                 kill ^u\n"
" * [-]decctlq    same as [-]ixany\n"
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
msgstr ""
"  dec           синонім echoe echoctl echoke -ixany intr ^c erase 0177\n"
"                 kill ^u\n"
"* [-]decctlq    синонім [-]ixany\n"
"  ek            встановити типові значення для символів erase та kill\n"
"  evenp         синонім parenb -parodd cs7\n"

#: src/stty.c:695
msgid ""
"   -evenp        same as -parenb cs8\n"
" * [-]lcase      same as xcase iuclc olcuc\n"
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
"   nl            same as -icrnl -onlcr\n"
"   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
msgstr ""
"  -evenp        синонім -parenb cs8\n"
"* [-]lcase      синонім xcase iuclc olcuc\n"
"  litout        синонім -parenb -istrip -opost cs8\n"
"  -litout       синонім parenb istrip opost cs7\n"
"  nl            синонім -icrnl -onlcr\n"
"  -nl           синонім icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#: src/stty.c:703
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"  oddp          синонім parenb parodd cs7\n"
"  -oddp         синонім -parenb cs8\n"
"  [-]parity     синонім [-]evenp\n"
"  pass8         синонім -parenb -istrip cs8\n"
"  -pass8        синонім parenb istrip cs7\n"

#: src/stty.c:710
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                 -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"  raw           синонім -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                -inlcr -igncr -icrnl  -ixon  -ixoff  -iuclc  -ixany\n"
"                -imaxbel -opost -isig -icanon -xcase min 1 time 0\n"
"  -raw          синонім cooked\n"

#: src/stty.c:716
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"                 -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                 -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                 isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                 -xcase -tostop -echoprt echoctl echoke, all special\n"
"                 characters to their default values\n"
msgstr ""
"  sane          синонім cread -ignbrk brkint -inlcr -igncr icrnl -iutf8\n"
"                -ixoff -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr\n"
"                -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\n"
"                isig icanon iexten echo echoe echok -echonl -noflsh\n"
"                -xcase -tostop -echoprt echoctl echoke, всі спецсимволи\n"
"                мають типове значення\n"

#: src/stty.c:724
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Керує термінальною лінією, що підключена до стандартного вводу.  Запущена\n"
"без аргументів, виводить швидкість передачі інформації, line discipline та\n"
"відмінності від звичайних параметрів.  В параметрах, СИМВОЛИ трактуються\n"
"буквально або вказуються у як ^c, 0x37, 0177 або 127; для скасування\n"
"спеціальних символів служать значення ^- та undef.\n"

#: src/stty.c:796
#, c-format
msgid "only one device may be specified"
msgstr "можна вказати лише одне пристрій"

#: src/stty.c:826
#, c-format
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"ключі для виводу у текстовому та виводі, зрозумілому програмі stty,\n"
"виключають один одного"

#: src/stty.c:832
#, c-format
msgid "when specifying an output style, modes may not be set"
msgstr "при вказуванні стилю виводу не можна встановлювати режим"

#: src/stty.c:847
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: не вдалося переініціалізувати неблокуючий режим"

#: src/stty.c:892 src/stty.c:1002
#, c-format
msgid "invalid argument %s"
msgstr "неправильний аргумент %s"

#: src/stty.c:903 src/stty.c:920 src/stty.c:932 src/stty.c:945 src/stty.c:957
#: src/stty.c:977
#, c-format
msgid "missing argument to %s"
msgstr "пропущений аргумент для %s"

#: src/stty.c:983
#, c-format
msgid "invalid line discipline %s"
msgstr "неправильна line discipline %s"

#: src/stty.c:1053
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: не вдалося виконати всі запитані дії"

#: src/stty.c:1399
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: для цього пристрою немає відомостей про розмір"

#: src/stty.c:1920
#, c-format
msgid "invalid integer argument %s"
msgstr "неправильний цілий аргумент %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:37
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:62
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"Виводить контрольну суму і кількість блоків для кожного ФАЙЛа.\n"
"\n"
"  -r              використовувати метод обчислення контрольних сум BSD,\n"
"                  розмір блоку 1 кБ\n"
"  -s, --sysv      використовувати метод обчислення контрольних сум System "
"V,\n"
"                  розмір блоку 512 байт\n"

#: src/sync.c:41
msgid ""
"Force changed blocks to disk, update the super block.\n"
"\n"
msgstr ""
"Записує змінені блоки на диск, оновлює суперблок\n"
"\n"

#: src/sync.c:69
#, c-format
msgid "ignoring all arguments"
msgstr "всі аргументи проігноровані"

#: src/system.h:343
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"ПРИМІТКА: ваша оболонка може надавати свою версію %s, яка\n"
"звичайно перекриває версію, описану тут.  Зверніться до\n"
"документації з вашої оболонки, щоб дізнатись, які ключі вона\n"
"підтримує.\n"

#: src/system.h:349
msgid "      --help     display this help and exit\n"
msgstr "      --help     показати цю довідку та вийти\n"

#: src/system.h:351
msgid "      --version  output version information and exit\n"
msgstr ""
"      --version  показати інформацію про версію та вийти\n"
"\n"

#: src/system.h:544
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"Обов'язкові аргументи для довгих форм запису параметрів є обов'язковими і "
"для скорочених форм.\n"

#: src/system.h:552
msgid ""
"\n"
"SIZE is an integer and optional unit (example: 10M is 10*1024*1024).  Units\n"
"are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of "
"1000).\n"
msgstr ""
"\n"
"РОЗМІР є цілим числом з додатковим значенням одиниці (приклад: 10M = "
"10*1024*1024).\n"
"Одиницями можуть бути K, M, G, T, P, E, Z, Y (степені 1024) або KB, MB... "
"(степені 1000).\n"

#: src/system.h:561
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"Показує значення у одиницях першого доступного РОЗМІРу з --block-size\n"
"та змінні середовища %s_BLOCK_SIZE, BLOCK_SIZE та BLOCKSIZE.\n"
"Якщо розмір не буде знайдено, типовою одиницею буде 1024 байтів\n"
"(або 512, якщо встановлено POSIXLY_CORRECT).\n"

#: src/system.h:571
#, c-format
msgid ""
"\n"
"Report %s bugs to %s\n"
msgstr ""
"\n"
"Про вади у %s повідомляйте на адресу %s.\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <http://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at http://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:585
#, c-format
msgid "Report %s translation bugs to <http://translationproject.org/team/>\n"
msgstr ""
"Повідомте %s про помилку у перекладі на <http://translationproject.org/team/"
">\n"

#: src/system.h:589
#, c-format
msgid "For complete documentation, run: info coreutils '%s invocation'\n"
msgstr ""
"Ознайомитися з повною документацією можна за допомогою команди info "
"coreutils '%s invocation'\n"

#: src/system.h:596
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "Спробуйте '%s --help' для одержання додаткової інформації.\n"

#: src/system.h:628
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"УВАГА: Зациклення у структурі каталогу.\n"
"Швидше за все, це означає, що ваша файлова система пошкоджена.\n"
"ПОВІДОМТЕ ВАШОГО СИСТЕМНОГО АДМІНІСТРАТОРА.\n"
"Наступний каталог є частиною циклу:\n"
" %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:58
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:137
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Виводить ФАЙЛИ на стандартний вивід, починаючи з останньої рядка.\n"
"Якщо ФАЙЛ не вказано або вказано як -, читає стандартний ввід.\n"

#: src/tac.c:144
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             приєднати розділювач до початку, а не до кінця\n"
"  -r, --regex              сприймати розділювач як регулярний вираз\n"
"  -s, --separator=РЯДОК    вказати розділювачем РЯДОК, а не знак '\\n'\n"

#: src/tac.c:234 src/tac.c:335
#, c-format
msgid "%s: seek failed"
msgstr "%s: помилка переміщення по файла"

#: src/tac.c:263
#, c-format
msgid "record too large"
msgstr "запис надто великий"

#: src/tac.c:450
#, c-format
msgid "failed to create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/tac.c:458
#, c-format
msgid "failed to open %s for writing"
msgstr "не вдалося відкрити %s для читання"

#: src/tac.c:475
#, c-format
msgid "failed to rewind stream for %s"
msgstr "не вдалося повернутися до початку потоку даних для %s"

#: src/tac.c:511 src/tac.c:518
#, c-format
msgid "%s: write error"
msgstr "%s: помилка запису"

#: src/tac.c:571
#, c-format
msgid "failed to open %s for reading"
msgstr "помилка при спробі відкрити %s для читання"

#: src/tac.c:629
#, c-format
msgid "separator cannot be empty"
msgstr "розділювач не може бути порожнім"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:71
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:262
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Виводить останні %d рядків кожного з ФАЙЛІВ на стандартний вивід.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводить заголовок з назвою файла.\n"
"Якщо ФАЙЛ не вказано або вказано як -, читає стандартний ввід.\n"

#: src/tail.c:270
msgid ""
"  -c, --bytes=K            output the last K bytes; alternatively, use -c "
"+K\n"
"                           to output bytes starting with the Kth of each "
"file\n"
msgstr ""
"  -c, --bytes=Н            вивести останні Н байтів; вкажіть «-c +Н»,\n"
"                           щоб виведення було розпочато з Н-го байта кожного "
"з файлів\n"

#: src/tail.c:274
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                           -f, --follow, and --follow=descriptor are\n"
"                           equivalent\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           виводити дані, що надходять, при зростанні "
"файла;\n"
"                           -f, --follow та --follow=descriptor еквівалентні\n"
"  -F                       еквівалент --follow=name --retry\n"

#: src/tail.c:281
#, c-format
msgid ""
"  -n, --lines=K            output the last K lines, instead of the last %d;\n"
"                           or use -n +K to output lines starting with the "
"Kth\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                           changed size after N (default %d) iterations\n"
"                           to see if it has been unlinked or renamed\n"
"                           (this is the usual case of rotated log files).\n"
"                           With inotify, this option is rarely useful.\n"
msgstr ""
"  -n, --lines=Н            виводити останні Н рядків, а не останні %d\n"
"                           скористайтеся -n +K для виведення рядків з Н-го\n"
"      --max-unchanged-stats=Н\n"
"                           c ключем --follow=name, повторно відкривати\n"
"                           ФАЙЛ, який не змінився останні Н (типово %d)\n"
"                           ітерацій, щоб перевірити, чи не було його "
"вилучено\n"
"                           або перейменовано (таке звичайно буває при\n"
"                           ротації системних протокольних файлів)\n"
"                           З inotify цей параметр малокорисний.\n"

#: src/tail.c:294
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file even when it is or\n"
"                             becomes inaccessible; useful when following by\n"
"                             name, i.e., with --follow=name\n"
msgstr ""
"      --pid=PID            з ключем -f, перерватися, коли процес PID\n"
"                           завершує роботу\n"
"  -q, --quiet, --silent    не виводити заголовки з назвами файлів\n"
"      --retry              повторювати спроби відкрити файл, навіть якщо\n"
"                             доступ до нього буде втрачено, корисно, якщо \n"
"                             вказано назву файла, тобто з --follow=name\n"

#: src/tail.c:301
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations.\n"
"                             With inotify and --pid=P, check process P at\n"
"                             least once every N seconds.\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=Н   з ключем -f, перевіряти отримання нових даних\n"
"                             приблизно кожні Н секунд (типово 1).\n"
"                             Якщо використано inotify і --pid=P, перевіряти\n"
"                             процес P принаймні кожні Н секунд.\n"
"  -v, --verbose            завжди виводити заголовки з назвами файлів\n"

#: src/tail.c:310
msgid ""
"\n"
"If the first character of K (the number of bytes or lines) is a '+',\n"
"print beginning with the Kth item from the start of each file, otherwise,\n"
"print the last K items in the file.  K may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"\n"
msgstr ""
"\n"
"Якщо першим символом у Н (числі байт або рядків) є «+», виведення буде\n"
"розпочато з Н-ого елемента від початку кожного файла, інакше буде\n"
"виведено останні Н елементи. Н може мати суфікс-множник: b 512, kB 1000, K "
"1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"\n"

#: src/tail.c:319
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"З --follow (-f) tail типово слідкує за дескриптором файла, тобто, навіть "
"якщо\n"
"назву файла буде змінено, tail продовжуватиме стежити за його кінцем.\n"
"Така типова поведінка небажана, якщо ви хочете слідкувати за файлом, який\n"
"має певну назву, а не за дескриптором (наприклад файлом журналу, який\n"
"підлягає періодичній ротації). У такому разі використовуйте\n"
"--follow=name. Це змусить tail слідувати за вказаним файлом, беручи до "
"уваги\n"
"його перейменування, вилучення або створення.\n"

#: src/tail.c:378
#, c-format
msgid "closing %s (fd=%d)"
msgstr "закриття %s (fd=%d)"

#: src/tail.c:453
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s"

#: src/tail.c:457
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s відносно кінця"

#: src/tail.c:894
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr ""
"не вдалося визначити розташування %s. Повертаємося до способу опитування"

#: src/tail.c:906
#, c-format
msgid ""
"unrecognized file system type 0x%08lx for %s. please report this to %s. "
"reverting to polling"
msgstr ""
"Нерозпізнаний тип файлової системи 0x%08lx для %s. Будь ласка, повідомте про "
"нього до %s. Повертаємося до простого опитування."

#: src/tail.c:963
#, c-format
msgid "%s has become inaccessible"
msgstr "%s став недоступний"

#: src/tail.c:980
#, c-format
msgid "%s has been replaced with an untailable file; giving up on this name"
msgstr ""
"%s був замінений файлом, для якого tail незастосовний; кінець виводу для "
"цієї назви"

#: src/tail.c:989
#, c-format
msgid "%s has been replaced with a remote file. giving up on this name"
msgstr "%s було замінено віддаленим файлом. Кінець виводу для цієї назви"

#: src/tail.c:1010
#, c-format
msgid "%s has become accessible"
msgstr "%s став доступний"

#: src/tail.c:1018
#, c-format
msgid "%s has appeared;  following end of new file"
msgstr "%s з'явився; початий вивід для нового файла"

#: src/tail.c:1029
#, c-format
msgid "%s has been replaced;  following end of new file"
msgstr "%s був заміщений; вивід продовжується для нового файла"

#: src/tail.c:1130
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: не вдалося змінити неблокуючий режим"

#: src/tail.c:1172 src/tail.c:1287
#, c-format
msgid "%s: file truncated"
msgstr "%s: файл обрізаний"

#: src/tail.c:1196 src/tail.c:1442
#, c-format
msgid "no files remaining"
msgstr "більше немає файлів"

#: src/tail.c:1369
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "не вдалося виконати спостереження за батьківським каталогом %s"

#: src/tail.c:1372 src/tail.c:1387
#, c-format
msgid "inotify resources exhausted"
msgstr "вичерпано ресурси inotify"

#: src/tail.c:1390 src/tail.c:1519
#, c-format
msgid "cannot watch %s"
msgstr "не вдалося виконати спостереження за %s"

#: src/tail.c:1473
#, c-format
msgid "error monitoring inotify event"
msgstr "помилка під час стеження за подією inotify"

#: src/tail.c:1493
#, c-format
msgid "error reading inotify event"
msgstr "помилка під час спроби читання події inotify"

#: src/tail.c:1786
#, c-format
msgid "%s: cannot follow end of this type of file; giving up on this name"
msgstr ""
"%s: не можна стежити за кінцем файла такого типу; вивід продовжується для "
"нового файла"

#: src/tail.c:1903
#, c-format
msgid "number in %s is too large"
msgstr "число у %s надто велике"

#: src/tail.c:1975
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr ""
"%s: неправильна максимальна кількість не змінених параметрів між відкриттями"

#: src/tail.c:1991
#, c-format
msgid "%s: invalid PID"
msgstr "%s: неправильний PID"

#: src/tail.c:2010
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: неправильне число секунд"

#: src/tail.c:2026
#, c-format
msgid "option used in invalid context -- %c"
msgstr "параметр використовує неправильний контекст -- %c"

#: src/tail.c:2034
#, c-format
msgid "warning: --retry is useful mainly when following by name"
msgstr ""
"попередження: ключ --retry корисний лише при слідуванні за назвою файла"

#: src/tail.c:2038
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"попередження: PID ігнорований; ключ --pid=PID корисний лише при слідуванні"

#: src/tail.c:2041
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "попередження: --pid=PID не підтримується на цій системі"

#: src/tail.c:2142
#, c-format
msgid "cannot follow %s by name"
msgstr "не вдалося слідувати за %s за назвою"

#: src/tail.c:2148
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "попередження: нескінченне стеження за стандартним вводом неефективне"

#: src/tail.c:2209
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "не можна використовувати inotify, повертаємося до способу опитування"

#: src/tee.c:63
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Копіює стандартний ввід у кожен ФАЙЛ, а також у стандартний вивід.\n"
"\n"
"  -a, --append              дописати у вказані ФАЙЛИ\n"
"  -i, --ignore-interrupts   ігнорувати сигнали переривання\n"

#: src/tee.c:71
msgid ""
"\n"
"If a FILE is -, copy again to standard output.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказаний як -, копіює знову у стандартний вивід.\n"

#: src/test.c:123
#, c-format
msgid "missing argument after %s"
msgstr "пропущений аргумент після %s"

#: src/test.c:159
#, c-format
msgid "invalid integer %s"
msgstr "неправильне ціле число %s"

#: src/test.c:241
msgid "')' expected"
msgstr "очікується ')'"

#: src/test.c:244
#, c-format
msgid "')' expected, found %s"
msgstr "очікується ')', виявлено %s"

#: src/test.c:260 src/test.c:618
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очікується унарний оператор"

#: src/test.c:329
msgid "-nt does not accept -l"
msgstr "-nt не допускає -l"

#: src/test.c:342
msgid "-ef does not accept -l"
msgstr "-ef не допускає -l"

#: src/test.c:358
msgid "-ot does not accept -l"
msgstr "-ot не допускає -l"

#: src/test.c:367
msgid "unknown binary operator"
msgstr "невідомий двійковий оператор"

#: src/test.c:646
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очікується двійковий оператор"

#: src/test.c:704
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Використання: test ВИРАЗ\n"
"  або:  test\n"
"  або:  [ ВИРАЗ ]\n"
"  або:  [ ]\n"
"  або:  [ КЛЮЧ\n"

#: src/test.c:711
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr "Вихідний статус визначається ВИРАЗОМ.\n"

#: src/test.c:717
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Якщо ВИРАЗ не вказаний, він вважається хибним.  У іншому випадку\n"
"ВИРАЗ може бути істинним або хибним; він встановлює статус\n"
"завершення програми.  Код завершення визначається наступним образом:\n"

#: src/test.c:722
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( ВИРАЗ )               ВИРАЗ істинний\n"
"  ! ВИРАЗ                 ВИРАЗ хибний\n"
"  ВИРАЗ1 -a ВИРАЗ2        ВИРАЗ1 та ВИРАЗ2 обидва істинні\n"
"  ВИРАЗ1 -o ВИРАЗ2        ВИРАЗ1 або ВИРАЗ2 істинний\n"

#: src/test.c:729
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n РЯДОК            довжина РЯДКА відмінна від нуля\n"
"  РЯДОК               еквівалентно -n РЯДОК\n"
"  -z РЯДОК            довжина РЯДКА дорівнює нулю\n"
"  РЯДОК1 = РЯДОК2     рядки еквівалентні\n"
"  РЯДОК1 != РЯДОК2    рядки не еквівалентні\n"

#: src/test.c:737
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ЦІЛЕ1 -eq ЦІЛЕ2   ЦІЛЕ1 дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -ge ЦІЛЕ2   ЦІЛЕ1 більше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -gt ЦІЛЕ2   ЦІЛЕ1 більше ЦІЛОГО2\n"
"  ЦІЛЕ1 -le ЦІЛЕ2   ЦІЛЕ1 менше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -lt ЦІЛЕ2   ЦІЛЕ1 менше ЦІЛОГО2\n"
"  ЦІЛЕ1 -ne ЦІЛЕ2   ЦІЛЕ1 відмінне від ЦІЛОГО2\n"

#: src/test.c:746
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  ФАЙЛ1 -ef ФАЙЛ2   ФАЙЛ1 та ФАЙЛ2 мають одинакові пристрої та номери inode\n"
"  ФАЙЛ1 -nt ФАЙЛ2   ФАЙЛ1 змінювався пізніше ніж ФАЙЛ2\n"
"  ФАЙЛ1 -ot ФАЙЛ2   ФАЙЛ1 створений пізніше ніж ФАЙЛ2\n"

#: src/test.c:752
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b ФАЙЛ     ФАЙЛ існує та є спеціальним з блочним доступом\n"
"  -c ФАЙЛ     ФАЙЛ існує та є спеціальним з символьним доступом\n"
"  -d ФАЙЛ     ФАЙЛ існує та є каталогом\n"
"  -e ФАЙЛ     ФАЙЛ існує\n"

#: src/test.c:759
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f ФАЙЛ     ФАЙЛ існує та є звичайним файлом\n"
"  -g ФАЙЛ     ФАЙЛ існує та має ознака set-group-ID\n"
"  -G ФАЙЛ     ФАЙЛ існує та належить поточної ефективній групі\n"
"  -h ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -L)\n"
"  -k ФАЙЛ     ФАЙЛ існує та має ознака sticky\n"

#: src/test.c:766
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -h)\n"
"  -O ФАЙЛ     ФАЙЛ існує та належить поточному ефективному користувачу\n"
"  -p ФАЙЛ     ФАЙЛ існує та є іменованим каналом\n"
"  -r ФАЙЛ     ФАЙЛ існує доступний для читання\n"
"  -s ФАЙЛ     ФАЙЛ існує та має ненульовий розмір\n"

#: src/test.c:773
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S ФАЙЛ     ФАЙЛ існує та є сокетом\n"
"  -t [ДФ]     дескриптор файла ДФ відкритий на терміналі\n"
"  -u ФАЙЛ     ФАЙЛ існує та має ознака set-user-ID\n"
"  -w ФАЙЛ     ФАЙЛ існує та доступний для запису\n"
"  -x ФАЙЛ     ФАЙЛ існує та є виконуваним\n"

#: src/test.c:780
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Всі тести, що відносяться до ФАЙЛА, крім -h та -L розіменовують\n"
"символьні посилання.  Пам'ятайте, що ви повинні скасувати спеціальне\n"
"значення дужок для командного інтерпретатора (наприклад, за допомогою\n"
"знаку '\\').  ЦІЛЕ може також бути вказане як \"-l РЯДОК\", при цьому\n"
"воно приймає значення довжини РЯДКА.\n"

#: src/test.c:786
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"ПРИМІТКА: [ притримується параметрів --help та --version options, але тест - "
"ні.\n"
"інтерпретує кожен з цих параметрів як будь-який непорожній рядок.\n"

#: src/test.c:791
msgid "test and/or ["
msgstr "test та/або ["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:803
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:804
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:858
msgid "missing ']'"
msgstr "пропущено ']'"

#: src/test.c:872
#, c-format
msgid "extra argument %s"
msgstr "зайвий аргумент %s"

#: src/timeout.c:112
#, c-format
msgid "warning: sigprocmask"
msgstr "попередження: sigprocmask"

#: src/timeout.c:145
#, c-format
msgid "warning: timer_settime"
msgstr "попередження: timer_settime"

#: src/timeout.c:150
#, c-format
msgid "warning: timer_create"
msgstr "попередження: timer_create"

#: src/timeout.c:225
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] ТРИВАЛІСТЬ КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s [ПАРАМЕТР]\n"

#: src/timeout.c:229
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr ""
"Запустити КОМАНДУ і завершити її роботу, якщо її не буде завершено протягом "
"часу ТРИВАЛІСТЬ.\n"

#: src/timeout.c:235
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                 command times out\n"
"      --foreground\n"
"                 When not running timeout directly from a shell prompt,\n"
"                 allow COMMAND to read from the TTY and receive TTY "
"signals.\n"
"                 In this mode, children of COMMAND will not be timed out.\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                 this long after the initial signal was sent.\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout.\n"
"                 SIGNAL may be a name like 'HUP' or a number.\n"
"                 See 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 вийти зі станом рівним стану КОМАНДИ, навіть якщо час\n"
"                 час очікування на завершення команди перевищено\n"
"      --foreground\n"
"                 Якщо timeout не запущено безпосередньо з командної "
"оболонки,\n"
"                 надати змогу КОМАНДІ читати дані з TTY і отримувати сигнали "
"TTY.\n"
"                 У цьому режимі дочірні процеси КОМАНДИ не підлягатимуть "
"обмеженню\n"
"                 часу очікування на завершення.\n"
"  -k, --kill-after=ТРИВАЛІСТЬ\n"
"                 надсилати сигнал KILL, якщо КОМАНДА не завершила роботу\n"
"                 протягом вказаного часу з надсилання початкового сигналу.\n"
"  -s, --signal=СИГНАЛ\n"
"                 вказати сигнал, який слід надсилати у разі перевищення "
"часу\n"
"                 очікування.\n"
"                 СИГНАЛом може бути назва, наприклад HUP, або число.\n"
"                 Переглянути список сигналів можна за допомогою команди\n"
"                 «kill -l»\n"

#: src/timeout.c:254
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
msgstr ""
"\n"
"ТРИВАЛІСТЬ — число з плаваючою крапкою з додатковим суфіксом:\n"
"«s» — секунди (типовий), «m» — хвилини, «h» — години або «d» — дні.\n"

#: src/timeout.c:259
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""
"\n"
"Якщо час очікування на завершення команди буде перевищено, і не вказано\n"
"--preserve-status, вийти з кодом стану 124. Якщо цього не відбудеться,\n"
"вийти з кодом стану КОМАНДИ. Якщо сигналу не вказано, надіслати сигнал TERM\n"
"після перевищення часу очікування. Сигнал TERM перерве виконання будь-яких\n"
"процесів, які не блокують і не перехоплюють цей сигнал. Іншим\n"
"процесам слід насилати сигнал KILL (9), оскільки цей сигнал не може\n"
"бути перехоплено. Якщо надіслано сигнал KILL (9), станом виходу буде\n"
"128+9, а не 124.\n"

#: src/timeout.c:363
#, c-format
msgid "warning: disabling core dumps failed"
msgstr "попередження: спроба вимикання дампів ядра завершилася невдало"

#: src/timeout.c:471
#, c-format
msgid "error waiting for command"
msgstr "помилка під час очікування на команду"

#: src/timeout.c:482
#, c-format
msgid "the monitored command dumped core"
msgstr ""
"команда, за якою виконувалося спостереження, завершила роботу критичною "
"помилкою"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:43
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:45
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:115 src/touch.c:309
#, c-format
msgid "invalid date format %s"
msgstr "неправильний формат дати %s"

#: src/touch.c:191
#, c-format
msgid "cannot touch %s"
msgstr "не вдалося виконати touch для %s"

#: src/touch.c:197
#, c-format
msgid "setting times of %s"
msgstr "встановлення тимчасових позначок %s"

#: src/touch.c:213
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"Оновити час доступу та час зміни кожного ФАЙЛА до поточної позначки часу.\n"
"\n"
"Якщо ФАЙЛа у аргументі не існує і не вказано -c або -h, його буде створено\n"
"порожнім.\n"
"\n"
"Якщо у аргументі ФАЙЛ вказано символ -, він обробляється особливим чином\n"
"та призводить до зміни позначки часу для файла, пов'язаного зі стандартним\n"
"виведенням даних.\n"

#: src/touch.c:225
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     змінювати лише час доступу\n"
"  -c, --no-create        не створювати файлів\n"
"  -d, --date=РЯДОК       проаналізувати РЯДОК і використовувати його\n"
"                          замість поточного часу\n"
"  -f                     (ігнорується)\n"

#: src/touch.c:231
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   впливає на символічне посилання, а не на файл,\n"
"                         на який вказує (діє лише на системі з підтримкою\n"
"                         зміни часових позначок символічних посилань)\n"
"  -m                     змірити лише час внесення змін\n"

#: src/touch.c:237
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=ФАЙЛ   використовувати час ФАЙЛА замість поточного\n"
"  -t Час                 використовувати [[ВВ]РР]ММДДггхх[.сс] замість\n"
"                           поточного часу\n"
"  --time=СЛОВО           змінити вказаний час:\n"
"                          СЛОВО access, atime, use еквівалентно -a\n"
"                          СЛОВО modify, mtime еквівалентно -m\n"

#: src/touch.c:246
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Зауважте, що ключі -d та -t сприймають різні формати дати та часу.\n"

#: src/touch.c:335
#, c-format
msgid "cannot specify times from more than one source"
msgstr "не вдалося вказати час з кількох джерел"

#: src/touch.c:409
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"попередження: 'touch %s' застарів; використовуйте 'touch -t %04ld%02d%02d%02d"
"%02d.%02d'"

#: src/tr.c:286
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Використання: %s [КЛЮЧ]... НАБІР1 [НАБІР2]\n"

#: src/tr.c:290
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each input sequence of a repeated "
"character\n"
"                            that is listed in SET1 with a single occurrence\n"
"                            of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Перетворює, ущільнює та/або вилучає символи зі стандартного введення і\n"
"виводить їх до стандартного виведення.\n"
"\n"
"  -c, -C, --complement    спочатку отримати доповнення ТАБЛИЦІ1\n"
"  -d, --delete            вилучати знаки з ТАБЛИЦІ1, не перетворювати\n"
"  -s, --squeeze-repeats   заміщати послідовності знаків, що повторюються, з\n"
"                          перелічених у ТАБЛИЦІ1 на єдиний такий знак\n"
"  -t, --truncate-set1     спочатку вкоротити ТАБЛИЦЮ1 до розміру ТАБЛИЦІ2\n"

#: src/tr.c:303
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"ТАБЛИЦі вказуються як символьні рядки.  У багатьох випадках символи\n"
"представляють самі себе.  Приймаються наступні послідовності:\n"
"\n"
"  \\ННН            знак з вісімковим кодом ННН (від 1 до 3 цифр)\n"
"  \\\\              зворотна похила риска\n"
"  \\a              звуковий сигнал\n"
"  \\b              забиття\n"
"  \\f              переведення сторінки\n"
"  \\n              новий рядок\n"
"  \\r              переведення каретки\n"
"  \\t              горизонтальна табуляція\n"

#: src/tr.c:317
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              вертикальна табуляція\n"
"  ЗНАК1-ЗНАК2     всі знаки від ЗНАК1 до ЗНАК2 у порядку зростання\n"
"  [ЗНАК*]         ЗНАК заповнює ТАБЛИЦЮ2 до довжини ТАБЛИЦІ1\n"
"  [ЗНАК*ЧИСЛО]    вказане ЧИСЛО однакових ЗНАКІВ; ЧИСЛО вісімкових, якщо\n"
"                  починається з 0\n"
"  [:alnum:]       всі літери та цифри\n"
"  [:alpha:]       всі літери\n"
"  [:blank:]       всі горизонтальні пробільні символи\n"
"  [:cntrl:]       всі керівні знаки\n"
"  [:digit:]       всі цифри\n"

#: src/tr.c:328
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       всі друковані знаки, за винятком пробілу\n"
"  [:lower:]       всі маленькі літери\n"
"  [:print:]       всі друковані знаки, включно з пробілом\n"
"  [:punct:]       всі знаки пунктуації\n"
"  [:space:]       всі вертикальні або горизонтальні пробільні знаки\n"
"  [:upper:]       всі великі літери\n"
"  [:xdigit:]      всі шістнадцяткові цифри\n"
"  [=ЗНАК=]        всі знаки, еквівалентні ЗНАКУ\n"

#: src/tr.c:338
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"Перетворення виконується, якщо не вказано -d і обох таблиць, ТАБЛИЦІ1\n"
"і ТАБЛИЦІ2. -t можна використовувати лише під час перетворення.\n"
"Якщо потрібно, ТАБЛИЦЮ2 буде розширено до розмірів ТАБЛИЦІ1\n"
"повторенням останнього символу. Зайві символи ТАБЛИЦІ2 буде пропущено.\n"
"Гарантовано розширюються у порядку зростання лише [:lower:] і [:upper:].\n"
"Використані у ТАБЛИЦІ2 під час перетворення символи можна використовувати\n"
"для визначення перетворення регістру лише у парах. -s використовує "
"ТАБЛИЦЮ1,\n"
"якщо не виконується ні перетворення, ні вилучення. Інакше, для ущільнення\n"
"використовується ТАБЛИЦЯ2. Ущільнення відбувається після перетворення або\n"
"вилучення.\n"

#: src/tr.c:509
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"попередження: неоднозначна вісімкова послідовність \\%c%c%c трактується\n"
"як двобайтова послідовність \\0%c%c, %c"

#: src/tr.c:518
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"попередження: неекранована зворотна похила риска наприкінці формату не є "
"переносимою"

#: src/tr.c:673
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "неправильний порядок меж діапазону '%s-%s'"

#: src/tr.c:829
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "неправильно вказана кількість повторів %s у конструкції [c*n]"

#: src/tr.c:910
#, c-format
msgid "missing character class name '[::]'"
msgstr "пропущено назву класу знаків '[::]'"

#: src/tr.c:913
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "пропущений знак класу еквівалентності '[==]'"

#: src/tr.c:928
#, c-format
msgid "invalid character class %s"
msgstr "неправильний клас знаків %s"

#: src/tr.c:947
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: потрібно вказати один символ, що визначає клас еквівалентних йому"

#: src/tr.c:1229
#, c-format
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "непарні конструкції [:upper:] та/або [:lower:]"

#: src/tr.c:1335
#, c-format
msgid "too many characters in set"
msgstr "надто багато знаків у таблиці"

#: src/tr.c:1420
#, c-format
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""
"якщо під час перетворення рядок1 буде довшим за рядок2,\n"
"останній рядок не повинен завершуватися класом символів"

#: src/tr.c:1480
#, c-format
msgid "the [c*] repeat construct may not appear in string1"
msgstr "конструкція [c*] не може використовуватись у ТАБЛИЦІ1"

#: src/tr.c:1490
#, c-format
msgid "only one [c*] repeat construct may appear in string2"
msgstr "у ТАБЛИЦІ2 може використовуватись лише одна конструкція [c*]"

#: src/tr.c:1498
#, c-format
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "вираз [=c=] не може використовуватись у ТАБЛИЦІ2 при перетворенні"

#: src/tr.c:1505
#, c-format
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"при перетворенні, у ТАБЛИЦІ2 можуть використовуватись лише\n"
"класи 'upper' та 'lower'"

#: src/tr.c:1520
#, c-format
msgid "when not truncating set1, string2 must be non-empty"
msgstr ""
"якщо частина таблиці1 не відкидається, таблиця2 не повинна бути порожньою"

#: src/tr.c:1529
#, c-format
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"при перетворенні з доповненням класів символів, ТАБЛИЦЯ2 повинна\n"
"ставити у відповідність всім символам доповнення рівно один символ"

#: src/tr.c:1538
#, c-format
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"конструкція [c*] може використовуватись у ТАБЛИЦІ2 лише при перетворенні"

#: src/tr.c:1788
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "При вилученні і ущільненні повторів слід вказати два рядки."

#: src/tr.c:1790
msgid "Two strings must be given when translating."
msgstr "При перетворенні потрібно вказати дві таблиці."

#: src/tr.c:1800
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"При вилученні без ущільнення повторів можна вказати дві лише одну таблицю."

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ аргументи командного рядка, що ігноруються ]\n"
"       або:    %s КЛЮЧ\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Завершення з успішним статусом."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Завершення роботи з кодом стану, що відповідає невдалому виконанню."

#: src/truncate.c:96
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Використання: %s ПАРАМЕТР... ФАЙЛ...\n"

#: src/truncate.c:97
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"Зменшити або збільшити розмір кожного ФАЙЛа до вказаного значення\n"
"\n"
"Якщо ФАЙЛа не існує, його буде створено.\n"
"\n"
"Якщо розмір ФАЙЛа перевищуватиме вказаний, додаткові дані буде втрачено.\n"
"Якщо розмір ФАЙЛа буде меншим, його буде збільшено. Додаткову частину\n"
"буде заповнено нульовими байтами.\n"

#: src/truncate.c:109
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create        не створювати файлів\n"

#: src/truncate.c:112
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""
"  -o, --io-blocks        вважати РОЗМІР кількістю блоків введення-вивадення, "
"а не байтів\n"

#: src/truncate.c:115
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE\n"
msgstr ""
"  -r, --reference=RФАЙЛ  основний розмір RФАЙЛА\n"
"  -s, --size=РОЗМІР      встановити або змінити розмір файла, відповідно до "
"РОЗМІР\n"

#: src/truncate.c:121
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"Перед РОЗМІРом може бути додано один з таких символів-модифікаторів:\n"
"«+» — розширити, «-» — звузити, «<» — не більше, «>» — не менше,\n"
"«/» — зменшити до кратного, «%» — збільшити до кратного.\n"

#: src/truncate.c:149
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdMAX> byte blocks for file %s"
msgstr "переповнення у %<PRIdMAX> * %<PRIdMAX> байтових блоків для файла %s"

#: src/truncate.c:173
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s має непридатний, ймовірно від'ємний розмір"

#: src/truncate.c:183 src/truncate.c:384
#, c-format
msgid "cannot get the size of %s"
msgstr "не вдалося визначити розмір %s"

#: src/truncate.c:205
#, c-format
msgid "overflow rounding up size of file %s"
msgstr "переповнення під час округлення розміру файла %s у бік збільшення"

#: src/truncate.c:215
#, c-format
msgid "overflow extending size of file %s"
msgstr "переповнення під час розширення розміру файла %s"

#: src/truncate.c:230
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "не вдалося обрізати %s до %<PRIdMAX> байтів"

#: src/truncate.c:303
#, c-format
msgid "multiple relative modifiers specified"
msgstr "вказано декілька відносних модифікаторів"

#: src/truncate.c:333
#, c-format
msgid "you must specify either %s or %s"
msgstr "можна визначити лише щось одне: %s або %s"

#: src/truncate.c:340
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "вам слід вказати відносний %s з %s"

#: src/truncate.c:347
#, c-format
msgid "%s was specified but %s was not"
msgstr "вказано %s, але без %s"

#: src/truncate.c:404
#, c-format
msgid "cannot open %s for writing"
msgstr "не вдалося відкрити %s для запису"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
msgstr ""
"Використання: %s [КЛЮЧ] [ФАЙЛ]\n"
"Виводити повністю сортований список, що відповідає частковому сортуванню\n"
"у заданому ФАЙЛІ.  Якщо ФАЙЛ не вказаний або вказаний як -, читається\n"
"стандартний ввід.\n"
"\n"

#: src/tsort.c:472
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: на вході міститься непарна кількість лексем"

#: src/tsort.c:518
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: на вході міститься цикл:"

#: src/tty.c:65
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Виводить назву файла для терміналу, що приєднаний до стандартному вводу.\n"
"\n"
"  -s, --silent, --quiet   не виводити, лише повернути код завершення\n"

#: src/tty.c:120
msgid "not a tty"
msgstr "не tty"

#: src/uname.c:124
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Виводить певні відомості про систему.  Якщо КЛЮЧ не вказаний,\n"
"вважається -s.\n"
"\n"
"  -a, --all                вивести всю інформацію, у наступному порядку,\n"
"                            крім -p та -i, якщо вони невідомі:\n"
"  -s, --kernel-name        вивести назву ядра\n"
"  -n, --nodename           вивести назву машини у мережі\n"
"  -r, --release            вивести номер випуску операційної системи\n"

#: src/uname.c:133
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type or \"unknown\"\n"
"  -i, --hardware-platform  print the hardware platform or \"unknown\"\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     вивести версію ядра\n"
"  -m, --machine            вивести тип обладнання машини\n"
"  -p, --processor          вивести тип процесора або \"невідомо\"\n"
"  -i, --hardware-platform  вивести тип апаратної платформи або \"невідомо\"\n"
"  -o, --operating-system   вивести назву операційної системи\n"

#: src/uname.c:143
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Вивести архітектуру машини.\n"
"\n"

#: src/uname.c:286
#, c-format
msgid "cannot get system name"
msgstr "не вдалося дізнатись назву системи"

#: src/unexpand.c:117
msgid ""
"Convert blanks in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Перетворює пробіли у ФАЙЛАХ у знаки табуляції та виводить на\n"
"стандартний вивід. Якщо ФАЙЛ не вказано або вказано як -, читаються\n"
"дані зі стандартного джерела вхідних даних.\n"

#: src/unexpand.c:124
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
"  -t, --tabs=LIST  use comma separated LIST of tab positions (enables -a)\n"
msgstr ""
"  -a, --all         перетворювати всі пробільні знаки, а не лише початкові\n"
"      --first-only  перетворювати лише початкові пробільні знаки\n"
"                      (перекриває-a)\n"
"  -t, --tabs=ЧИСЛО  вживати табуляцію вказаної ширини, а не 8 (включає -a)\n"
"  -t, --tabs=СПИСОК використовувати заданий СПИСОК (розділених комами)\n"
"                       позицій табуляції (включає -a)\n"

#: src/unexpand.c:152
#, c-format
msgid "tabs are too far apart"
msgstr "позиції табуляції надто далеко одна від одної"

#: src/unexpand.c:504
#, c-format
msgid "tab stop value is too large"
msgstr "розмір табуляції надто великий"

#: src/uniq.c:134
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Використання: %s [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/uniq.c:138
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"Фільтрує сусідні відповідні рядків з ВХОДУ (або стандартного введення),\n"
"з записом до ВИХОДУ (або стандартного виведення).\n"
"\n"
"Якщо не вказано параметрів, відповідні рядки об'єднуються з рядками,\n"
"виявленими першими.\n"

#: src/uniq.c:147
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
msgstr ""
"  -c, --count           виводити число повторів на початку кожного рядка\n"
"  -d, --repeated        виводити лише рядки, що повторюються\n"

#: src/uniq.c:151
msgid ""
"  -D, --all-repeated[=delimit-method]  print all duplicate lines\n"
"                        delimit-method={none(default),prepend,separate}\n"
"                        Delimiting is done with blank lines\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -z, --zero-terminated  end lines with 0 byte, not newline\n"
msgstr ""
"  -D, --all-repeated[=delimit-method] вивести всі рядки, що повторюються\n"
"                        delimit-method={none(типово),prepend,separate)}\n"
"                        Розділення виконується за порожніми рядками.\n"
"  -f, --skip-fields=Н   не порівнювати перші Н полів\n"
"  -i, --ignore-case     ігнорувати при порівнянні регістр\n"
"  -s, --skip-chars=Н    не порівнювати перші Н знаків\n"
"  -u, --unique          виводити лише рядки, що не повторюються\n"
"  -z, --zero-terminated кінцеві рядки з 0 байта, без символу нового рядка\n"

#: src/uniq.c:161
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=Н   порівнювати перші Н знаків рядків\n"

#: src/uniq.c:166
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Полем вважається послідовність пробільних знаків, за якою\n"
"йдуть не пробільні знаки. Спочатку пропускаються поля, потім символи.\n"

#: src/uniq.c:171
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
"Also, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"Зауваження: uniq не зможе визначити повторених рядків, якщо ці рядки не є\n"
"сусідніми. Вам варто спочатку впорядкувати вхідні дані, або скористатися\n"
"«sort -u» замість uniq.\n"
"Крім того, під час порівняння використовуються правила, встановлені змінною\n"
"LC_COLLATE.\n"

#: src/uniq.c:358
#, c-format
msgid "too many repeated lines"
msgstr "надто багато рядків, що повторюються"

#: src/uniq.c:521
msgid "invalid number of fields to skip"
msgstr "неправильна кількість полів, що пропускаються"

#: src/uniq.c:530
msgid "invalid number of bytes to skip"
msgstr "неправильна кількість байт, що пропускаються"

#: src/uniq.c:539
msgid "invalid number of bytes to compare"
msgstr "неправильна кількість байт, що порівнюються"

#: src/uniq.c:558
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "вивід усіх рядків, що повторюються та числа повторів не має сенсу"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ\n"
"       або:    %s КЛЮЧ\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Викликає функцію unlink для вилучення вказаного ФАЙЛА.\n"
"\n"

#: src/unlink.c:86
#, c-format
msgid "cannot unlink %s"
msgstr "не вдалося вилучити посилання %s"

#: src/uptime.c:125
#, c-format
msgid "couldn't get boot time"
msgstr "не вдалося дізнатись час початкового завантаження"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:136
msgid " %H:%M%P  "
msgstr " %H:%M  "

#: src/uptime.c:138
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:140
#, c-format
msgid "up ???? days ??:??,  "
msgstr "???? днів ??:??,  "

#: src/uptime.c:144
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "%ld день %2d:%02d,  "
msgstr[1] "%ld дні %2d:%02d,  "
msgstr[2] "%ld днів %2d:%02d,  "

#: src/uptime.c:149
#, c-format
msgid "up  %2d:%02d,  "
msgstr "%2d:%02d,  "

#: src/uptime.c:151
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu користувач"
msgstr[1] "%lu користувачі"
msgstr[2] "%lu користувачів"

#: src/uptime.c:161
#, c-format
msgid ",  load average: %.2f"
msgstr ", середня завантаженість: %.2f"

#: src/uptime.c:197
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Виводить поточний час, час безперервної роботи системи, кількість\n"
"користувачів у системі та середнє число завдань у черзі запуску за\n"
"останні 1, 5 та 15 хвилин."

#: src/uptime.c:206
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Процеси у\n"
"стані неперервного сну також впливають на середнє завантаження.\n"

#: src/uptime.c:210
#, c-format
msgid "\n"
msgstr "\n"

#: src/uptime.c:212
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Якщо ФАЙЛ не вказано, використовується %s.  Часто замість ФАЙЛ\n"
"вказують %s.\n"
"\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Виводить список підключених користувачів відповідно до ФАЙЛА.\n"
"Якщо ФАЙЛ не вказаний, використовується %s.  Часто у якості ФАЙЛА\n"
"вказують %s.\n"
"\n"

#: src/wc.c:117
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.  A word is a non-zero-length sequence of characters\n"
"delimited by white space.\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"Виводить кількість розривів рядків, слів та байт для кожного ФАЙЛа\n"
"та сумарний рядок. Якщо не було вказано ФАЙЛ, або вказано ФАЙЛ «-»,\n"
"читає дані зі стандартного джерел введення. Словом вважається\n"
"ненульова послідовність символів, обмежених пробілами.\n"
"За допомогою вказаних нижче параметрів можна вибрати дані, які\n"
"буде виведено. Порядок буде завжди таким: розриви рядків,\n"
"слова, символи, байти, максимальна довжина рядка.\n"
"  -c, --bytes            вивести кількість байт\n"
"  -m, --chars            вивести кількість знаків\n"
"  -l, --lines            вивести кількість розривів рядків\n"

#: src/wc.c:128
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=F    читати вхідні дані з файлів, вказаних\n"
"                           назвами зі списку, розділеного символами\n"
"                           NUL у файлі F. Якщо F дорівнює «-», назви\n"
"                           буде прочитано зі стандартного джерела даних\n"
"  -L, --max-line-length  вивести довжину найбільшого рядка\n"
"  -w, --words            вивести кількість слів\n"

#: src/who.c:210
msgid " old "
msgstr "давно"

#: src/who.c:440
msgid "system boot"
msgstr "завантаження системи"

#: src/who.c:447 src/who.c:449
msgid "id="
msgstr "id="

#: src/who.c:462 src/who.c:467
msgid "term="
msgstr "термінал="

#: src/who.c:464 src/who.c:468
msgid "exit="
msgstr "вихід="

#: src/who.c:485
msgid "LOGIN"
msgstr "ВХІД"

#: src/who.c:505
msgid "clock change"
msgstr "зміна часу"

#: src/who.c:517 src/who.c:518
msgid "run-level"
msgstr "рівень виконання"

#: src/who.c:521 src/who.c:522
msgid "last="
msgstr "попередній="

#: src/who.c:553
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"число користувачів=%lu\n"

#: src/who.c:559
msgid "NAME"
msgstr "НАЗВА"

#: src/who.c:559
msgid "LINE"
msgstr "ЛІНІЯ"

#: src/who.c:559
msgid "TIME"
msgstr "Час"

#: src/who.c:559
msgid "IDLE"
msgstr "НЕАКТИВНИЙ"

#: src/who.c:560
msgid "PID"
msgstr "PID"

#: src/who.c:560
msgid "COMMENT"
msgstr "КОМЕНТАР"

#: src/who.c:560
msgid "EXIT"
msgstr "ВИХІД"

#: src/who.c:640
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Використання: %s [КЛЮЧ]... [ ФАЙЛ | АРГ1 АРГ2]\n"

#: src/who.c:641
msgid "Print information about users who are currently logged in.\n"
msgstr "Вивести дані щодо користувачів, які працюють у системі.\n"

#: src/who.c:644
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         еквівалент -b -d --login -p -r -t -T -u\n"
"  -b, --boot        час останнього звантаження системи\n"
"  -d, --dead        виводити мертві процеси\n"
"  -H, --heading     виводити рядок з заголовками стовпчиків\n"

#: src/who.c:651
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       виводити процеси входу у систему\n"

#: src/who.c:654
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      намагатись канонізувати назви вузлів через DNS\n"
"  -m                лише назва вузлі та користувач, пов'язані з\n"
"                    стандартним вводом\n"
"  -p, --process     виводити активні процеси, які породжені init\n"

#: src/who.c:659
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       всі назви та кількість підключених користувачів\n"
"  -r, --runlevel    виводити поточний рівень виконання\n"
"  -s, --short       виводити лише назву, лінію та час (приймається типово)\n"
"  -t, --time        виводити останню зміна системного часу\n"

#: src/who.c:665
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    додавати статус отримання повідомлень як  +, - або ?\n"
"  -u, --users       перерахувати підключених користувачів\n"
"      --message     еквівалент -T\n"
"      --writable    еквівалент -T\n"

#: src/who.c:673
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ не вказаний, використовується %s. Часто як ФАЙЛ вказують %s.\n"
"Якщо вказані АРГ1 та АРГ2, вважається використання -m: наприклад 'am i'\n"
"та 'mom likes'.\n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Вивести ім'я користувача, що відповідає поточному ефективному id\n"
"користувача.  Аналогічно виклику id -un.\n"
"\n"

#: src/whoami.c:91
#, c-format
msgid "%s: cannot find name for user ID %lu\n"
msgstr "%s: не вдалося визначити ім'я користувача для ID %lu\n"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [РЯДОК]...\n"
"       або:    %s КЛЮЧ\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"Безперервно виводити вказаний РЯДОК (РЯДКИ) або, якщо РЯДОК не вказано, "
"'y'.\n"
"\n"

#~ msgid "using single-precision arithmetic"
#~ msgstr "використання арифметики з фіксованою точністю"

#~ msgid "using arbitrary-precision arithmetic"
#~ msgstr "використання арифметики з довільною точністю"

#~ msgid ""
#~ "simple_strtod_human:\n"
#~ "  input string: '%s'\n"
#~ "  locale decimal-point: '%s'\n"
#~ msgstr ""
#~ "simple_strtod_human:\n"
#~ "  рядок вхідних даних: «%s»\n"
#~ "  символ відокремлення дробової частини локалі: «%s»\n"

#~ msgid ""
#~ "  parsed numeric value: %Lf\n"
#~ "  input precision = %d\n"
#~ msgstr ""
#~ "  оброблене числове значення: %Lf\n"
#~ "  точність вхідних даних = %d\n"

#~ msgid "  Auto-scaling, found 'i', switching to base %d\n"
#~ msgstr "  Автомасштабування, виявлено «i», перемикаємося на основу %d\n"

#~ msgid "  suffix power=%d^%d = %Lf\n"
#~ msgstr "  степінь у суфіксі=%d^%d = %Lf\n"

#~ msgid "  returning value: %Lf (%LG)\n"
#~ msgstr "  повертаємо значення %Lf (%LG)\n"

#~ msgid "double_to_human:\n"
#~ msgstr "double_to_human:\n"

#~ msgid "  no scaling, returning (grouped) value: %'.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення (з групуванням) %'.*Lf\n"

#~ msgid "  no scaling, returning value: %.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення %.*Lf\n"

#~ msgid "  scaled value to %Lf * %0.f ^ %d\n"
#~ msgstr "  масштабоване значення до %Lf * %0.f ^ %d\n"

#~ msgid "  after rounding, value=%Lf * %0.f ^ %d\n"
#~ msgstr "  після округлення, значення=%Lf * %0.f ^ %d\n"

#~ msgid "  returning value: '%s'\n"
#~ msgstr "  повернутаємо значення «%s»\n"

#~ msgid "Usage: %s [OPTIONS] [NUMBER]\n"
#~ msgstr "Використання: %s [ПАРАМЕТРИ] [ЧИСЛО]\n"

#~ msgid ""
#~ "  --from=UNIT     auto-scale input numbers to UNITs. Default is 'none'.\n"
#~ "                  See UNIT below.\n"
#~ "  --from-unit=N   specify the input unit size (instead of the default "
#~ "1).\n"
#~ "  --to=UNIT       auto-scale output numbers to UNITs.\n"
#~ "                  See UNIT below.\n"
#~ "  --to-unit=N     the output unit size (instead of the default 1).\n"
#~ "  --round=METHOD  the rounding method to use when scaling. METHOD can "
#~ "be:\n"
#~ "                  up, down, from-zero (default), towards-zero, nearest\n"
#~ "  --suffix=SUFFIX add SUFFIX to output numbers, and accept optional "
#~ "SUFFIX\n"
#~ "                  in input numbers.\n"
#~ "  --padding=N     pad the output to N characters.\n"
#~ "                  Positive N will right-aligned. Negative N will left-"
#~ "align.\n"
#~ "                  Note: if the output is wider than N, padding is "
#~ "ignored.\n"
#~ "                  Default is to automatically pad if whitespace is "
#~ "found.\n"
#~ "  --grouping      group digits together (e.g. 1,000,000).\n"
#~ "                  Uses the locale-defined grouping (i.e. have no effect\n"
#~ "                  in C/POSIX locales).\n"
#~ "  --header[=N]    print (without converting) the first N header lines.\n"
#~ "                  N defaults to 1 if not specified.\n"
#~ "  --field N       replace the number in input field N (default is 1)\n"
#~ "  -d, --delimiter=X  use X instead of whitespace for field delimiter\n"
#~ "  --format=FORMAT use printf style floating-point FORMAT.\n"
#~ "                  See FORMAT below for details.\n"
#~ "  --invalid=MODE  failure mode for invalid numbers: MODE can be:\n"
#~ "                  abort (the default), fail, warn, ignore.\n"
#~ "  --debug         print warnings about invalid input.\n"
#~ "  \n"
#~ msgstr ""
#~ "  --from=ОДИНИЦЯ  автоматично масштабувати вхідні числа за ОДИНИЦЕЮ. "
#~ "Типове\n"
#~ "                  значення -- 'none'. Опис ОДИНИЦІ наведено нижче.\n"
#~ "  --from-unit=N   вказати розмір вхідної одиниці (типовим є 1).\n"
#~ "  --to=ОДИНИЦЯ    автоматично масштабувати виведені числа за ОДИНИЦЕЮ. "
#~ "Опис\n"
#~ "                  ОДИНИЦІ наведено нижче.\n"
#~ "  --to-unit=N     розмір одиниці виведення (замість типового значення "
#~ "1).\n"
#~ "  --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
#~ "                  up (до більшого), down (до меншого), from-zero (до "
#~ "дальшого\n"
#~ "                  до нуля, типовий), towards-zero (до ближчого до "
#~ "нуля),                   nearest (до найближчого цілого\n"
#~ "  --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
#~ "СУФІКС\n"
#~ "                  у вхідних даних.\n"
#~ "  --padding=N     доповнити виведені дані до N символів.\n"
#~ "                  Використання додатного N призведе до вирівнювання "
#~ "праворуч\n"
#~ "                  Від’ємні N вирівнюватимуть дані ліворуч.\n"
#~ "                  Зауваження: якщо виведені дані будуть довшими за N,\n"
#~ "                  доповнення не відбуватиметься. Типовим є автоматичне "
#~ "доповнення,\n"
#~ "                  якщо буде виявлено пробіли.\n"
#~ "  --grouping      групувати цифри (наприклад, 1.000.000).\n"
#~ "                  Використовується визначене локаллю групування (тобто не "
#~ "впливає\n"
#~ "                  на локалі C/POSIX).\n"
#~ "  --header[=N]    вивести (без перетворення) перші N рядків заголовка.\n"
#~ "                  Якщо не вказано, типовим значенням N є 1.\n"
#~ "  --field N       замінити число у вхідному полі N (типовим є 1)\n"
#~ "  -d, --delimiter=X  використовувати X замість пробілу для відокремлення "
#~ "полів\n"
#~ "  --format=ФОРМАТ використовувати форматування у стилі printf.\n"
#~ "                  Опис ФОРМАТу наведено нижче.\n"
#~ "  --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
#~ "                  abort (перервати обробку, типовий), fail (обробити з "
#~ "помилками),\n"
#~ "                  warn (попередити), ignore (ігнорувати).\n"
#~ "  --debug         виводити попередження щодо некоректних вхідних даних.\n"
#~ "  \n"

#~ msgid ""
#~ "\n"
#~ "UNIT options:\n"
#~ "  none       No auto-scaling is done. Suffixes will trigger an error.\n"
#~ "  auto       Accept optional single-letter/two-letter suffix:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Accept optional single letter suffix:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Accept optional single letter suffix:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Accept optional two-letter suffix:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Варіанти ОДИНИЦІ:\n"
#~ "  none       без автоматичного масштабування. Використання суфіксів\n"
#~ "             призводитиме до повідомлення про помилку.\n"
#~ "  auto       Використовувати додатковий одно- або дволітерний суфікс:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Використовувати додатковий дволітерний суфікс:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"

#~ msgid ""
#~ "format String:\n"
#~ "  input: %s\n"
#~ "  grouping: %s\n"
#~ "  padding width: %ld\n"
#~ "  alignment: %s\n"
#~ "  prefix: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "Рядок форматування:\n"
#~ "  вхідні дані: %s\n"
#~ "  групування: %s\n"
#~ "  розмір доповнення: %ld\n"
#~ "  вирівнювання: %s\n"
#~ "  префікс: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid ""
#~ "formatting output:\n"
#~ "  value: %Lf\n"
#~ "  humanized: '%s'\n"
#~ msgstr ""
#~ "форматуємо виведення:\n"
#~ "  значення: %Lf\n"
#~ "  у зручному форматі: «%s»\n"

#~ msgid "  After padding: '%s'\n"
#~ msgstr "  Після доповнення: «%s»\n"

#~ msgid "trimming suffix '%s'\n"
#~ msgstr "обрізаємо суфікс «%s»\n"

#~ msgid "no valid suffix found\n"
#~ msgstr "не знайдено коректного суфікса\n"

#~ msgid "setting Auto-Padding to %ld characters\n"
#~ msgstr "встановлюємо автоматичне доповнення до %ld символів\n"

#~ msgid ""
#~ "extracting Fields:\n"
#~ "  input: '%s'\n"
#~ "  field: %d\n"
#~ msgstr ""
#~ "видобуваємо поля:\n"
#~ "  вхідні дані: «%s»\n"
#~ "  поле: %d\n"

#~ msgid ""
#~ "  TOO FEW FIELDS!\n"
#~ "  prefix: '%s'\n"
#~ msgstr ""
#~ "  НАДТО МАЛО ПОЛІВ!\n"
#~ "  префікс: «%s»\n"

#~ msgid ""
#~ "  prefix: '%s'\n"
#~ "  number: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "  префікс: «%s»\n"
#~ "  номер: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid "reading %s"
#~ msgstr "читання %s"

#~ msgid "writing %s"
#~ msgstr "запис %s"

#~ msgid "closing %s"
#~ msgstr "закриття %s"

#~ msgid "accessing %s"
#~ msgstr "звернення до %s"

#~ msgid "opening %s"
#~ msgstr "відкриття %s"

#~ msgid ""
#~ "  -x, --one-file-system    skip directories on different file systems\n"
#~ "  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
#~ "      --exclude=PATTERN    exclude files that match PATTERN\n"
#~ "  -d, --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system   пропускати каталоги на інших файлових системах\n"
#~ "  -X, --exclude-from=ФАЙЛ виключати файли, що збігаються з якимось\n"
#~ "                          шаблоном з ФАЙЛА\n"
#~ "      --exclude=ШАБЛОН    виключати файли, що збігаються з ШАБЛОНОМ\n"
#~ "      --max-depth=N       виводити зведення про каталог (або файл, з --"
#~ "all),\n"
#~ "                          лише якщо він на N або менше рівнів нижче,\n"
#~ "                          ніж аргумент командного рядка; --max-depth=0\n"
#~ "                          еквівалентно до --summarize\n"

#~ msgid ""
#~ "  none, off       never make backups (even if --backup is given)\n"
#~ "  numbered, t     make numbered backups\n"
#~ "  existing, nil   numbered if numbered backups exist, simple otherwise\n"
#~ "  simple, never   always make simple backups\n"
#~ "\n"
#~ msgstr ""
#~ "  none, off       ніколи не створювати резервних копій (навіть якщо\n"
#~ "                  вказаний ключ --backup)\n"
#~ "  numbered, t     створювати нумеровані копії\n"
#~ "  existing, nil   якщо існують нумеровані копії, то створювати\n"
#~ "                  нумеровані інакше створювати прості\n"
#~ "  simple. never   завжди створювати прості копії\n"
#~ "\n"

#~ msgid ""
#~ "WARNING: --page-increment is deprecated; use --line-increment instead"
#~ msgstr ""
#~ "ПОПЕРЕДЖЕННЯ: --page-increment вважаєте застарілим; вам варто "
#~ "скористатися --line-increment"

#~ msgid "All arguments to long options are mandatory for short options.\n"
#~ msgstr "Всі аргументи для довгих ключів є обов'язковими для коротких.\n"

#~ msgid ""
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
#~ "suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "Adding a z suffix to any type displays printable characters at the end of "
#~ "each\n"
#~ "output line.\n"
#~ msgstr ""
#~ "\n"
#~ "ОСНОВА може бути d (десятковою), o (вісімковою), x (шістнадцятковою) або\n"
#~ "n (не виводити зсув).  Н з префіксом 0x або 0X сприймається як\n"
#~ "шістнадцяткове, з суфіксом b множиться на 512, з суфіксом kB — 1000, K — "
#~ "1024,\n"
#~ "MB — 1000*1000, M — 1024*1024, GB — 1000*1000*1000, G — 1024*1024*1024, "
#~ "те саме\n"
#~ "для T, P, E, Z, Y. Якщо додати до будь-якого формату суфікс z,\n"
#~ "наприкінці кожного рядка будуть виводитись друковані символи.\n"

#~ msgid ""
#~ "Option --string without a number implies 3; option --width without a "
#~ "number\n"
#~ "implies 32.  By default, od uses -A o -t oS -w16.\n"
#~ msgstr ""
#~ "Параметр --string без аргументу означає 3, --width — 32.\n"
#~ "Типово od використовуються ключі -A o -t oS -w16.\n"

#~ msgid "Usage: %s [OPTION]... FILE\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#~ msgid "Password:"
#~ msgstr "Пароль:"

#~ msgid "getpass: cannot open /dev/tty"
#~ msgstr "getpass: не вдалося відкрити /dev/tty"

#~ msgid "cannot set groups"
#~ msgstr "не вдалося встановити групи"

#~ msgid "cannot set group id"
#~ msgstr "не вдалося встановити груповий id"

#~ msgid "cannot set user id"
#~ msgstr "не вдалося встановити id користувача"

#~ msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [-] [КОРИСТУВАЧ [АРГ]...]\n"

#~ msgid ""
#~ "Change the effective user id and group id to that of USER.\n"
#~ "\n"
#~ "  -, -l, --login               make the shell a login shell\n"
#~ "  -c, --command=COMMAND        pass a single COMMAND to the shell with -"
#~ "c\n"
#~ "  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
#~ "  -m, --preserve-environment   do not reset environment variables\n"
#~ "  -p                           same as -m\n"
#~ "  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
#~ msgstr ""
#~ "Встановлює ефективні id користувача та групи як у КОРИСТУВАЧА.\n"
#~ "\n"
#~ "  -, -l, --login               використовувати оболонку як оболонку "
#~ "входу\n"
#~ "  -c, --commmand=КОМАНДА       передати оболонці КОМАНДУ за допомогою -c\n"
#~ "  -f, --fast                   передати оболонці -f (для csh або tcsh)\n"
#~ "  -m, --preserve-environment   не перевстановлювати змінні оточення\n"
#~ "  -p                           синонім для -m\n"
#~ "  -s, --shell=ОБОЛОНКА         запустити ОБОЛОНКУ, якщо дозволяє /etc/"
#~ "shells\n"

#~ msgid ""
#~ "\n"
#~ "A mere - implies -l.   If USER not given, assume root.\n"
#~ msgstr ""
#~ "\n"
#~ "Просто знак мінус означає -l.  Якщо КОРИСТУВАЧ не вказаний,\n"
#~ "вважається root.\n"

#~ msgid "user %s does not exist"
#~ msgstr "користувач %s не існує"

#~ msgid "incorrect password"
#~ msgstr "неправильний пароль"

#~ msgid "using restricted shell %s"
#~ msgstr "використовується обмежена оболонка %s"

#~ msgid "warning: cannot change directory to %s"
#~ msgstr "попередження: не вдалося змінити каталог на %s"

#~ msgid ""
#~ "\n"
#~ "Examples:\n"
#~ "  %s /usr/bin/sort       Output \"sort\".\n"
#~ "  %s include/stdio.h .h  Output \"stdio\".\n"
#~ msgstr ""
#~ "\n"
#~ "Приклади:\n"
#~ "  %s /usr/bin/sort       Виводить \"sort\".\n"
#~ "  %s include/stdio.h .h  Виводить \"stdio\".\n"

#~ msgid ""
#~ "Usage: %s NAME\n"
#~ "  or:  %s OPTION\n"
#~ msgstr ""
#~ "Використання: %s НАЗВА\n"
#~ "       або:    %s КЛЮЧ\n"

#~ msgid "--relative-base requires --relative-to"
#~ msgstr "Для --relative-base слід вказати --relative-to"

#~ msgid ""
#~ "Change the group of each FILE to GROUP.\n"
#~ "With --reference, change the group of each FILE to that of RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює групу власника кожного файла ФАЙЛ на ГРУПА.\n"
#~ "З ключем  --reference, змінює групу кожного ФАЙЛУ на групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --changes          як і verbose, але виводити лише при змінах\n"
#~ "      --dereference      впливає на ціль кожного символічного посилання\n"
#~ "                         (типово), а не на саме символічне посилання\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's group rather than specifying a\n"
#~ "                         GROUP value\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛУ використовувати групу ЗФАЙЛУ замість явного\n"
#~ "                         вказування ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "Change the mode of each FILE to MODE.\n"
#~ "\n"
#~ "  -c, --changes           like verbose but report only when a change is "
#~ "made\n"
#~ msgstr ""
#~ "Змінює режим кожного ФАЙЛУ на вказаний РЕЖИМ.\n"
#~ "\n"
#~ "  -c, --changes           як verbose, але повідомляти, лише якщо справді\n"
#~ "                          внесена зміна\n"

#~ msgid ""
#~ "      --no-preserve-root  do not treat `/' specially (the default)\n"
#~ "      --preserve-root     fail to operate recursively on `/'\n"
#~ msgstr ""
#~ "      --no-preserve-root  не обробляти `/' особливим чином (типово)\n"
#~ "      --preserve-root     не обробляти рекурсивно `/'\n"

#~ msgid ""
#~ "  -f, --silent, --quiet   suppress most error messages\n"
#~ "  -v, --verbose           output a diagnostic for every file processed\n"
#~ "      --reference=RFILE   use RFILE's mode instead of MODE values\n"
#~ "  -R, --recursive         change files and directories recursively\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet   не виводити більшість повідомлень про помилки\n"
#~ "  -v, --verbose           виводити діагностичні повідомлення для усіх "
#~ "файлів\n"
#~ "      --reference=ЗФАЙЛ   режим ЗФАЙЛУ замість явного вказування РЕЖИМУ\n"
#~ "  -R, --recursive         рекурсивно обробляти файли та каталоги\n"

#~ msgid ""
#~ "Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
#~ "With --reference, change the owner and group of each FILE to those of "
#~ "RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює власника та/або групу кожного ФАЙЛУ на ВЛАСНИКА та/або ГРУПУ.\n"
#~ "З ключем --reference, змінює власника та групу кожного ФАЙЛУ на власника "
#~ "та\n"
#~ "групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --change           те саме що й --verbose, але повідомляє лише "
#~ "коли\n"
#~ "                         були внесені зміни\n"
#~ "      --dereference      змінювати файл, на який вказує символьне\n"
#~ "                         посилання, а не саме посилання (типово)\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's owner and group rather than\n"
#~ "                         specifying OWNER:GROUP values\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛУ "
#~ "замість\n"
#~ "                         явного вказування ВЛАСНИКА:ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "Display the current time in the given FORMAT, or set the system date.\n"
#~ "\n"
#~ "  -d, --date=STRING         display time described by STRING, not `now'\n"
#~ "  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
#~ msgstr ""
#~ "Виводить поточний час у заданому ФОРМАТІ, або встановлює системний час.\n"
#~ "\n"
#~ "  -d,  --date=РЯДОК         показати не поточний час, а час, що "
#~ "описується\n"
#~ "                            вказаним РЯДКОМ\n"
#~ "  -f,  --file=ФАЙЛ          відповідає застосуванню --date для кожного\n"
#~ "                            рядка ФАЙЛУ\n"

#~ msgid ""
#~ "\n"
#~ "SIZE may be (or may be an integer optionally followed by) one of "
#~ "following:\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, "
#~ "Y.\n"
#~ msgstr ""
#~ "\n"
#~ "РОЗМІР може бути таким (або це може бути ціле число, за яким\n"
#~ "може слідувати одне з переліченого):\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
