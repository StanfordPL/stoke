/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ../../../../src/parser/smt1/Smt1.g
 *     -                            On : 2017-07-10 10:01:28
 *     -                for the parser : Smt1ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/**
 ** This file is part of the CVC4 project.
 ** Copyright (c) 2009-2016 by the authors listed in the file AUTHORS
 ** in the top-level source directory) and their institutional affiliations.
 ** All rights reserved.  See the file COPYING in the top-level source
 ** directory for licensing information.
 **/

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "Smt1Parser.h"


#include <vector>

#include "base/output.h"
#include "base/ptr_closer.h"
#include "expr/expr.h"
#include "expr/kind.h"
#include "expr/type.h"
#include "parser/antlr_input.h"
#include "parser/parser.h"
#include "parser/smt1/smt1.h"
#include "util/integer.h"
#include "util/rational.h"

using namespace CVC4;
using namespace CVC4::parser;

/* These need to be macros so they can refer to the PARSER macro, which will be defined
 * by ANTLR *after* this section. (If they were functions, PARSER would be undefined.) */
#undef PARSER_STATE
#define PARSER_STATE ((Smt1*)PARSER->super)
#undef EXPR_MANAGER
#define EXPR_MANAGER PARSER_STATE->getExprManager()
#undef MK_EXPR
#define MK_EXPR EXPR_MANAGER->mkExpr
#undef MK_CONST
#define MK_CONST EXPR_MANAGER->mkConst


/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSmt1Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSmt1Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSmt1Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSmt1Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   Smt1ParserTokenNames[102+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ALPHA",
        (pANTLR3_UINT8) "AMPERSAND_TOK",
        (pANTLR3_UINT8) "AND_TOK",
        (pANTLR3_UINT8) "ASSUMPTION_TOK",
        (pANTLR3_UINT8) "ATTR_IDENTIFIER",
        (pANTLR3_UINT8) "AT_TOK",
        (pANTLR3_UINT8) "BENCHMARK_TOK",
        (pANTLR3_UINT8) "BITVECTOR1_BV_CONST",
        (pANTLR3_UINT8) "BITVECTOR_BV_CONST",
        (pANTLR3_UINT8) "BITVECTOR_TOK",
        (pANTLR3_UINT8) "BVADD_TOK",
        (pANTLR3_UINT8) "BVAND_TOK",
        (pANTLR3_UINT8) "BVASHR_TOK",
        (pANTLR3_UINT8) "BVCOMP_TOK",
        (pANTLR3_UINT8) "BVLSHR_TOK",
        (pANTLR3_UINT8) "BVMUL_TOK",
        (pANTLR3_UINT8) "BVNAND_TOK",
        (pANTLR3_UINT8) "BVNEG_TOK",
        (pANTLR3_UINT8) "BVNOR_TOK",
        (pANTLR3_UINT8) "BVNOT_TOK",
        (pANTLR3_UINT8) "BVOR_TOK",
        (pANTLR3_UINT8) "BVSDIV_TOK",
        (pANTLR3_UINT8) "BVSGE_TOK",
        (pANTLR3_UINT8) "BVSGT_TOK",
        (pANTLR3_UINT8) "BVSHL_TOK",
        (pANTLR3_UINT8) "BVSLE_TOK",
        (pANTLR3_UINT8) "BVSLT_TOK",
        (pANTLR3_UINT8) "BVSMOD_TOK",
        (pANTLR3_UINT8) "BVSREM_TOK",
        (pANTLR3_UINT8) "BVSUB_TOK",
        (pANTLR3_UINT8) "BVUDIV_TOK",
        (pANTLR3_UINT8) "BVUGE_TOK",
        (pANTLR3_UINT8) "BVUGT_TOK",
        (pANTLR3_UINT8) "BVULE_TOK",
        (pANTLR3_UINT8) "BVULT_TOK",
        (pANTLR3_UINT8) "BVUREM_TOK",
        (pANTLR3_UINT8) "BVXNOR_TOK",
        (pANTLR3_UINT8) "BVXOR_TOK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONCAT_TOK",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DISTINCT_TOK",
        (pANTLR3_UINT8) "DIV_TOK",
        (pANTLR3_UINT8) "EQUAL_TOK",
        (pANTLR3_UINT8) "ESCAPE",
        (pANTLR3_UINT8) "EXISTS_TOK",
        (pANTLR3_UINT8) "EXTRACT_TOK",
        (pANTLR3_UINT8) "EXTRAFUNS_TOK",
        (pANTLR3_UINT8) "EXTRAPREDS_TOK",
        (pANTLR3_UINT8) "EXTRASORTS_TOK",
        (pANTLR3_UINT8) "FALSE_TOK",
        (pANTLR3_UINT8) "FLET_IDENTIFIER",
        (pANTLR3_UINT8) "FLET_TOK",
        (pANTLR3_UINT8) "FORALL_TOK",
        (pANTLR3_UINT8) "FORMULA_TOK",
        (pANTLR3_UINT8) "GREATER_THAN_TOK",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IFF_TOK",
        (pANTLR3_UINT8) "IMPLIES_TOK",
        (pANTLR3_UINT8) "ITE_TOK",
        (pANTLR3_UINT8) "LESS_THAN_TOK",
        (pANTLR3_UINT8) "LET_IDENTIFIER",
        (pANTLR3_UINT8) "LET_TOK",
        (pANTLR3_UINT8) "LOGIC_TOK",
        (pANTLR3_UINT8) "LPAREN_TOK",
        (pANTLR3_UINT8) "MINUS_TOK",
        (pANTLR3_UINT8) "NOTES_TOK",
        (pANTLR3_UINT8) "NOT_TOK",
        (pANTLR3_UINT8) "NUMERAL_TOK",
        (pANTLR3_UINT8) "OR_TOK",
        (pANTLR3_UINT8) "PATTERN_ANNOTATION_BEGIN",
        (pANTLR3_UINT8) "PERCENT_TOK",
        (pANTLR3_UINT8) "PIPE_TOK",
        (pANTLR3_UINT8) "PLUS_TOK",
        (pANTLR3_UINT8) "POUND_TOK",
        (pANTLR3_UINT8) "RATIONAL_TOK",
        (pANTLR3_UINT8) "REPEAT_TOK",
        (pANTLR3_UINT8) "ROTATE_LEFT_TOK",
        (pANTLR3_UINT8) "ROTATE_RIGHT_TOK",
        (pANTLR3_UINT8) "RPAREN_TOK",
        (pANTLR3_UINT8) "SAT_TOK",
        (pANTLR3_UINT8) "SELECT_TOK",
        (pANTLR3_UINT8) "SIGN_EXTEND_TOK",
        (pANTLR3_UINT8) "STAR_TOK",
        (pANTLR3_UINT8) "STATUS_TOK",
        (pANTLR3_UINT8) "STORE_TOK",
        (pANTLR3_UINT8) "STRING_LITERAL",
        (pANTLR3_UINT8) "THEORY_TOK",
        (pANTLR3_UINT8) "TILDE_TOK",
        (pANTLR3_UINT8) "TRUE_TOK",
        (pANTLR3_UINT8) "UNKNOWN_TOK",
        (pANTLR3_UINT8) "UNSAT_TOK",
        (pANTLR3_UINT8) "USER_VALUE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "XOR_TOK",
        (pANTLR3_UINT8) "ZERO_EXTEND_TOK",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':pat'",
        (pANTLR3_UINT8) "'Array['",
        (pANTLR3_UINT8) "'['",
        (pANTLR3_UINT8) "']'",
        (pANTLR3_UINT8) "'}'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 CVC4::parser::smt1::myExpr
	parseExpr    (pSmt1Parser ctx);
static 
 CVC4::Command*
	parseCommand    (pSmt1Parser ctx);
static 
 void
	benchmark    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	benchAttributes    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd);
static 
 void
	benchAttribute    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command);
static 
 void
	annotatedFormula    (pSmt1Parser ctx, CVC4::Expr& expr);
static 
 void
	annotatedFormulas    (pSmt1Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr);
static 
 void
	builtinOp    (pSmt1Parser ctx, CVC4::Kind& kind);
static 
 void
	parameterizedOperator    (pSmt1Parser ctx, CVC4::Expr& op);
static 
 void
	bitVectorOperator    (pSmt1Parser ctx, CVC4::Expr& op);
static 
 void
	predicateName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	functionName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 void
	functionSymbol    (pSmt1Parser ctx, CVC4::Expr& fun);
static 
 void
	attribute    (pSmt1Parser ctx, std::string& s);
static 
 void
	functionDeclaration    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command);
static 
 void
	predicateDeclaration    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command);
static 
 void
	sortDeclaration    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command);
static 
 void
	sortList    (pSmt1Parser ctx, std::vector<CVC4::Type>& sorts);
static 
 void
	sortName    (pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check);
static 
 CVC4::parser::smt1::myType
	sortSymbol    (pSmt1Parser ctx);
static 
 void
	status    (pSmt1Parser ctx, CVC4::BenchmarkStatus& status);
static 
 void
	annotation    (pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command);
static 
 void
	termAnnotation    (pSmt1Parser ctx, CVC4::Expr& expr);
static 
 void
	identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type);
static 
 void
	let_identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check);
static 
 void
	flet_identifier    (pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check);
static 
 void
	userValue    (pSmt1Parser ctx, std::string& s);
static void	Smt1ParserFree(pSmt1Parser ctx);
static void     Smt1ParserReset (pSmt1Parser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "../../../../src/parser/smt1/Smt1.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new Smt1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt1Parser
Smt1ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return Smt1ParserNewSSD(instream, NULL);
}

/** \brief Create a new Smt1Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSmt1Parser
Smt1ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSmt1Parser ctx;	    /* Context structure we will build and return   */

    ctx	= (pSmt1Parser) ANTLR3_CALLOC(1, sizeof(Smt1Parser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in Smt1Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our Smt1Parser interface
     */
    ctx->parseExpr	= parseExpr;
    ctx->parseCommand	= parseCommand;
    ctx->benchmark	= benchmark;
    ctx->benchAttributes	= benchAttributes;
    ctx->benchAttribute	= benchAttribute;
    ctx->annotatedFormula	= annotatedFormula;
    ctx->annotatedFormulas	= annotatedFormulas;
    ctx->builtinOp	= builtinOp;
    ctx->parameterizedOperator	= parameterizedOperator;
    ctx->bitVectorOperator	= bitVectorOperator;
    ctx->predicateName	= predicateName;
    ctx->functionName	= functionName;
    ctx->functionSymbol	= functionSymbol;
    ctx->attribute	= attribute;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->predicateDeclaration	= predicateDeclaration;
    ctx->sortDeclaration	= sortDeclaration;
    ctx->sortList	= sortList;
    ctx->sortName	= sortName;
    ctx->sortSymbol	= sortSymbol;
    ctx->status	= status;
    ctx->annotation	= annotation;
    ctx->termAnnotation	= termAnnotation;
    ctx->identifier	= identifier;
    ctx->let_identifier	= let_identifier;
    ctx->flet_identifier	= flet_identifier;
    ctx->userValue	= userValue;
    ctx->free			= Smt1ParserFree;
    ctx->reset			= Smt1ParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = Smt1ParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
Smt1ParserReset (pSmt1Parser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 Smt1ParserFree(pSmt1Parser ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return Smt1ParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_parseExpr105  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_parseExpr105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_parseExpr105	= { FOLLOW_annotatedFormula_in_parseExpr105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_parseExpr112  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_parseExpr112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_parseExpr112	= { FOLLOW_EOF_in_parseExpr112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchmark_in_parseCommand145  */
static	ANTLR3_BITWORD FOLLOW_benchmark_in_parseCommand145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_benchmark_in_parseCommand145	= { FOLLOW_benchmark_in_parseCommand145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_parseCommand152  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_parseCommand152_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_parseCommand152	= { FOLLOW_LPAREN_TOK_in_parseCommand152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_parseCommand156  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_parseCommand156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_parseCommand156	= { FOLLOW_IDENTIFIER_in_parseCommand156_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchmark179  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchmark179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchmark179	= { FOLLOW_LPAREN_TOK_in_benchmark179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BENCHMARK_TOK_in_benchmark181  */
static	ANTLR3_BITWORD FOLLOW_BENCHMARK_TOK_in_benchmark181_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BENCHMARK_TOK_in_benchmark181	= { FOLLOW_BENCHMARK_TOK_in_benchmark181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_benchmark183  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_benchmark183_bits[]	= { ANTLR3_UINT64_LIT(0x0438000000000180), ANTLR3_UINT64_LIT(0x0000000001000448) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_benchmark183	= { FOLLOW_IDENTIFIER_in_benchmark183_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchAttributes_in_benchmark185  */
static	ANTLR3_BITWORD FOLLOW_benchAttributes_in_benchmark185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_benchAttributes_in_benchmark185	= { FOLLOW_benchAttributes_in_benchmark185_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchmark188  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchmark188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchmark188	= { FOLLOW_RPAREN_TOK_in_benchmark188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_benchmark194  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_benchmark194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_benchmark194	= { FOLLOW_EOF_in_benchmark194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_benchAttribute_in_benchAttributes222  */
static	ANTLR3_BITWORD FOLLOW_benchAttribute_in_benchAttributes222_bits[]	= { ANTLR3_UINT64_LIT(0x0438000000000182), ANTLR3_UINT64_LIT(0x0000000001000448) };
static  ANTLR3_BITSET_LIST FOLLOW_benchAttribute_in_benchAttributes222	= { FOLLOW_benchAttribute_in_benchAttributes222_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LOGIC_TOK_in_benchAttribute259  */
static	ANTLR3_BITWORD FOLLOW_LOGIC_TOK_in_benchAttribute259_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LOGIC_TOK_in_benchAttribute259	= { FOLLOW_LOGIC_TOK_in_benchAttribute259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_benchAttribute261  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_benchAttribute261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_benchAttribute261	= { FOLLOW_identifier_in_benchAttribute261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ASSUMPTION_TOK_in_benchAttribute274  */
static	ANTLR3_BITWORD FOLLOW_ASSUMPTION_TOK_in_benchAttribute274_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_ASSUMPTION_TOK_in_benchAttribute274	= { FOLLOW_ASSUMPTION_TOK_in_benchAttribute274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_benchAttribute276  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_benchAttribute276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_benchAttribute276	= { FOLLOW_annotatedFormula_in_benchAttribute276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORMULA_TOK_in_benchAttribute289  */
static	ANTLR3_BITWORD FOLLOW_FORMULA_TOK_in_benchAttribute289_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_FORMULA_TOK_in_benchAttribute289	= { FOLLOW_FORMULA_TOK_in_benchAttribute289_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_benchAttribute291  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_benchAttribute291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_benchAttribute291	= { FOLLOW_annotatedFormula_in_benchAttribute291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STATUS_TOK_in_benchAttribute304  */
static	ANTLR3_BITWORD FOLLOW_STATUS_TOK_in_benchAttribute304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00000000C0100000) };
static  ANTLR3_BITSET_LIST FOLLOW_STATUS_TOK_in_benchAttribute304	= { FOLLOW_STATUS_TOK_in_benchAttribute304_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_status_in_benchAttribute306  */
static	ANTLR3_BITWORD FOLLOW_status_in_benchAttribute306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_status_in_benchAttribute306	= { FOLLOW_status_in_benchAttribute306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRAFUNS_TOK_in_benchAttribute319  */
static	ANTLR3_BITWORD FOLLOW_EXTRAFUNS_TOK_in_benchAttribute319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRAFUNS_TOK_in_benchAttribute319	= { FOLLOW_EXTRAFUNS_TOK_in_benchAttribute319_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute321  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute321	= { FOLLOW_LPAREN_TOK_in_benchAttribute321_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_benchAttribute335  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_benchAttribute335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080010) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_benchAttribute335	= { FOLLOW_functionDeclaration_in_benchAttribute335_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute353  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute353	= { FOLLOW_RPAREN_TOK_in_benchAttribute353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRAPREDS_TOK_in_benchAttribute367  */
static	ANTLR3_BITWORD FOLLOW_EXTRAPREDS_TOK_in_benchAttribute367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRAPREDS_TOK_in_benchAttribute367	= { FOLLOW_EXTRAPREDS_TOK_in_benchAttribute367_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute369  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute369	= { FOLLOW_LPAREN_TOK_in_benchAttribute369_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateDeclaration_in_benchAttribute383  */
static	ANTLR3_BITWORD FOLLOW_predicateDeclaration_in_benchAttribute383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080010) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateDeclaration_in_benchAttribute383	= { FOLLOW_predicateDeclaration_in_benchAttribute383_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute401  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute401	= { FOLLOW_RPAREN_TOK_in_benchAttribute401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRASORTS_TOK_in_benchAttribute415  */
static	ANTLR3_BITWORD FOLLOW_EXTRASORTS_TOK_in_benchAttribute415_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRASORTS_TOK_in_benchAttribute415	= { FOLLOW_EXTRASORTS_TOK_in_benchAttribute415_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_benchAttribute417  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_benchAttribute417_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_benchAttribute417	= { FOLLOW_LPAREN_TOK_in_benchAttribute417_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortDeclaration_in_benchAttribute433  */
static	ANTLR3_BITWORD FOLLOW_sortDeclaration_in_benchAttribute433_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortDeclaration_in_benchAttribute433	= { FOLLOW_sortDeclaration_in_benchAttribute433_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_benchAttribute451  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_benchAttribute451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_benchAttribute451	= { FOLLOW_RPAREN_TOK_in_benchAttribute451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOTES_TOK_in_benchAttribute465  */
static	ANTLR3_BITWORD FOLLOW_NOTES_TOK_in_benchAttribute465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOTES_TOK_in_benchAttribute465	= { FOLLOW_NOTES_TOK_in_benchAttribute465_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_LITERAL_in_benchAttribute467  */
static	ANTLR3_BITWORD FOLLOW_STRING_LITERAL_in_benchAttribute467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_LITERAL_in_benchAttribute467	= { FOLLOW_STRING_LITERAL_in_benchAttribute467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotation_in_benchAttribute479  */
static	ANTLR3_BITWORD FOLLOW_annotation_in_benchAttribute479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_annotation_in_benchAttribute479	= { FOLLOW_annotation_in_benchAttribute479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula507  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula507_bits[]	= { ANTLR3_UINT64_LIT(0x6800EBFFFFFFC040), ANTLR3_UINT64_LIT(0x0000000412A022A1) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula507	= { FOLLOW_LPAREN_TOK_in_annotatedFormula507_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_builtinOp_in_annotatedFormula509  */
static	ANTLR3_BITWORD FOLLOW_builtinOp_in_annotatedFormula509_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_builtinOp_in_annotatedFormula509	= { FOLLOW_builtinOp_in_annotatedFormula509_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotatedFormula512  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotatedFormula512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotatedFormula512	= { FOLLOW_annotatedFormulas_in_annotatedFormula512_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula525  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula525	= { FOLLOW_termAnnotation_in_annotatedFormula525_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula529  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula529_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula529	= { FOLLOW_RPAREN_TOK_in_annotatedFormula529_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula542  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula542_bits[]	= { ANTLR3_UINT64_LIT(0x0202000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula542	= { FOLLOW_LPAREN_TOK_in_annotatedFormula542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FORALL_TOK_in_annotatedFormula550  */
static	ANTLR3_BITWORD FOLLOW_FORALL_TOK_in_annotatedFormula550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_FORALL_TOK_in_annotatedFormula550	= { FOLLOW_FORALL_TOK_in_annotatedFormula550_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXISTS_TOK_in_annotatedFormula556  */
static	ANTLR3_BITWORD FOLLOW_EXISTS_TOK_in_annotatedFormula556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_EXISTS_TOK_in_annotatedFormula556	= { FOLLOW_EXISTS_TOK_in_annotatedFormula556_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula574  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula574	= { FOLLOW_LPAREN_TOK_in_annotatedFormula574_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula576  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula576_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula576	= { FOLLOW_let_identifier_in_annotatedFormula576_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_annotatedFormula581  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_annotatedFormula581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_annotatedFormula581	= { FOLLOW_sortSymbol_in_annotatedFormula581_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula583  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula583_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula583	= { FOLLOW_RPAREN_TOK_in_annotatedFormula583_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula604  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula604	= { FOLLOW_annotatedFormula_in_annotatedFormula604_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula617  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula617	= { FOLLOW_termAnnotation_in_annotatedFormula617_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula621  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula621	= { FOLLOW_RPAREN_TOK_in_annotatedFormula621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula656  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula656_bits[]	= { ANTLR3_UINT64_LIT(0x1004000000000000), ANTLR3_UINT64_LIT(0x0000000800470000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula656	= { FOLLOW_LPAREN_TOK_in_annotatedFormula656_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_parameterizedOperator_in_annotatedFormula662  */
static	ANTLR3_BITWORD FOLLOW_parameterizedOperator_in_annotatedFormula662_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_parameterizedOperator_in_annotatedFormula662	= { FOLLOW_parameterizedOperator_in_annotatedFormula662_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotatedFormula669  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotatedFormula669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotatedFormula669	= { FOLLOW_annotatedFormulas_in_annotatedFormula669_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula687  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula687	= { FOLLOW_termAnnotation_in_annotatedFormula687_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula691  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula691	= { FOLLOW_RPAREN_TOK_in_annotatedFormula691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula704  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula704_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula704	= { FOLLOW_LPAREN_TOK_in_annotatedFormula704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ITE_TOK_in_annotatedFormula706  */
static	ANTLR3_BITWORD FOLLOW_ITE_TOK_in_annotatedFormula706_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_ITE_TOK_in_annotatedFormula706	= { FOLLOW_ITE_TOK_in_annotatedFormula706_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula712  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula712_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula712	= { FOLLOW_annotatedFormula_in_annotatedFormula712_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula725  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula725_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula725	= { FOLLOW_annotatedFormula_in_annotatedFormula725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula738  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula738	= { FOLLOW_annotatedFormula_in_annotatedFormula738_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula751  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula751	= { FOLLOW_termAnnotation_in_annotatedFormula751_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula755  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula755	= { FOLLOW_RPAREN_TOK_in_annotatedFormula755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula768  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula768_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula768	= { FOLLOW_LPAREN_TOK_in_annotatedFormula768_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_TOK_in_annotatedFormula776  */
static	ANTLR3_BITWORD FOLLOW_LET_TOK_in_annotatedFormula776_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_TOK_in_annotatedFormula776	= { FOLLOW_LET_TOK_in_annotatedFormula776_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula778  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula778_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula778	= { FOLLOW_LPAREN_TOK_in_annotatedFormula778_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula780  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula780_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula780	= { FOLLOW_let_identifier_in_annotatedFormula780_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLET_TOK_in_annotatedFormula791  */
static	ANTLR3_BITWORD FOLLOW_FLET_TOK_in_annotatedFormula791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_FLET_TOK_in_annotatedFormula791	= { FOLLOW_FLET_TOK_in_annotatedFormula791_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_annotatedFormula793  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_annotatedFormula793_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_annotatedFormula793	= { FOLLOW_LPAREN_TOK_in_annotatedFormula793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flet_identifier_in_annotatedFormula795  */
static	ANTLR3_BITWORD FOLLOW_flet_identifier_in_annotatedFormula795_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_flet_identifier_in_annotatedFormula795	= { FOLLOW_flet_identifier_in_annotatedFormula795_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula804  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula804	= { FOLLOW_annotatedFormula_in_annotatedFormula804_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula807  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula807_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula807	= { FOLLOW_RPAREN_TOK_in_annotatedFormula807_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormula819  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormula819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormula819	= { FOLLOW_annotatedFormula_in_annotatedFormula819_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_termAnnotation_in_annotatedFormula826  */
static	ANTLR3_BITWORD FOLLOW_termAnnotation_in_annotatedFormula826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100), ANTLR3_UINT64_LIT(0x0000002000080400) };
static  ANTLR3_BITSET_LIST FOLLOW_termAnnotation_in_annotatedFormula826	= { FOLLOW_termAnnotation_in_annotatedFormula826_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_annotatedFormula830  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_annotatedFormula830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_annotatedFormula830	= { FOLLOW_RPAREN_TOK_in_annotatedFormula830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_TOK_in_annotatedFormula849  */
static	ANTLR3_BITWORD FOLLOW_TRUE_TOK_in_annotatedFormula849_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_TOK_in_annotatedFormula849	= { FOLLOW_TRUE_TOK_in_annotatedFormula849_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_TOK_in_annotatedFormula866  */
static	ANTLR3_BITWORD FOLLOW_FALSE_TOK_in_annotatedFormula866_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_TOK_in_annotatedFormula866	= { FOLLOW_FALSE_TOK_in_annotatedFormula866_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_annotatedFormula882  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_annotatedFormula882_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_annotatedFormula882	= { FOLLOW_NUMERAL_TOK_in_annotatedFormula882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RATIONAL_TOK_in_annotatedFormula894  */
static	ANTLR3_BITWORD FOLLOW_RATIONAL_TOK_in_annotatedFormula894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RATIONAL_TOK_in_annotatedFormula894	= { FOLLOW_RATIONAL_TOK_in_annotatedFormula894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula910  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula910	= { FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula910_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_annotatedFormula912  */
static	ANTLR3_BITWORD FOLLOW_103_in_annotatedFormula912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_annotatedFormula912	= { FOLLOW_103_in_annotatedFormula912_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_annotatedFormula918  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_annotatedFormula918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_annotatedFormula918	= { FOLLOW_NUMERAL_TOK_in_annotatedFormula918_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_annotatedFormula920  */
static	ANTLR3_BITWORD FOLLOW_104_in_annotatedFormula920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_annotatedFormula920	= { FOLLOW_104_in_annotatedFormula920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula936  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula936	= { FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_annotatedFormula968  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_annotatedFormula968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_annotatedFormula968	= { FOLLOW_identifier_in_annotatedFormula968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_let_identifier_in_annotatedFormula979  */
static	ANTLR3_BITWORD FOLLOW_let_identifier_in_annotatedFormula979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_let_identifier_in_annotatedFormula979	= { FOLLOW_let_identifier_in_annotatedFormula979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_flet_identifier_in_annotatedFormula990  */
static	ANTLR3_BITWORD FOLLOW_flet_identifier_in_annotatedFormula990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_flet_identifier_in_annotatedFormula990	= { FOLLOW_flet_identifier_in_annotatedFormula990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormula_in_annotatedFormulas1019  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormula_in_annotatedFormulas1019_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001802), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormula_in_annotatedFormulas1019	= { FOLLOW_annotatedFormula_in_annotatedFormulas1019_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_TOK_in_builtinOp1046  */
static	ANTLR3_BITWORD FOLLOW_NOT_TOK_in_builtinOp1046_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_TOK_in_builtinOp1046	= { FOLLOW_NOT_TOK_in_builtinOp1046_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IMPLIES_TOK_in_builtinOp1059  */
static	ANTLR3_BITWORD FOLLOW_IMPLIES_TOK_in_builtinOp1059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IMPLIES_TOK_in_builtinOp1059	= { FOLLOW_IMPLIES_TOK_in_builtinOp1059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_TOK_in_builtinOp1068  */
static	ANTLR3_BITWORD FOLLOW_AND_TOK_in_builtinOp1068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_TOK_in_builtinOp1068	= { FOLLOW_AND_TOK_in_builtinOp1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_TOK_in_builtinOp1081  */
static	ANTLR3_BITWORD FOLLOW_OR_TOK_in_builtinOp1081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_TOK_in_builtinOp1081	= { FOLLOW_OR_TOK_in_builtinOp1081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_XOR_TOK_in_builtinOp1095  */
static	ANTLR3_BITWORD FOLLOW_XOR_TOK_in_builtinOp1095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_XOR_TOK_in_builtinOp1095	= { FOLLOW_XOR_TOK_in_builtinOp1095_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IFF_TOK_in_builtinOp1108  */
static	ANTLR3_BITWORD FOLLOW_IFF_TOK_in_builtinOp1108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IFF_TOK_in_builtinOp1108	= { FOLLOW_IFF_TOK_in_builtinOp1108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1121  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1121	= { FOLLOW_EQUAL_TOK_in_builtinOp1121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DISTINCT_TOK_in_builtinOp1132  */
static	ANTLR3_BITWORD FOLLOW_DISTINCT_TOK_in_builtinOp1132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DISTINCT_TOK_in_builtinOp1132	= { FOLLOW_DISTINCT_TOK_in_builtinOp1132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_TOK_in_builtinOp1143  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_TOK_in_builtinOp1143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_TOK_in_builtinOp1143	= { FOLLOW_GREATER_THAN_TOK_in_builtinOp1143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GREATER_THAN_TOK_in_builtinOp1168  */
static	ANTLR3_BITWORD FOLLOW_GREATER_THAN_TOK_in_builtinOp1168_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GREATER_THAN_TOK_in_builtinOp1168	= { FOLLOW_GREATER_THAN_TOK_in_builtinOp1168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1170  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1170	= { FOLLOW_EQUAL_TOK_in_builtinOp1170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_TOK_in_builtinOp1195  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_TOK_in_builtinOp1195_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_TOK_in_builtinOp1195	= { FOLLOW_LESS_THAN_TOK_in_builtinOp1195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_TOK_in_builtinOp1197  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_TOK_in_builtinOp1197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_TOK_in_builtinOp1197	= { FOLLOW_EQUAL_TOK_in_builtinOp1197_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LESS_THAN_TOK_in_builtinOp1222  */
static	ANTLR3_BITWORD FOLLOW_LESS_THAN_TOK_in_builtinOp1222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LESS_THAN_TOK_in_builtinOp1222	= { FOLLOW_LESS_THAN_TOK_in_builtinOp1222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PLUS_TOK_in_builtinOp1247  */
static	ANTLR3_BITWORD FOLLOW_PLUS_TOK_in_builtinOp1247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PLUS_TOK_in_builtinOp1247	= { FOLLOW_PLUS_TOK_in_builtinOp1247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_TOK_in_builtinOp1259  */
static	ANTLR3_BITWORD FOLLOW_STAR_TOK_in_builtinOp1259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_TOK_in_builtinOp1259	= { FOLLOW_STAR_TOK_in_builtinOp1259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TILDE_TOK_in_builtinOp1271  */
static	ANTLR3_BITWORD FOLLOW_TILDE_TOK_in_builtinOp1271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TILDE_TOK_in_builtinOp1271	= { FOLLOW_TILDE_TOK_in_builtinOp1271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MINUS_TOK_in_builtinOp1282  */
static	ANTLR3_BITWORD FOLLOW_MINUS_TOK_in_builtinOp1282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MINUS_TOK_in_builtinOp1282	= { FOLLOW_MINUS_TOK_in_builtinOp1282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIV_TOK_in_builtinOp1293  */
static	ANTLR3_BITWORD FOLLOW_DIV_TOK_in_builtinOp1293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIV_TOK_in_builtinOp1293	= { FOLLOW_DIV_TOK_in_builtinOp1293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONCAT_TOK_in_builtinOp1309  */
static	ANTLR3_BITWORD FOLLOW_CONCAT_TOK_in_builtinOp1309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONCAT_TOK_in_builtinOp1309	= { FOLLOW_CONCAT_TOK_in_builtinOp1309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVAND_TOK_in_builtinOp1319  */
static	ANTLR3_BITWORD FOLLOW_BVAND_TOK_in_builtinOp1319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVAND_TOK_in_builtinOp1319	= { FOLLOW_BVAND_TOK_in_builtinOp1319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVOR_TOK_in_builtinOp1330  */
static	ANTLR3_BITWORD FOLLOW_BVOR_TOK_in_builtinOp1330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVOR_TOK_in_builtinOp1330	= { FOLLOW_BVOR_TOK_in_builtinOp1330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXOR_TOK_in_builtinOp1342  */
static	ANTLR3_BITWORD FOLLOW_BVXOR_TOK_in_builtinOp1342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXOR_TOK_in_builtinOp1342	= { FOLLOW_BVXOR_TOK_in_builtinOp1342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNOT_TOK_in_builtinOp1353  */
static	ANTLR3_BITWORD FOLLOW_BVNOT_TOK_in_builtinOp1353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNOT_TOK_in_builtinOp1353	= { FOLLOW_BVNOT_TOK_in_builtinOp1353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNAND_TOK_in_builtinOp1364  */
static	ANTLR3_BITWORD FOLLOW_BVNAND_TOK_in_builtinOp1364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNAND_TOK_in_builtinOp1364	= { FOLLOW_BVNAND_TOK_in_builtinOp1364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNOR_TOK_in_builtinOp1374  */
static	ANTLR3_BITWORD FOLLOW_BVNOR_TOK_in_builtinOp1374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNOR_TOK_in_builtinOp1374	= { FOLLOW_BVNOR_TOK_in_builtinOp1374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVXNOR_TOK_in_builtinOp1385  */
static	ANTLR3_BITWORD FOLLOW_BVXNOR_TOK_in_builtinOp1385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVXNOR_TOK_in_builtinOp1385	= { FOLLOW_BVXNOR_TOK_in_builtinOp1385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVCOMP_TOK_in_builtinOp1395  */
static	ANTLR3_BITWORD FOLLOW_BVCOMP_TOK_in_builtinOp1395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVCOMP_TOK_in_builtinOp1395	= { FOLLOW_BVCOMP_TOK_in_builtinOp1395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVMUL_TOK_in_builtinOp1405  */
static	ANTLR3_BITWORD FOLLOW_BVMUL_TOK_in_builtinOp1405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVMUL_TOK_in_builtinOp1405	= { FOLLOW_BVMUL_TOK_in_builtinOp1405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVADD_TOK_in_builtinOp1416  */
static	ANTLR3_BITWORD FOLLOW_BVADD_TOK_in_builtinOp1416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVADD_TOK_in_builtinOp1416	= { FOLLOW_BVADD_TOK_in_builtinOp1416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSUB_TOK_in_builtinOp1427  */
static	ANTLR3_BITWORD FOLLOW_BVSUB_TOK_in_builtinOp1427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSUB_TOK_in_builtinOp1427	= { FOLLOW_BVSUB_TOK_in_builtinOp1427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVNEG_TOK_in_builtinOp1438  */
static	ANTLR3_BITWORD FOLLOW_BVNEG_TOK_in_builtinOp1438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVNEG_TOK_in_builtinOp1438	= { FOLLOW_BVNEG_TOK_in_builtinOp1438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUDIV_TOK_in_builtinOp1449  */
static	ANTLR3_BITWORD FOLLOW_BVUDIV_TOK_in_builtinOp1449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUDIV_TOK_in_builtinOp1449	= { FOLLOW_BVUDIV_TOK_in_builtinOp1449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUREM_TOK_in_builtinOp1459  */
static	ANTLR3_BITWORD FOLLOW_BVUREM_TOK_in_builtinOp1459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUREM_TOK_in_builtinOp1459	= { FOLLOW_BVUREM_TOK_in_builtinOp1459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSDIV_TOK_in_builtinOp1469  */
static	ANTLR3_BITWORD FOLLOW_BVSDIV_TOK_in_builtinOp1469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSDIV_TOK_in_builtinOp1469	= { FOLLOW_BVSDIV_TOK_in_builtinOp1469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSREM_TOK_in_builtinOp1479  */
static	ANTLR3_BITWORD FOLLOW_BVSREM_TOK_in_builtinOp1479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSREM_TOK_in_builtinOp1479	= { FOLLOW_BVSREM_TOK_in_builtinOp1479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSMOD_TOK_in_builtinOp1489  */
static	ANTLR3_BITWORD FOLLOW_BVSMOD_TOK_in_builtinOp1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSMOD_TOK_in_builtinOp1489	= { FOLLOW_BVSMOD_TOK_in_builtinOp1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSHL_TOK_in_builtinOp1499  */
static	ANTLR3_BITWORD FOLLOW_BVSHL_TOK_in_builtinOp1499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSHL_TOK_in_builtinOp1499	= { FOLLOW_BVSHL_TOK_in_builtinOp1499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVLSHR_TOK_in_builtinOp1510  */
static	ANTLR3_BITWORD FOLLOW_BVLSHR_TOK_in_builtinOp1510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVLSHR_TOK_in_builtinOp1510	= { FOLLOW_BVLSHR_TOK_in_builtinOp1510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVASHR_TOK_in_builtinOp1520  */
static	ANTLR3_BITWORD FOLLOW_BVASHR_TOK_in_builtinOp1520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVASHR_TOK_in_builtinOp1520	= { FOLLOW_BVASHR_TOK_in_builtinOp1520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVULT_TOK_in_builtinOp1530  */
static	ANTLR3_BITWORD FOLLOW_BVULT_TOK_in_builtinOp1530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVULT_TOK_in_builtinOp1530	= { FOLLOW_BVULT_TOK_in_builtinOp1530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVULE_TOK_in_builtinOp1541  */
static	ANTLR3_BITWORD FOLLOW_BVULE_TOK_in_builtinOp1541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVULE_TOK_in_builtinOp1541	= { FOLLOW_BVULE_TOK_in_builtinOp1541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUGT_TOK_in_builtinOp1552  */
static	ANTLR3_BITWORD FOLLOW_BVUGT_TOK_in_builtinOp1552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUGT_TOK_in_builtinOp1552	= { FOLLOW_BVUGT_TOK_in_builtinOp1552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVUGE_TOK_in_builtinOp1563  */
static	ANTLR3_BITWORD FOLLOW_BVUGE_TOK_in_builtinOp1563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVUGE_TOK_in_builtinOp1563	= { FOLLOW_BVUGE_TOK_in_builtinOp1563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLT_TOK_in_builtinOp1574  */
static	ANTLR3_BITWORD FOLLOW_BVSLT_TOK_in_builtinOp1574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLT_TOK_in_builtinOp1574	= { FOLLOW_BVSLT_TOK_in_builtinOp1574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSLE_TOK_in_builtinOp1585  */
static	ANTLR3_BITWORD FOLLOW_BVSLE_TOK_in_builtinOp1585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSLE_TOK_in_builtinOp1585	= { FOLLOW_BVSLE_TOK_in_builtinOp1585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGT_TOK_in_builtinOp1596  */
static	ANTLR3_BITWORD FOLLOW_BVSGT_TOK_in_builtinOp1596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGT_TOK_in_builtinOp1596	= { FOLLOW_BVSGT_TOK_in_builtinOp1596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BVSGE_TOK_in_builtinOp1607  */
static	ANTLR3_BITWORD FOLLOW_BVSGE_TOK_in_builtinOp1607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BVSGE_TOK_in_builtinOp1607	= { FOLLOW_BVSGE_TOK_in_builtinOp1607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SELECT_TOK_in_builtinOp1621  */
static	ANTLR3_BITWORD FOLLOW_SELECT_TOK_in_builtinOp1621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SELECT_TOK_in_builtinOp1621	= { FOLLOW_SELECT_TOK_in_builtinOp1621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STORE_TOK_in_builtinOp1631  */
static	ANTLR3_BITWORD FOLLOW_STORE_TOK_in_builtinOp1631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STORE_TOK_in_builtinOp1631	= { FOLLOW_STORE_TOK_in_builtinOp1631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_parameterizedOperator1655  */
static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_parameterizedOperator1655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_parameterizedOperator1655	= { FOLLOW_functionSymbol_in_parameterizedOperator1655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitVectorOperator_in_parameterizedOperator1662  */
static	ANTLR3_BITWORD FOLLOW_bitVectorOperator_in_parameterizedOperator1662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitVectorOperator_in_parameterizedOperator1662	= { FOLLOW_bitVectorOperator_in_parameterizedOperator1662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EXTRACT_TOK_in_bitVectorOperator1679  */
static	ANTLR3_BITWORD FOLLOW_EXTRACT_TOK_in_bitVectorOperator1679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_EXTRACT_TOK_in_bitVectorOperator1679	= { FOLLOW_EXTRACT_TOK_in_bitVectorOperator1679_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1681  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1681	= { FOLLOW_103_in_bitVectorOperator1681_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1687  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1687	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1687_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_100_in_bitVectorOperator1689  */
static	ANTLR3_BITWORD FOLLOW_100_in_bitVectorOperator1689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_100_in_bitVectorOperator1689	= { FOLLOW_100_in_bitVectorOperator1689_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1695  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1695	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1695_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1697  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1697	= { FOLLOW_104_in_bitVectorOperator1697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPEAT_TOK_in_bitVectorOperator1709  */
static	ANTLR3_BITWORD FOLLOW_REPEAT_TOK_in_bitVectorOperator1709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REPEAT_TOK_in_bitVectorOperator1709	= { FOLLOW_REPEAT_TOK_in_bitVectorOperator1709_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1711  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1711	= { FOLLOW_103_in_bitVectorOperator1711_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1717  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1717	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1717_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1719  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1719	= { FOLLOW_104_in_bitVectorOperator1719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1731  */
static	ANTLR3_BITWORD FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1731	= { FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1731_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1733  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1733	= { FOLLOW_103_in_bitVectorOperator1733_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1739  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1739	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1739_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1741  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1741	= { FOLLOW_104_in_bitVectorOperator1741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1753  */
static	ANTLR3_BITWORD FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1753	= { FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1753_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1755  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1755	= { FOLLOW_103_in_bitVectorOperator1755_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1761  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1761	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1761_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1763  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1763	= { FOLLOW_104_in_bitVectorOperator1763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1775  */
static	ANTLR3_BITWORD FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1775	= { FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1775_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1777  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1777	= { FOLLOW_103_in_bitVectorOperator1777_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1783  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1783	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1783_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1785  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1785	= { FOLLOW_104_in_bitVectorOperator1785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1797  */
static	ANTLR3_BITWORD FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1797	= { FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1797_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_bitVectorOperator1799  */
static	ANTLR3_BITWORD FOLLOW_103_in_bitVectorOperator1799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_bitVectorOperator1799	= { FOLLOW_103_in_bitVectorOperator1799_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_bitVectorOperator1805  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_bitVectorOperator1805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_bitVectorOperator1805	= { FOLLOW_NUMERAL_TOK_in_bitVectorOperator1805_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_bitVectorOperator1807  */
static	ANTLR3_BITWORD FOLLOW_104_in_bitVectorOperator1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_bitVectorOperator1807	= { FOLLOW_104_in_bitVectorOperator1807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_predicateName1830  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_predicateName1830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_predicateName1830	= { FOLLOW_functionName_in_predicateName1830_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_functionName1848  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_functionName1848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_functionName1848	= { FOLLOW_identifier_in_functionName1848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_functionSymbol1870  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_functionSymbol1870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_functionSymbol1870	= { FOLLOW_functionName_in_functionSymbol1870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ATTR_IDENTIFIER_in_attribute1893  */
static	ANTLR3_BITWORD FOLLOW_ATTR_IDENTIFIER_in_attribute1893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ATTR_IDENTIFIER_in_attribute1893	= { FOLLOW_ATTR_IDENTIFIER_in_attribute1893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_functionDeclaration1918  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_functionDeclaration1918_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_functionDeclaration1918	= { FOLLOW_LPAREN_TOK_in_functionDeclaration1918_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionName_in_functionDeclaration1920  */
static	ANTLR3_BITWORD FOLLOW_functionName_in_functionDeclaration1920_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_functionName_in_functionDeclaration1920	= { FOLLOW_functionName_in_functionDeclaration1920_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_functionDeclaration1933  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_functionDeclaration1933_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_functionDeclaration1933	= { FOLLOW_sortSymbol_in_functionDeclaration1933_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_functionDeclaration1948  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_functionDeclaration1948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_functionDeclaration1948	= { FOLLOW_sortList_in_functionDeclaration1948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_functionDeclaration1951  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_functionDeclaration1951_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_functionDeclaration1951	= { FOLLOW_RPAREN_TOK_in_functionDeclaration1951_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAREN_TOK_in_predicateDeclaration1978  */
static	ANTLR3_BITWORD FOLLOW_LPAREN_TOK_in_predicateDeclaration1978_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAREN_TOK_in_predicateDeclaration1978	= { FOLLOW_LPAREN_TOK_in_predicateDeclaration1978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicateName_in_predicateDeclaration1980  */
static	ANTLR3_BITWORD FOLLOW_predicateName_in_predicateDeclaration1980_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002000), ANTLR3_UINT64_LIT(0x0000004000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_predicateName_in_predicateDeclaration1980	= { FOLLOW_predicateName_in_predicateDeclaration1980_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortList_in_predicateDeclaration1983  */
static	ANTLR3_BITWORD FOLLOW_sortList_in_predicateDeclaration1983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortList_in_predicateDeclaration1983	= { FOLLOW_sortList_in_predicateDeclaration1983_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAREN_TOK_in_predicateDeclaration1986  */
static	ANTLR3_BITWORD FOLLOW_RPAREN_TOK_in_predicateDeclaration1986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAREN_TOK_in_predicateDeclaration1986	= { FOLLOW_RPAREN_TOK_in_predicateDeclaration1986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortDeclaration2011  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortDeclaration2011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortDeclaration2011	= { FOLLOW_sortName_in_sortDeclaration2011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortSymbol_in_sortList2040  */
static	ANTLR3_BITWORD FOLLOW_sortSymbol_in_sortList2040_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000002002), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sortSymbol_in_sortList2040	= { FOLLOW_sortSymbol_in_sortList2040_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_identifier_in_sortName2060  */
static	ANTLR3_BITWORD FOLLOW_identifier_in_sortName2060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_identifier_in_sortName2060	= { FOLLOW_identifier_in_sortName2060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sortName_in_sortSymbol2083  */
static	ANTLR3_BITWORD FOLLOW_sortName_in_sortSymbol2083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sortName_in_sortSymbol2083	= { FOLLOW_sortName_in_sortSymbol2083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BITVECTOR_TOK_in_sortSymbol2095  */
static	ANTLR3_BITWORD FOLLOW_BITVECTOR_TOK_in_sortSymbol2095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BITVECTOR_TOK_in_sortSymbol2095	= { FOLLOW_BITVECTOR_TOK_in_sortSymbol2095_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_sortSymbol2097  */
static	ANTLR3_BITWORD FOLLOW_103_in_sortSymbol2097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_103_in_sortSymbol2097	= { FOLLOW_103_in_sortSymbol2097_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2099  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2099	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2099_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_sortSymbol2101  */
static	ANTLR3_BITWORD FOLLOW_104_in_sortSymbol2101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_sortSymbol2101	= { FOLLOW_104_in_sortSymbol2101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_102_in_sortSymbol2113  */
static	ANTLR3_BITWORD FOLLOW_102_in_sortSymbol2113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_102_in_sortSymbol2113	= { FOLLOW_102_in_sortSymbol2113_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2117  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2117	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2117_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_100_in_sortSymbol2119  */
static	ANTLR3_BITWORD FOLLOW_100_in_sortSymbol2119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_100_in_sortSymbol2119	= { FOLLOW_100_in_sortSymbol2119_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMERAL_TOK_in_sortSymbol2123  */
static	ANTLR3_BITWORD FOLLOW_NUMERAL_TOK_in_sortSymbol2123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMERAL_TOK_in_sortSymbol2123	= { FOLLOW_NUMERAL_TOK_in_sortSymbol2123_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_sortSymbol2125  */
static	ANTLR3_BITWORD FOLLOW_104_in_sortSymbol2125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_104_in_sortSymbol2125	= { FOLLOW_104_in_sortSymbol2125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SAT_TOK_in_status2143  */
static	ANTLR3_BITWORD FOLLOW_SAT_TOK_in_status2143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SAT_TOK_in_status2143	= { FOLLOW_SAT_TOK_in_status2143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNSAT_TOK_in_status2157  */
static	ANTLR3_BITWORD FOLLOW_UNSAT_TOK_in_status2157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNSAT_TOK_in_status2157	= { FOLLOW_UNSAT_TOK_in_status2157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNKNOWN_TOK_in_status2169  */
static	ANTLR3_BITWORD FOLLOW_UNKNOWN_TOK_in_status2169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNKNOWN_TOK_in_status2169	= { FOLLOW_UNKNOWN_TOK_in_status2169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2194  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2194_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2194	= { FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2194_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_annotation2206  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_annotation2206_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_annotation2206	= { FOLLOW_annotatedFormulas_in_annotation2206_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_annotation2209  */
static	ANTLR3_BITWORD FOLLOW_105_in_annotation2209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_105_in_annotation2209	= { FOLLOW_105_in_annotation2209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_annotation2215  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_annotation2215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_annotation2215	= { FOLLOW_attribute_in_annotation2215_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userValue_in_annotation2224  */
static	ANTLR3_BITWORD FOLLOW_userValue_in_annotation2224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userValue_in_annotation2224	= { FOLLOW_userValue_in_annotation2224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2268  */
static	ANTLR3_BITWORD FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2268_bits[]	= { ANTLR3_UINT64_LIT(0x10C0000000001800), ANTLR3_UINT64_LIT(0x0000000020008112) };
static  ANTLR3_BITSET_LIST FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2268	= { FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2268_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_annotatedFormulas_in_termAnnotation2270  */
static	ANTLR3_BITWORD FOLLOW_annotatedFormulas_in_termAnnotation2270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_annotatedFormulas_in_termAnnotation2270	= { FOLLOW_annotatedFormulas_in_termAnnotation2270_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_termAnnotation2273  */
static	ANTLR3_BITWORD FOLLOW_105_in_termAnnotation2273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_105_in_termAnnotation2273	= { FOLLOW_105_in_termAnnotation2273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_101_in_termAnnotation2285  */
static	ANTLR3_BITWORD FOLLOW_101_in_termAnnotation2285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_101_in_termAnnotation2285	= { FOLLOW_101_in_termAnnotation2285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_termAnnotation2297  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_termAnnotation2297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_termAnnotation2297	= { FOLLOW_attribute_in_termAnnotation2297_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_userValue_in_termAnnotation2300  */
static	ANTLR3_BITWORD FOLLOW_userValue_in_termAnnotation2300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_userValue_in_termAnnotation2300	= { FOLLOW_userValue_in_termAnnotation2300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_identifier2324  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_identifier2324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_identifier2324	= { FOLLOW_IDENTIFIER_in_identifier2324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LET_IDENTIFIER_in_let_identifier2346  */
static	ANTLR3_BITWORD FOLLOW_LET_IDENTIFIER_in_let_identifier2346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LET_IDENTIFIER_in_let_identifier2346	= { FOLLOW_LET_IDENTIFIER_in_let_identifier2346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FLET_IDENTIFIER_in_flet_identifier2368  */
static	ANTLR3_BITWORD FOLLOW_FLET_IDENTIFIER_in_flet_identifier2368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FLET_IDENTIFIER_in_flet_identifier2368	= { FOLLOW_FLET_IDENTIFIER_in_flet_identifier2368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_USER_VALUE_in_userValue3616  */
static	ANTLR3_BITWORD FOLLOW_USER_VALUE_in_userValue3616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_USER_VALUE_in_userValue3616	= { FOLLOW_USER_VALUE_in_userValue3616_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start parseExpr
 * ../../../../src/parser/smt1/Smt1.g:149:1: parseExpr returns [CVC4::parser::smt1::myExpr expr] : ( annotatedFormula[expr] | EOF );
 */
static CVC4::parser::smt1::myExpr
parseExpr(pSmt1Parser ctx)
{
    CVC4::parser::smt1::myExpr expr;


    /* Initialize rule variables
     */

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:150:3: ( annotatedFormula[expr] | EOF )

            ANTLR3_UINT32 alt1;

            alt1=2;

            switch ( LA(1) )
            {
            case BITVECTOR1_BV_CONST:
            case BITVECTOR_BV_CONST:
            case FALSE_TOK:
            case FLET_IDENTIFIER:
            case IDENTIFIER:
            case LET_IDENTIFIER:
            case LPAREN_TOK:
            case NUMERAL_TOK:
            case RATIONAL_TOK:
            case TRUE_TOK:
            	{
            		alt1=1;
            	}
                break;
            case EOF:
            	{
            		alt1=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 1;
                EXCEPTION->state        = 0;


                goto ruleparseExprEx;

            }

            switch (alt1)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:150:5: annotatedFormula[expr]
        	    {
        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_parseExpr105);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:151:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_parseExpr112);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseExprEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseExprEx; /* Prevent compiler warnings */
    ruleparseExprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return expr;
}
/* $ANTLR end parseExpr */

/**
 * $ANTLR start parseCommand
 * ../../../../src/parser/smt1/Smt1.g:158:1: parseCommand returns [CVC4::Command* cmd_return = NULL] : (b= benchmark[&cmd] | LPAREN_TOK c= IDENTIFIER );
 */
static CVC4::Command*
parseCommand(pSmt1Parser ctx)
{
    CVC4::Command* cmd_return;



      CVC4::PtrCloser<CVC4::Command> cmd;

    pANTLR3_COMMON_TOKEN    c;

    /* Initialize rule variables
     */
    cmd_return =  NULL;


    c       = NULL;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:165:3: (b= benchmark[&cmd] | LPAREN_TOK c= IDENTIFIER )

            ANTLR3_UINT32 alt2;

            alt2=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case BENCHMARK_TOK:
            			{
            				alt2=1;
            			}
            		    break;
            		case IDENTIFIER:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 2;
            		    EXCEPTION->state        = 1;


            		    goto ruleparseCommandEx;

            		}

            	}
                break;
            case EOF:
            	{
            		alt2=1;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleparseCommandEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:165:5: b= benchmark[&cmd]
        	    {
        	        FOLLOWPUSH(FOLLOW_benchmark_in_parseCommand145);
        	        benchmark(ctx, &cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:166:5: LPAREN_TOK c= IDENTIFIER
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_parseCommand152);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        c = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_parseCommand156);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparseCommandEx;
        	        }


        	        {
        	             std::string s = AntlrInput::tokenText(c);
        	                  if(s == "set" || s == "get") {
        	                    PARSER_STATE->parseError(std::string("In SMT-LIBv1 mode, expected keyword `benchmark', but it looks like you're writing SMT-LIBv2.  Use --lang smt for SMT-LIBv2."));
        	                  } else {
        	                    PARSER_STATE->parseError(std::string("expected keyword `benchmark', got `" + s + "'"));
        	                  }
        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparseCommandEx; /* Prevent compiler warnings */
    ruleparseCommandEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd_return = cmd.release();

                }
            }


    return cmd_return;
}
/* $ANTLR end parseCommand */

/**
 * $ANTLR start benchmark
 * ../../../../src/parser/smt1/Smt1.g:180:1: benchmark[CVC4::PtrCloser<CVC4::Command>* cmd] : ( LPAREN_TOK BENCHMARK_TOK IDENTIFIER benchAttributes[cmd] RPAREN_TOK | EOF );
 */
static void
benchmark(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:181:3: ( LPAREN_TOK BENCHMARK_TOK IDENTIFIER benchAttributes[cmd] RPAREN_TOK | EOF )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		alt3=1;
            	}
                break;
            case EOF:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto rulebenchmarkEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:181:5: LPAREN_TOK BENCHMARK_TOK IDENTIFIER benchAttributes[cmd] RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchmark179);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(BENCHMARK_TOK, &FOLLOW_BENCHMARK_TOK_in_benchmark181);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_benchmark183);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_benchAttributes_in_benchmark185);
        	        benchAttributes(ctx, cmd);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchmark188);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:182:5: EOF
        	    {
        	         MATCHT(EOF, &FOLLOW_EOF_in_benchmark194);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchmarkEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebenchmarkEx; /* Prevent compiler warnings */
    rulebenchmarkEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end benchmark */

/**
 * $ANTLR start benchAttributes
 * ../../../../src/parser/smt1/Smt1.g:190:1: benchAttributes[CVC4::PtrCloser<CVC4::Command>* cmd] : ( benchAttribute[&attribute] )+ ;
 */
static void
benchAttributes(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* cmd)
{
    /* Initialize rule variables
     */


      CVC4::PtrCloser<CVC4::CommandSequence> cmd_seq(new CommandSequence());
      CVC4::PtrCloser<CVC4::Command> attribute;

    {
        // ../../../../src/parser/smt1/Smt1.g:198:3: ( ( benchAttribute[&attribute] )+ )
        // ../../../../src/parser/smt1/Smt1.g:198:5: ( benchAttribute[&attribute] )+
        {
            // ../../../../src/parser/smt1/Smt1.g:198:5: ( benchAttribute[&attribute] )+
            {
                int cnt4=0;

                for (;;)
                {
                    int alt4=2;
            	switch ( LA(1) )
            	{
            	case ASSUMPTION_TOK:
            	case ATTR_IDENTIFIER:
            	case EXTRAFUNS_TOK:
            	case EXTRAPREDS_TOK:
            	case EXTRASORTS_TOK:
            	case FORMULA_TOK:
            	case LOGIC_TOK:
            	case NOTES_TOK:
            	case PATTERN_ANNOTATION_BEGIN:
            	case STATUS_TOK:
            		{
            			alt4=1;
            		}
            	    break;

            	}

            	switch (alt4)
            	{
            	    case 1:
            	        // ../../../../src/parser/smt1/Smt1.g:198:6: benchAttribute[&attribute]
            	        {
            	            FOLLOWPUSH(FOLLOW_benchAttribute_in_benchAttributes222);
            	            benchAttribute(ctx, &attribute);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulebenchAttributesEx;
            	            }


            	            {
            	                 if (attribute) cmd_seq->addCommand(attribute.release()); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt4 >= 1 )
            		{
            		    goto loop4;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulebenchAttributesEx;
            	}
            	cnt4++;
                }
                loop4: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebenchAttributesEx; /* Prevent compiler warnings */
    rulebenchAttributesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {

                      cmd->reset(cmd_seq.release());

                }
            }


    return ;
}
/* $ANTLR end benchAttributes */

/**
 * $ANTLR start benchAttribute
 * ../../../../src/parser/smt1/Smt1.g:208:1: benchAttribute[CVC4::PtrCloser<CVC4::Command>* smt_command] : ( LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE] | ASSUMPTION_TOK annotatedFormula[expr] | FORMULA_TOK annotatedFormula[expr] | STATUS_TOK status[b_status] | EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[&declaration_command] )+ RPAREN_TOK | EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[&declaration_command] )+ RPAREN_TOK | EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[&declaration_command] )+ RPAREN_TOK | NOTES_TOK STRING_LITERAL | annotation[smt_command] );
 */
static void
benchAttribute(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command)
{

      std::string name;
      BenchmarkStatus b_status;
      Expr expr;
      CVC4::PtrCloser<CVC4::CommandSequence> command_seq;
      CVC4::PtrCloser<CVC4::Command> declaration_command;

    pANTLR3_COMMON_TOKEN    STRING_LITERAL1;

    /* Initialize rule variables
     */

    STRING_LITERAL1       = NULL;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:216:3: ( LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE] | ASSUMPTION_TOK annotatedFormula[expr] | FORMULA_TOK annotatedFormula[expr] | STATUS_TOK status[b_status] | EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[&declaration_command] )+ RPAREN_TOK | EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[&declaration_command] )+ RPAREN_TOK | EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[&declaration_command] )+ RPAREN_TOK | NOTES_TOK STRING_LITERAL | annotation[smt_command] )

            ANTLR3_UINT32 alt8;

            alt8=9;

            switch ( LA(1) )
            {
            case LOGIC_TOK:
            	{
            		alt8=1;
            	}
                break;
            case ASSUMPTION_TOK:
            	{
            		alt8=2;
            	}
                break;
            case FORMULA_TOK:
            	{
            		alt8=3;
            	}
                break;
            case STATUS_TOK:
            	{
            		alt8=4;
            	}
                break;
            case EXTRAFUNS_TOK:
            	{
            		alt8=5;
            	}
                break;
            case EXTRAPREDS_TOK:
            	{
            		alt8=6;
            	}
                break;
            case EXTRASORTS_TOK:
            	{
            		alt8=7;
            	}
                break;
            case NOTES_TOK:
            	{
            		alt8=8;
            	}
                break;
            case ATTR_IDENTIFIER:
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt8=9;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulebenchAttributeEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:216:5: LOGIC_TOK identifier[name,CHECK_NONE,SYM_VARIABLE]
        	    {
        	         MATCHT(LOGIC_TOK, &FOLLOW_LOGIC_TOK_in_benchAttribute259);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_identifier_in_benchAttribute261);
        	        identifier(ctx, name, CHECK_NONE, SYM_VARIABLE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             PARSER_STATE->preemptCommand(new SetBenchmarkLogicCommand(name));
        	                  PARSER_STATE->setLogic(name);
        	                  smt_command->reset(new EmptyCommand());
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:221:5: ASSUMPTION_TOK annotatedFormula[expr]
        	    {
        	         MATCHT(ASSUMPTION_TOK, &FOLLOW_ASSUMPTION_TOK_in_benchAttribute274);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_benchAttribute276);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(new AssertCommand(expr)); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:223:5: FORMULA_TOK annotatedFormula[expr]
        	    {
        	         MATCHT(FORMULA_TOK, &FOLLOW_FORMULA_TOK_in_benchAttribute289);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_benchAttribute291);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(new CheckSatCommand(expr)); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../src/parser/smt1/Smt1.g:225:5: STATUS_TOK status[b_status]
        	    {
        	         MATCHT(STATUS_TOK, &FOLLOW_STATUS_TOK_in_benchAttribute304);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_status_in_benchAttribute306);
        	        status(ctx, b_status);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(new SetBenchmarkStatusCommand(b_status)); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../src/parser/smt1/Smt1.g:227:5: EXTRAFUNS_TOK LPAREN_TOK ( functionDeclaration[&declaration_command] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRAFUNS_TOK, &FOLLOW_EXTRAFUNS_TOK_in_benchAttribute319);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute321);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             command_seq.reset(new CommandSequence()); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:229:5: ( functionDeclaration[&declaration_command] )+
        	        {
        	            int cnt5=0;

        	            for (;;)
        	            {
        	                int alt5=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt5=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt5)
        	        	{
        	        	    case 1:
        	        	        // ../../../../src/parser/smt1/Smt1.g:229:7: functionDeclaration[&declaration_command]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_functionDeclaration_in_benchAttribute335);
        	        	            functionDeclaration(ctx, &declaration_command);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 command_seq->addCommand(declaration_command.release()); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt5 >= 1 )
        	        		{
        	        		    goto loop5;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt5++;
        	            }
        	            loop5: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute353);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(command_seq.release()); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../src/parser/smt1/Smt1.g:233:5: EXTRAPREDS_TOK LPAREN_TOK ( predicateDeclaration[&declaration_command] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRAPREDS_TOK, &FOLLOW_EXTRAPREDS_TOK_in_benchAttribute367);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute369);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             command_seq.reset(new CommandSequence()); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:235:5: ( predicateDeclaration[&declaration_command] )+
        	        {
        	            int cnt6=0;

        	            for (;;)
        	            {
        	                int alt6=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			alt6=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt6)
        	        	{
        	        	    case 1:
        	        	        // ../../../../src/parser/smt1/Smt1.g:235:7: predicateDeclaration[&declaration_command]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_predicateDeclaration_in_benchAttribute383);
        	        	            predicateDeclaration(ctx, &declaration_command);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 command_seq->addCommand(declaration_command.release()); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt6 >= 1 )
        	        		{
        	        		    goto loop6;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt6++;
        	            }
        	            loop6: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute401);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(command_seq.release()); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../src/parser/smt1/Smt1.g:239:5: EXTRASORTS_TOK LPAREN_TOK ( sortDeclaration[&declaration_command] )+ RPAREN_TOK
        	    {
        	         MATCHT(EXTRASORTS_TOK, &FOLLOW_EXTRASORTS_TOK_in_benchAttribute415);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_benchAttribute417);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             command_seq.reset(new CommandSequence()); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:241:5: ( sortDeclaration[&declaration_command] )+
        	        {
        	            int cnt7=0;

        	            for (;;)
        	            {
        	                int alt7=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt7=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt7)
        	        	{
        	        	    case 1:
        	        	        // ../../../../src/parser/smt1/Smt1.g:241:7: sortDeclaration[&declaration_command]
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_sortDeclaration_in_benchAttribute433);
        	        	            sortDeclaration(ctx, &declaration_command);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulebenchAttributeEx;
        	        	            }


        	        	            {
        	        	                 command_seq->addCommand(declaration_command.release()); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt7 >= 1 )
        	        		{
        	        		    goto loop7;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulebenchAttributeEx;
        	        	}
        	        	cnt7++;
        	            }
        	            loop7: ;	/* Jump to here if this rule does not match */
        	        }

        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_benchAttribute451);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(command_seq.release()); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../src/parser/smt1/Smt1.g:245:5: NOTES_TOK STRING_LITERAL
        	    {
        	         MATCHT(NOTES_TOK, &FOLLOW_NOTES_TOK_in_benchAttribute465);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        STRING_LITERAL1 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING_LITERAL, &FOLLOW_STRING_LITERAL_in_benchAttribute467);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	        {
        	             smt_command->reset(
        	                      new CommentCommand(AntlrInput::tokenText(STRING_LITERAL1))); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../src/parser/smt1/Smt1.g:248:5: annotation[smt_command]
        	    {
        	        FOLLOWPUSH(FOLLOW_annotation_in_benchAttribute479);
        	        annotation(ctx, smt_command);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebenchAttributeEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebenchAttributeEx; /* Prevent compiler warnings */
    rulebenchAttributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end benchAttribute */

/**
 * $ANTLR start annotatedFormula
 * ../../../../src/parser/smt1/Smt1.g:255:1: annotatedFormula[CVC4::Expr& expr] : ( LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | TRUE_TOK | FALSE_TOK | NUMERAL_TOK | RATIONAL_TOK |n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']' |n= BITVECTOR1_BV_CONST | ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] ) );
 */
static void
annotatedFormula(pSmt1Parser ctx, CVC4::Expr& expr)
{
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    size;
    pANTLR3_COMMON_TOKEN    NUMERAL_TOK2;
    pANTLR3_COMMON_TOKEN    RATIONAL_TOK3;
    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */


      Debug("parser") << "annotated formula: " << AntlrInput::tokenText(LT(1)) << std::endl;
      Kind kind;
      std::string name;
      std::vector<Expr> args; /* = getExprVector(); */
      std::vector<Expr> args2;
      Expr op; /* Operator expression FIXME: move away kill it */

    n       = NULL;
    size       = NULL;
    NUMERAL_TOK2       = NULL;
    RATIONAL_TOK3       = NULL;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:264:3: ( LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK | TRUE_TOK | FALSE_TOK | NUMERAL_TOK | RATIONAL_TOK |n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']' |n= BITVECTOR1_BV_CONST | ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] ) )

            ANTLR3_UINT32 alt18;

            alt18=12;

            switch ( LA(1) )
            {
            case LPAREN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case ITE_TOK:
            			{
            				alt18=4;
            			}
            		    break;
            		case AND_TOK:
            		case BVADD_TOK:
            		case BVAND_TOK:
            		case BVASHR_TOK:
            		case BVCOMP_TOK:
            		case BVLSHR_TOK:
            		case BVMUL_TOK:
            		case BVNAND_TOK:
            		case BVNEG_TOK:
            		case BVNOR_TOK:
            		case BVNOT_TOK:
            		case BVOR_TOK:
            		case BVSDIV_TOK:
            		case BVSGE_TOK:
            		case BVSGT_TOK:
            		case BVSHL_TOK:
            		case BVSLE_TOK:
            		case BVSLT_TOK:
            		case BVSMOD_TOK:
            		case BVSREM_TOK:
            		case BVSUB_TOK:
            		case BVUDIV_TOK:
            		case BVUGE_TOK:
            		case BVUGT_TOK:
            		case BVULE_TOK:
            		case BVULT_TOK:
            		case BVUREM_TOK:
            		case BVXNOR_TOK:
            		case BVXOR_TOK:
            		case CONCAT_TOK:
            		case DISTINCT_TOK:
            		case DIV_TOK:
            		case EQUAL_TOK:
            		case GREATER_THAN_TOK:
            		case IFF_TOK:
            		case IMPLIES_TOK:
            		case LESS_THAN_TOK:
            		case MINUS_TOK:
            		case NOT_TOK:
            		case OR_TOK:
            		case PLUS_TOK:
            		case SELECT_TOK:
            		case STAR_TOK:
            		case STORE_TOK:
            		case TILDE_TOK:
            		case XOR_TOK:
            			{
            				alt18=1;
            			}
            		    break;
            		case EXISTS_TOK:
            		case FORALL_TOK:
            			{
            				alt18=2;
            			}
            		    break;
            		case EXTRACT_TOK:
            		case IDENTIFIER:
            		case REPEAT_TOK:
            		case ROTATE_LEFT_TOK:
            		case ROTATE_RIGHT_TOK:
            		case SIGN_EXTEND_TOK:
            		case ZERO_EXTEND_TOK:
            			{
            				alt18=3;
            			}
            		    break;
            		case FLET_TOK:
            		case LET_TOK:
            			{
            				alt18=5;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 18;
            		    EXCEPTION->state        = 1;


            		    goto ruleannotatedFormulaEx;

            		}

            	}
                break;
            case TRUE_TOK:
            	{
            		alt18=6;
            	}
                break;
            case FALSE_TOK:
            	{
            		alt18=7;
            	}
                break;
            case NUMERAL_TOK:
            	{
            		alt18=8;
            	}
                break;
            case RATIONAL_TOK:
            	{
            		alt18=9;
            	}
                break;
            case BITVECTOR_BV_CONST:
            	{
            		alt18=10;
            	}
                break;
            case BITVECTOR1_BV_CONST:
            	{
            		alt18=11;
            	}
                break;
            case FLET_IDENTIFIER:
            case IDENTIFIER:
            case LET_IDENTIFIER:
            	{
            		alt18=12;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 18;
                EXCEPTION->state        = 0;


                goto ruleannotatedFormulaEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:265:5: LPAREN_TOK builtinOp[kind] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula507);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_builtinOp_in_annotatedFormula509);
        	        builtinOp(ctx, kind);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotatedFormula512);
        	        annotatedFormulas(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             if((kind == CVC4::kind::AND || kind == CVC4::kind::OR) && args.size() == 1) {
        	                    /* Unary AND/OR can be replaced with the argument.
        	            	 * It just so happens expr should already be the only argument. */
        	                    assert( expr == args[0] );
        	                  } else if( CVC4::kind::isAssociative(kind) &&
        	                             args.size() > EXPR_MANAGER->maxArity(kind) ) {
        	                	/* Special treatment for associative operators with lots of children */
        	                    expr = EXPR_MANAGER->mkAssociative(kind,args);
        	                  } else if(!PARSER_STATE->strictModeEnabled() &&
        	                            kind == CVC4::kind::MINUS && args.size() == 1) {
        	                    /* Special fix-up for unary minus improperly used in some benchmarks */
        	                    expr = MK_EXPR(CVC4::kind::UMINUS, args[0]);
        	                  } else {
        	                    PARSER_STATE->checkArity(kind, args.size());
        	                    expr = MK_EXPR(kind, args);
        	                  }
        	                
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:283:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:283:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula525);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula529);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:286:5: LPAREN_TOK ( FORALL_TOK | EXISTS_TOK ) ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+ annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula542);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:287:5: ( FORALL_TOK | EXISTS_TOK )
        	        {
        	            int alt10=2;
        	            switch ( LA(1) )
        	            {
        	            case FORALL_TOK:
        	            	{
        	            		alt10=1;
        	            	}
        	                break;
        	            case EXISTS_TOK:
        	            	{
        	            		alt10=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 10;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:287:7: FORALL_TOK
        	        	    {
        	        	         MATCHT(FORALL_TOK, &FOLLOW_FORALL_TOK_in_annotatedFormula550);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        {
        	        	             kind = kind::FORALL; 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../src/parser/smt1/Smt1.g:287:45: EXISTS_TOK
        	        	    {
        	        	         MATCHT(EXISTS_TOK, &FOLLOW_EXISTS_TOK_in_annotatedFormula556);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        {
        	        	             kind = kind::EXISTS; 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->pushScope(); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:289:5: ( LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK )+
        	        {
        	            int cnt11=0;

        	            for (;;)
        	            {
        	                int alt11=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case LPAREN_TOK:
        	        		{
        	        			switch ( LA(2) )
        	        			{
        	        			case LET_IDENTIFIER:
        	        				{
        	        					alt11=1;
        	        				}
        	        			    break;

        	        			}

        	        		}
        	        	    break;

        	        	}

        	        	switch (alt11)
        	        	{
        	        	    case 1:
        	        	        // ../../../../src/parser/smt1/Smt1.g:289:7: LPAREN_TOK let_identifier[name,CHECK_NONE] t= sortSymbol RPAREN_TOK
        	        	        {
        	        	             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula574);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula576);
        	        	            let_identifier(ctx, name, CHECK_NONE);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            FOLLOWPUSH(FOLLOW_sortSymbol_in_annotatedFormula581);
        	        	            t=sortSymbol(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula583);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleannotatedFormulaEx;
        	        	            }


        	        	            {
        	        	                 args.push_back(PARSER_STATE->mkBoundVar(name, t)); 
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt11 >= 1 )
        	        		{
        	        		    goto loop11;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleannotatedFormulaEx;
        	        	}
        	        	cnt11++;
        	            }
        	            loop11: ;	/* Jump to here if this rule does not match */
        	        }

        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula604);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args2.push_back( MK_EXPR( kind::BOUND_VAR_LIST, args ) );
        	                  args2.push_back(expr);
        	                  expr = MK_EXPR(kind, args2);
        	                
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:297:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt12=1;
        	            	}
        	                break;

        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:297:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula617);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop12;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop12: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula621);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:305:5: LPAREN_TOK parameterizedOperator[op] annotatedFormulas[args,expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula656);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_parameterizedOperator_in_annotatedFormula662);
        	        parameterizedOperator(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotatedFormula669);
        	        annotatedFormulas(ctx, args, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_EXPR(op,args); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:310:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt13=1;
        	            	}
        	                break;

        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:310:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula687);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop13;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop13: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula691);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../src/parser/smt1/Smt1.g:313:5: LPAREN_TOK ITE_TOK annotatedFormula[expr] annotatedFormula[expr] annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula704);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(ITE_TOK, &FOLLOW_ITE_TOK_in_annotatedFormula706);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula712);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula725);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula738);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             args.push_back(expr);
        	                  expr = MK_EXPR(CVC4::kind::ITE, args); 
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:321:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt14=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt14=1;
        	            	}
        	                break;

        	            }

        	            switch (alt14)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:321:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula751);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop14;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop14: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula755);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../src/parser/smt1/Smt1.g:324:5: LPAREN_TOK ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] ) annotatedFormula[expr] RPAREN_TOK annotatedFormula[expr] ( termAnnotation[expr] )* RPAREN_TOK
        	    {
        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula768);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:325:5: ( LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED] | FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED] )
        	        {
        	            int alt15=2;
        	            switch ( LA(1) )
        	            {
        	            case LET_TOK:
        	            	{
        	            		alt15=1;
        	            	}
        	                break;
        	            case FLET_TOK:
        	            	{
        	            		alt15=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 15;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt15)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:325:7: LET_TOK LPAREN_TOK let_identifier[name,CHECK_UNDECLARED]
        	        	    {
        	        	         MATCHT(LET_TOK, &FOLLOW_LET_TOK_in_annotatedFormula776);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula778);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula780);
        	        	        let_identifier(ctx, name, CHECK_UNDECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../src/parser/smt1/Smt1.g:326:9: FLET_TOK LPAREN_TOK flet_identifier[name,CHECK_UNDECLARED]
        	        	    {
        	        	         MATCHT(FLET_TOK, &FOLLOW_FLET_TOK_in_annotatedFormula791);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	         MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_annotatedFormula793);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_flet_identifier_in_annotatedFormula795);
        	        	        flet_identifier(ctx, name, CHECK_UNDECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula804);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula807);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->pushScope();
        	                  PARSER_STATE->defineVar(name,expr); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormula819);
        	        annotatedFormula(ctx, expr);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:331:5: ( termAnnotation[expr] )*

        	        for (;;)
        	        {
        	            int alt16=2;
        	            switch ( LA(1) )
        	            {
        	            case ATTR_IDENTIFIER:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case 101:
        	            	{
        	            		alt16=1;
        	            	}
        	                break;

        	            }

        	            switch (alt16)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:331:5: termAnnotation[expr]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_termAnnotation_in_annotatedFormula826);
        	        	        termAnnotation(ctx, expr);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop16;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop16: ; /* Jump out to here if this rule does not match */


        	         MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_annotatedFormula830);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             PARSER_STATE->popScope(); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../src/parser/smt1/Smt1.g:335:5: TRUE_TOK
        	    {
        	         MATCHT(TRUE_TOK, &FOLLOW_TRUE_TOK_in_annotatedFormula849);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST(bool(true)); 
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../src/parser/smt1/Smt1.g:336:5: FALSE_TOK
        	    {
        	         MATCHT(FALSE_TOK, &FOLLOW_FALSE_TOK_in_annotatedFormula866);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST(bool(false)); 
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../src/parser/smt1/Smt1.g:337:5: NUMERAL_TOK
        	    {
        	        NUMERAL_TOK2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_annotatedFormula882);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST( AntlrInput::tokenToInteger(NUMERAL_TOK2) ); 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../src/parser/smt1/Smt1.g:339:5: RATIONAL_TOK
        	    {
        	        RATIONAL_TOK3 = (pANTLR3_COMMON_TOKEN) MATCHT(RATIONAL_TOK, &FOLLOW_RATIONAL_TOK_in_annotatedFormula894);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             // FIXME: This doesn't work because an SMT rational is not a
        	                  // valid GMP rational string
        	                  expr = MK_CONST( AntlrInput::tokenToRational(RATIONAL_TOK3) ); 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../src/parser/smt1/Smt1.g:343:5: n= BITVECTOR_BV_CONST '[' size= NUMERAL_TOK ']'
        	    {
        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(BITVECTOR_BV_CONST, &FOLLOW_BITVECTOR_BV_CONST_in_annotatedFormula910);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_annotatedFormula912);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        size = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_annotatedFormula918);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_annotatedFormula920);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             expr = MK_CONST( AntlrInput::tokenToBitvector(n, size) ); 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../src/parser/smt1/Smt1.g:345:5: n= BITVECTOR1_BV_CONST
        	    {
        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(BITVECTOR1_BV_CONST, &FOLLOW_BITVECTOR1_BV_CONST_in_annotatedFormula936);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotatedFormulaEx;
        	        }


        	        {
        	             unsigned int bit = AntlrInput::tokenText(n)[3] - '0';
        	                  expr = MK_CONST( BitVector(1, bit) );
        	                
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../src/parser/smt1/Smt1.g:353:5: ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] )
        	    {
        	        // ../../../../src/parser/smt1/Smt1.g:353:5: ( identifier[name,CHECK_DECLARED,SYM_VARIABLE] | let_identifier[name,CHECK_DECLARED] | flet_identifier[name,CHECK_DECLARED] )
        	        {
        	            int alt17=3;
        	            switch ( LA(1) )
        	            {
        	            case IDENTIFIER:
        	            	{
        	            		alt17=1;
        	            	}
        	                break;
        	            case LET_IDENTIFIER:
        	            	{
        	            		alt17=2;
        	            	}
        	                break;
        	            case FLET_IDENTIFIER:
        	            	{
        	            		alt17=3;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 17;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotatedFormulaEx;

        	            }

        	            switch (alt17)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:353:7: identifier[name,CHECK_DECLARED,SYM_VARIABLE]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_identifier_in_annotatedFormula968);
        	        	        identifier(ctx, name, CHECK_DECLARED, SYM_VARIABLE);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../src/parser/smt1/Smt1.g:354:9: let_identifier[name,CHECK_DECLARED]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_let_identifier_in_annotatedFormula979);
        	        	        let_identifier(ctx, name, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // ../../../../src/parser/smt1/Smt1.g:355:9: flet_identifier[name,CHECK_DECLARED]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_flet_identifier_in_annotatedFormula990);
        	        	        flet_identifier(ctx, name, CHECK_DECLARED);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotatedFormulaEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             expr = PARSER_STATE->getVariable(name); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleannotatedFormulaEx; /* Prevent compiler warnings */
    ruleannotatedFormulaEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotatedFormula */

/**
 * $ANTLR start annotatedFormulas
 * ../../../../src/parser/smt1/Smt1.g:367:1: annotatedFormulas[std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr] : ( annotatedFormula[expr] )+ ;
 */
static void
annotatedFormulas(pSmt1Parser ctx, std::vector<CVC4::Expr>& formulas, CVC4::Expr& expr)
{
    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:368:3: ( ( annotatedFormula[expr] )+ )
        // ../../../../src/parser/smt1/Smt1.g:368:5: ( annotatedFormula[expr] )+
        {
            // ../../../../src/parser/smt1/Smt1.g:368:5: ( annotatedFormula[expr] )+
            {
                int cnt19=0;

                for (;;)
                {
                    int alt19=2;
            	switch ( LA(1) )
            	{
            	case BITVECTOR1_BV_CONST:
            	case BITVECTOR_BV_CONST:
            	case FALSE_TOK:
            	case FLET_IDENTIFIER:
            	case IDENTIFIER:
            	case LET_IDENTIFIER:
            	case LPAREN_TOK:
            	case NUMERAL_TOK:
            	case RATIONAL_TOK:
            	case TRUE_TOK:
            		{
            			alt19=1;
            		}
            	    break;

            	}

            	switch (alt19)
            	{
            	    case 1:
            	        // ../../../../src/parser/smt1/Smt1.g:368:7: annotatedFormula[expr]
            	        {
            	            FOLLOWPUSH(FOLLOW_annotatedFormula_in_annotatedFormulas1019);
            	            annotatedFormula(ctx, expr);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleannotatedFormulasEx;
            	            }


            	            {
            	                 formulas.push_back(expr); 
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt19 >= 1 )
            		{
            		    goto loop19;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleannotatedFormulasEx;
            	}
            	cnt19++;
                }
                loop19: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleannotatedFormulasEx; /* Prevent compiler warnings */
    ruleannotatedFormulasEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotatedFormulas */

/**
 * $ANTLR start builtinOp
 * ../../../../src/parser/smt1/Smt1.g:374:1: builtinOp[CVC4::Kind& kind] : ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | IFF_TOK | EQUAL_TOK | DISTINCT_TOK | GREATER_THAN_TOK | GREATER_THAN_TOK EQUAL_TOK | LESS_THAN_TOK EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | STAR_TOK | TILDE_TOK | MINUS_TOK | DIV_TOK | CONCAT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | SELECT_TOK | STORE_TOK );
 */
static void
builtinOp(pSmt1Parser ctx, CVC4::Kind& kind)
{
    /* Initialize rule variables
     */


      Debug("parser") << "builtin: " << AntlrInput::tokenText(LT(1)) << std::endl;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:378:3: ( NOT_TOK | IMPLIES_TOK | AND_TOK | OR_TOK | XOR_TOK | IFF_TOK | EQUAL_TOK | DISTINCT_TOK | GREATER_THAN_TOK | GREATER_THAN_TOK EQUAL_TOK | LESS_THAN_TOK EQUAL_TOK | LESS_THAN_TOK | PLUS_TOK | STAR_TOK | TILDE_TOK | MINUS_TOK | DIV_TOK | CONCAT_TOK | BVAND_TOK | BVOR_TOK | BVXOR_TOK | BVNOT_TOK | BVNAND_TOK | BVNOR_TOK | BVXNOR_TOK | BVCOMP_TOK | BVMUL_TOK | BVADD_TOK | BVSUB_TOK | BVNEG_TOK | BVUDIV_TOK | BVUREM_TOK | BVSDIV_TOK | BVSREM_TOK | BVSMOD_TOK | BVSHL_TOK | BVLSHR_TOK | BVASHR_TOK | BVULT_TOK | BVULE_TOK | BVUGT_TOK | BVUGE_TOK | BVSLT_TOK | BVSLE_TOK | BVSGT_TOK | BVSGE_TOK | SELECT_TOK | STORE_TOK )

            ANTLR3_UINT32 alt20;

            alt20=48;

            switch ( LA(1) )
            {
            case NOT_TOK:
            	{
            		alt20=1;
            	}
                break;
            case IMPLIES_TOK:
            	{
            		alt20=2;
            	}
                break;
            case AND_TOK:
            	{
            		alt20=3;
            	}
                break;
            case OR_TOK:
            	{
            		alt20=4;
            	}
                break;
            case XOR_TOK:
            	{
            		alt20=5;
            	}
                break;
            case IFF_TOK:
            	{
            		alt20=6;
            	}
                break;
            case EQUAL_TOK:
            	{
            		alt20=7;
            	}
                break;
            case DISTINCT_TOK:
            	{
            		alt20=8;
            	}
                break;
            case GREATER_THAN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				alt20=10;
            			}
            		    break;
            		case BITVECTOR1_BV_CONST:
            		case BITVECTOR_BV_CONST:
            		case FALSE_TOK:
            		case FLET_IDENTIFIER:
            		case IDENTIFIER:
            		case LET_IDENTIFIER:
            		case LPAREN_TOK:
            		case NUMERAL_TOK:
            		case RATIONAL_TOK:
            		case TRUE_TOK:
            			{
            				alt20=9;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 20;
            		    EXCEPTION->state        = 9;


            		    goto rulebuiltinOpEx;

            		}

            	}
                break;
            case LESS_THAN_TOK:
            	{
            		switch ( LA(2) )
            		{
            		case EQUAL_TOK:
            			{
            				alt20=11;
            			}
            		    break;
            		case BITVECTOR1_BV_CONST:
            		case BITVECTOR_BV_CONST:
            		case FALSE_TOK:
            		case FLET_IDENTIFIER:
            		case IDENTIFIER:
            		case LET_IDENTIFIER:
            		case LPAREN_TOK:
            		case NUMERAL_TOK:
            		case RATIONAL_TOK:
            		case TRUE_TOK:
            			{
            				alt20=12;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 20;
            		    EXCEPTION->state        = 10;


            		    goto rulebuiltinOpEx;

            		}

            	}
                break;
            case PLUS_TOK:
            	{
            		alt20=13;
            	}
                break;
            case STAR_TOK:
            	{
            		alt20=14;
            	}
                break;
            case TILDE_TOK:
            	{
            		alt20=15;
            	}
                break;
            case MINUS_TOK:
            	{
            		alt20=16;
            	}
                break;
            case DIV_TOK:
            	{
            		alt20=17;
            	}
                break;
            case CONCAT_TOK:
            	{
            		alt20=18;
            	}
                break;
            case BVAND_TOK:
            	{
            		alt20=19;
            	}
                break;
            case BVOR_TOK:
            	{
            		alt20=20;
            	}
                break;
            case BVXOR_TOK:
            	{
            		alt20=21;
            	}
                break;
            case BVNOT_TOK:
            	{
            		alt20=22;
            	}
                break;
            case BVNAND_TOK:
            	{
            		alt20=23;
            	}
                break;
            case BVNOR_TOK:
            	{
            		alt20=24;
            	}
                break;
            case BVXNOR_TOK:
            	{
            		alt20=25;
            	}
                break;
            case BVCOMP_TOK:
            	{
            		alt20=26;
            	}
                break;
            case BVMUL_TOK:
            	{
            		alt20=27;
            	}
                break;
            case BVADD_TOK:
            	{
            		alt20=28;
            	}
                break;
            case BVSUB_TOK:
            	{
            		alt20=29;
            	}
                break;
            case BVNEG_TOK:
            	{
            		alt20=30;
            	}
                break;
            case BVUDIV_TOK:
            	{
            		alt20=31;
            	}
                break;
            case BVUREM_TOK:
            	{
            		alt20=32;
            	}
                break;
            case BVSDIV_TOK:
            	{
            		alt20=33;
            	}
                break;
            case BVSREM_TOK:
            	{
            		alt20=34;
            	}
                break;
            case BVSMOD_TOK:
            	{
            		alt20=35;
            	}
                break;
            case BVSHL_TOK:
            	{
            		alt20=36;
            	}
                break;
            case BVLSHR_TOK:
            	{
            		alt20=37;
            	}
                break;
            case BVASHR_TOK:
            	{
            		alt20=38;
            	}
                break;
            case BVULT_TOK:
            	{
            		alt20=39;
            	}
                break;
            case BVULE_TOK:
            	{
            		alt20=40;
            	}
                break;
            case BVUGT_TOK:
            	{
            		alt20=41;
            	}
                break;
            case BVUGE_TOK:
            	{
            		alt20=42;
            	}
                break;
            case BVSLT_TOK:
            	{
            		alt20=43;
            	}
                break;
            case BVSLE_TOK:
            	{
            		alt20=44;
            	}
                break;
            case BVSGT_TOK:
            	{
            		alt20=45;
            	}
                break;
            case BVSGE_TOK:
            	{
            		alt20=46;
            	}
                break;
            case SELECT_TOK:
            	{
            		alt20=47;
            	}
                break;
            case STORE_TOK:
            	{
            		alt20=48;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto rulebuiltinOpEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:378:5: NOT_TOK
        	    {
        	         MATCHT(NOT_TOK, &FOLLOW_NOT_TOK_in_builtinOp1046);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::NOT;     
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:379:5: IMPLIES_TOK
        	    {
        	         MATCHT(IMPLIES_TOK, &FOLLOW_IMPLIES_TOK_in_builtinOp1059);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::IMPLIES; 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:380:5: AND_TOK
        	    {
        	         MATCHT(AND_TOK, &FOLLOW_AND_TOK_in_builtinOp1068);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::AND;     
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../src/parser/smt1/Smt1.g:381:5: OR_TOK
        	    {
        	         MATCHT(OR_TOK, &FOLLOW_OR_TOK_in_builtinOp1081);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::OR;      
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../src/parser/smt1/Smt1.g:382:5: XOR_TOK
        	    {
        	         MATCHT(XOR_TOK, &FOLLOW_XOR_TOK_in_builtinOp1095);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::XOR;     
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../src/parser/smt1/Smt1.g:383:5: IFF_TOK
        	    {
        	         MATCHT(IFF_TOK, &FOLLOW_IFF_TOK_in_builtinOp1108);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::EQUAL;   
        	        }


        	    }
        	    break;
        	case 7:
        	    // ../../../../src/parser/smt1/Smt1.g:384:5: EQUAL_TOK
        	    {
        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1121);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::EQUAL;   
        	        }


        	    }
        	    break;
        	case 8:
        	    // ../../../../src/parser/smt1/Smt1.g:385:5: DISTINCT_TOK
        	    {
        	         MATCHT(DISTINCT_TOK, &FOLLOW_DISTINCT_TOK_in_builtinOp1132);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DISTINCT; 
        	        }


        	    }
        	    break;
        	case 9:
        	    // ../../../../src/parser/smt1/Smt1.g:387:5: GREATER_THAN_TOK
        	    {
        	         MATCHT(GREATER_THAN_TOK, &FOLLOW_GREATER_THAN_TOK_in_builtinOp1143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GT; 
        	        }


        	    }
        	    break;
        	case 10:
        	    // ../../../../src/parser/smt1/Smt1.g:389:5: GREATER_THAN_TOK EQUAL_TOK
        	    {
        	         MATCHT(GREATER_THAN_TOK, &FOLLOW_GREATER_THAN_TOK_in_builtinOp1168);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1170);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::GEQ; 
        	        }


        	    }
        	    break;
        	case 11:
        	    // ../../../../src/parser/smt1/Smt1.g:391:5: LESS_THAN_TOK EQUAL_TOK
        	    {
        	         MATCHT(LESS_THAN_TOK, &FOLLOW_LESS_THAN_TOK_in_builtinOp1195);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	         MATCHT(EQUAL_TOK, &FOLLOW_EQUAL_TOK_in_builtinOp1197);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LEQ; 
        	        }


        	    }
        	    break;
        	case 12:
        	    // ../../../../src/parser/smt1/Smt1.g:393:5: LESS_THAN_TOK
        	    {
        	         MATCHT(LESS_THAN_TOK, &FOLLOW_LESS_THAN_TOK_in_builtinOp1222);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::LT; 
        	        }


        	    }
        	    break;
        	case 13:
        	    // ../../../../src/parser/smt1/Smt1.g:395:5: PLUS_TOK
        	    {
        	         MATCHT(PLUS_TOK, &FOLLOW_PLUS_TOK_in_builtinOp1247);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::PLUS; 
        	        }


        	    }
        	    break;
        	case 14:
        	    // ../../../../src/parser/smt1/Smt1.g:396:5: STAR_TOK
        	    {
        	         MATCHT(STAR_TOK, &FOLLOW_STAR_TOK_in_builtinOp1259);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MULT; 
        	        }


        	    }
        	    break;
        	case 15:
        	    // ../../../../src/parser/smt1/Smt1.g:397:5: TILDE_TOK
        	    {
        	         MATCHT(TILDE_TOK, &FOLLOW_TILDE_TOK_in_builtinOp1271);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::UMINUS; 
        	        }


        	    }
        	    break;
        	case 16:
        	    // ../../../../src/parser/smt1/Smt1.g:398:5: MINUS_TOK
        	    {
        	         MATCHT(MINUS_TOK, &FOLLOW_MINUS_TOK_in_builtinOp1282);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::MINUS; 
        	        }


        	    }
        	    break;
        	case 17:
        	    // ../../../../src/parser/smt1/Smt1.g:399:5: DIV_TOK
        	    {
        	         MATCHT(DIV_TOK, &FOLLOW_DIV_TOK_in_builtinOp1293);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::DIVISION; 
        	        }


        	    }
        	    break;
        	case 18:
        	    // ../../../../src/parser/smt1/Smt1.g:401:5: CONCAT_TOK
        	    {
        	         MATCHT(CONCAT_TOK, &FOLLOW_CONCAT_TOK_in_builtinOp1309);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_CONCAT; 
        	        }


        	    }
        	    break;
        	case 19:
        	    // ../../../../src/parser/smt1/Smt1.g:402:5: BVAND_TOK
        	    {
        	         MATCHT(BVAND_TOK, &FOLLOW_BVAND_TOK_in_builtinOp1319);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_AND;    
        	        }


        	    }
        	    break;
        	case 20:
        	    // ../../../../src/parser/smt1/Smt1.g:403:5: BVOR_TOK
        	    {
        	         MATCHT(BVOR_TOK, &FOLLOW_BVOR_TOK_in_builtinOp1330);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_OR;     
        	        }


        	    }
        	    break;
        	case 21:
        	    // ../../../../src/parser/smt1/Smt1.g:404:5: BVXOR_TOK
        	    {
        	         MATCHT(BVXOR_TOK, &FOLLOW_BVXOR_TOK_in_builtinOp1342);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_XOR;    
        	        }


        	    }
        	    break;
        	case 22:
        	    // ../../../../src/parser/smt1/Smt1.g:405:5: BVNOT_TOK
        	    {
        	         MATCHT(BVNOT_TOK, &FOLLOW_BVNOT_TOK_in_builtinOp1353);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NOT;    
        	        }


        	    }
        	    break;
        	case 23:
        	    // ../../../../src/parser/smt1/Smt1.g:406:5: BVNAND_TOK
        	    {
        	         MATCHT(BVNAND_TOK, &FOLLOW_BVNAND_TOK_in_builtinOp1364);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NAND;   
        	        }


        	    }
        	    break;
        	case 24:
        	    // ../../../../src/parser/smt1/Smt1.g:407:5: BVNOR_TOK
        	    {
        	         MATCHT(BVNOR_TOK, &FOLLOW_BVNOR_TOK_in_builtinOp1374);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NOR;    
        	        }


        	    }
        	    break;
        	case 25:
        	    // ../../../../src/parser/smt1/Smt1.g:408:5: BVXNOR_TOK
        	    {
        	         MATCHT(BVXNOR_TOK, &FOLLOW_BVXNOR_TOK_in_builtinOp1385);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_XNOR;   
        	        }


        	    }
        	    break;
        	case 26:
        	    // ../../../../src/parser/smt1/Smt1.g:409:5: BVCOMP_TOK
        	    {
        	         MATCHT(BVCOMP_TOK, &FOLLOW_BVCOMP_TOK_in_builtinOp1395);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_COMP;   
        	        }


        	    }
        	    break;
        	case 27:
        	    // ../../../../src/parser/smt1/Smt1.g:410:5: BVMUL_TOK
        	    {
        	         MATCHT(BVMUL_TOK, &FOLLOW_BVMUL_TOK_in_builtinOp1405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_MULT;   
        	        }


        	    }
        	    break;
        	case 28:
        	    // ../../../../src/parser/smt1/Smt1.g:411:5: BVADD_TOK
        	    {
        	         MATCHT(BVADD_TOK, &FOLLOW_BVADD_TOK_in_builtinOp1416);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_PLUS;   
        	        }


        	    }
        	    break;
        	case 29:
        	    // ../../../../src/parser/smt1/Smt1.g:412:5: BVSUB_TOK
        	    {
        	         MATCHT(BVSUB_TOK, &FOLLOW_BVSUB_TOK_in_builtinOp1427);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SUB;    
        	        }


        	    }
        	    break;
        	case 30:
        	    // ../../../../src/parser/smt1/Smt1.g:413:5: BVNEG_TOK
        	    {
        	         MATCHT(BVNEG_TOK, &FOLLOW_BVNEG_TOK_in_builtinOp1438);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_NEG;    
        	        }


        	    }
        	    break;
        	case 31:
        	    // ../../../../src/parser/smt1/Smt1.g:414:5: BVUDIV_TOK
        	    {
        	         MATCHT(BVUDIV_TOK, &FOLLOW_BVUDIV_TOK_in_builtinOp1449);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UDIV;   
        	        }


        	    }
        	    break;
        	case 32:
        	    // ../../../../src/parser/smt1/Smt1.g:415:5: BVUREM_TOK
        	    {
        	         MATCHT(BVUREM_TOK, &FOLLOW_BVUREM_TOK_in_builtinOp1459);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UREM;   
        	        }


        	    }
        	    break;
        	case 33:
        	    // ../../../../src/parser/smt1/Smt1.g:416:5: BVSDIV_TOK
        	    {
        	         MATCHT(BVSDIV_TOK, &FOLLOW_BVSDIV_TOK_in_builtinOp1469);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SDIV;   
        	        }


        	    }
        	    break;
        	case 34:
        	    // ../../../../src/parser/smt1/Smt1.g:417:5: BVSREM_TOK
        	    {
        	         MATCHT(BVSREM_TOK, &FOLLOW_BVSREM_TOK_in_builtinOp1479);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SREM;   
        	        }


        	    }
        	    break;
        	case 35:
        	    // ../../../../src/parser/smt1/Smt1.g:418:5: BVSMOD_TOK
        	    {
        	         MATCHT(BVSMOD_TOK, &FOLLOW_BVSMOD_TOK_in_builtinOp1489);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SMOD;   
        	        }


        	    }
        	    break;
        	case 36:
        	    // ../../../../src/parser/smt1/Smt1.g:419:5: BVSHL_TOK
        	    {
        	         MATCHT(BVSHL_TOK, &FOLLOW_BVSHL_TOK_in_builtinOp1499);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SHL;    
        	        }


        	    }
        	    break;
        	case 37:
        	    // ../../../../src/parser/smt1/Smt1.g:420:5: BVLSHR_TOK
        	    {
        	         MATCHT(BVLSHR_TOK, &FOLLOW_BVLSHR_TOK_in_builtinOp1510);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_LSHR;   
        	        }


        	    }
        	    break;
        	case 38:
        	    // ../../../../src/parser/smt1/Smt1.g:421:5: BVASHR_TOK
        	    {
        	         MATCHT(BVASHR_TOK, &FOLLOW_BVASHR_TOK_in_builtinOp1520);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ASHR;   
        	        }


        	    }
        	    break;
        	case 39:
        	    // ../../../../src/parser/smt1/Smt1.g:422:5: BVULT_TOK
        	    {
        	         MATCHT(BVULT_TOK, &FOLLOW_BVULT_TOK_in_builtinOp1530);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ULT;    
        	        }


        	    }
        	    break;
        	case 40:
        	    // ../../../../src/parser/smt1/Smt1.g:423:5: BVULE_TOK
        	    {
        	         MATCHT(BVULE_TOK, &FOLLOW_BVULE_TOK_in_builtinOp1541);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_ULE;    
        	        }


        	    }
        	    break;
        	case 41:
        	    // ../../../../src/parser/smt1/Smt1.g:424:5: BVUGT_TOK
        	    {
        	         MATCHT(BVUGT_TOK, &FOLLOW_BVUGT_TOK_in_builtinOp1552);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UGT;    
        	        }


        	    }
        	    break;
        	case 42:
        	    // ../../../../src/parser/smt1/Smt1.g:425:5: BVUGE_TOK
        	    {
        	         MATCHT(BVUGE_TOK, &FOLLOW_BVUGE_TOK_in_builtinOp1563);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_UGE;    
        	        }


        	    }
        	    break;
        	case 43:
        	    // ../../../../src/parser/smt1/Smt1.g:426:5: BVSLT_TOK
        	    {
        	         MATCHT(BVSLT_TOK, &FOLLOW_BVSLT_TOK_in_builtinOp1574);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SLT;    
        	        }


        	    }
        	    break;
        	case 44:
        	    // ../../../../src/parser/smt1/Smt1.g:427:5: BVSLE_TOK
        	    {
        	         MATCHT(BVSLE_TOK, &FOLLOW_BVSLE_TOK_in_builtinOp1585);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SLE;    
        	        }


        	    }
        	    break;
        	case 45:
        	    // ../../../../src/parser/smt1/Smt1.g:428:5: BVSGT_TOK
        	    {
        	         MATCHT(BVSGT_TOK, &FOLLOW_BVSGT_TOK_in_builtinOp1596);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SGT;    
        	        }


        	    }
        	    break;
        	case 46:
        	    // ../../../../src/parser/smt1/Smt1.g:429:5: BVSGE_TOK
        	    {
        	         MATCHT(BVSGE_TOK, &FOLLOW_BVSGE_TOK_in_builtinOp1607);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::BITVECTOR_SGE;    
        	        }


        	    }
        	    break;
        	case 47:
        	    // ../../../../src/parser/smt1/Smt1.g:431:5: SELECT_TOK
        	    {
        	         MATCHT(SELECT_TOK, &FOLLOW_SELECT_TOK_in_builtinOp1621);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::SELECT; 
        	        }


        	    }
        	    break;
        	case 48:
        	    // ../../../../src/parser/smt1/Smt1.g:432:5: STORE_TOK
        	    {
        	         MATCHT(STORE_TOK, &FOLLOW_STORE_TOK_in_builtinOp1631);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebuiltinOpEx;
        	        }


        	        {
        	             kind= CVC4::kind::STORE; 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebuiltinOpEx; /* Prevent compiler warnings */
    rulebuiltinOpEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end builtinOp */

/**
 * $ANTLR start parameterizedOperator
 * ../../../../src/parser/smt1/Smt1.g:439:1: parameterizedOperator[CVC4::Expr& op] : ( functionSymbol[op] | bitVectorOperator[op] );
 */
static void
parameterizedOperator(pSmt1Parser ctx, CVC4::Expr& op)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:440:3: ( functionSymbol[op] | bitVectorOperator[op] )

            ANTLR3_UINT32 alt21;

            alt21=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt21=1;
            	}
                break;
            case EXTRACT_TOK:
            case REPEAT_TOK:
            case ROTATE_LEFT_TOK:
            case ROTATE_RIGHT_TOK:
            case SIGN_EXTEND_TOK:
            case ZERO_EXTEND_TOK:
            	{
            		alt21=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleparameterizedOperatorEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:440:5: functionSymbol[op]
        	    {
        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_parameterizedOperator1655);
        	        functionSymbol(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparameterizedOperatorEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:441:5: bitVectorOperator[op]
        	    {
        	        FOLLOWPUSH(FOLLOW_bitVectorOperator_in_parameterizedOperator1662);
        	        bitVectorOperator(ctx, op);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleparameterizedOperatorEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleparameterizedOperatorEx; /* Prevent compiler warnings */
    ruleparameterizedOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end parameterizedOperator */

/**
 * $ANTLR start bitVectorOperator
 * ../../../../src/parser/smt1/Smt1.g:447:1: bitVectorOperator[CVC4::Expr& op] : ( EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' | REPEAT_TOK '[' n= NUMERAL_TOK ']' | ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']' | SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']' | ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']' | ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']' );
 */
static void
bitVectorOperator(pSmt1Parser ctx, CVC4::Expr& op)
{
    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    n;

    /* Initialize rule variables
     */

    n1       = NULL;
    n2       = NULL;
    n       = NULL;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:448:3: ( EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' | REPEAT_TOK '[' n= NUMERAL_TOK ']' | ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']' | SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']' | ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']' | ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']' )

            ANTLR3_UINT32 alt22;

            alt22=6;

            switch ( LA(1) )
            {
            case EXTRACT_TOK:
            	{
            		alt22=1;
            	}
                break;
            case REPEAT_TOK:
            	{
            		alt22=2;
            	}
                break;
            case ZERO_EXTEND_TOK:
            	{
            		alt22=3;
            	}
                break;
            case SIGN_EXTEND_TOK:
            	{
            		alt22=4;
            	}
                break;
            case ROTATE_LEFT_TOK:
            	{
            		alt22=5;
            	}
                break;
            case ROTATE_RIGHT_TOK:
            	{
            		alt22=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulebitVectorOperatorEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:448:5: EXTRACT_TOK '[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']'
        	    {
        	         MATCHT(EXTRACT_TOK, &FOLLOW_EXTRACT_TOK_in_bitVectorOperator1679);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1681);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1687);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(100, &FOLLOW_100_in_bitVectorOperator1689);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1695);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1697);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorExtract(AntlrInput::tokenToUnsigned(n1), AntlrInput::tokenToUnsigned(n2))); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:450:5: REPEAT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(REPEAT_TOK, &FOLLOW_REPEAT_TOK_in_bitVectorOperator1709);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1711);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1717);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1719);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRepeat(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:452:5: ZERO_EXTEND_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ZERO_EXTEND_TOK, &FOLLOW_ZERO_EXTEND_TOK_in_bitVectorOperator1731);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1733);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1739);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1741);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorZeroExtend(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 4:
        	    // ../../../../src/parser/smt1/Smt1.g:454:5: SIGN_EXTEND_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(SIGN_EXTEND_TOK, &FOLLOW_SIGN_EXTEND_TOK_in_bitVectorOperator1753);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1755);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1761);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1763);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorSignExtend(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 5:
        	    // ../../../../src/parser/smt1/Smt1.g:456:5: ROTATE_LEFT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ROTATE_LEFT_TOK, &FOLLOW_ROTATE_LEFT_TOK_in_bitVectorOperator1775);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1777);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1783);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1785);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRotateLeft(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;
        	case 6:
        	    // ../../../../src/parser/smt1/Smt1.g:458:5: ROTATE_RIGHT_TOK '[' n= NUMERAL_TOK ']'
        	    {
        	         MATCHT(ROTATE_RIGHT_TOK, &FOLLOW_ROTATE_RIGHT_TOK_in_bitVectorOperator1797);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_bitVectorOperator1799);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        n = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_bitVectorOperator1805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_bitVectorOperator1807);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitVectorOperatorEx;
        	        }


        	        {
        	             op = MK_CONST(BitVectorRotateRight(AntlrInput::tokenToUnsigned(n))); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebitVectorOperatorEx; /* Prevent compiler warnings */
    rulebitVectorOperatorEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end bitVectorOperator */

/**
 * $ANTLR start predicateName
 * ../../../../src/parser/smt1/Smt1.g:466:1: predicateName[std::string& name, CVC4::parser::DeclarationCheck check] : functionName[name,check] ;
 */
static void
predicateName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:467:3: ( functionName[name,check] )
        // ../../../../src/parser/smt1/Smt1.g:467:6: functionName[name,check]
        {
            FOLLOWPUSH(FOLLOW_functionName_in_predicateName1830);
            functionName(ctx, name, check);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepredicateNameEx; /* Prevent compiler warnings */
    rulepredicateNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end predicateName */

/**
 * $ANTLR start functionName
 * ../../../../src/parser/smt1/Smt1.g:474:1: functionName[std::string& name, CVC4::parser::DeclarationCheck check] : identifier[name,check,SYM_VARIABLE] ;
 */
static void
functionName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:475:3: ( identifier[name,check,SYM_VARIABLE] )
        // ../../../../src/parser/smt1/Smt1.g:475:6: identifier[name,check,SYM_VARIABLE]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_functionName1848);
            identifier(ctx, name, check, SYM_VARIABLE);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionNameEx; /* Prevent compiler warnings */
    rulefunctionNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionName */

/**
 * $ANTLR start functionSymbol
 * ../../../../src/parser/smt1/Smt1.g:481:1: functionSymbol[CVC4::Expr& fun] : functionName[name,CHECK_DECLARED] ;
 */
static void
functionSymbol(pSmt1Parser ctx, CVC4::Expr& fun)
{

    	std::string name;

    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:485:3: ( functionName[name,CHECK_DECLARED] )
        // ../../../../src/parser/smt1/Smt1.g:485:5: functionName[name,CHECK_DECLARED]
        {
            FOLLOWPUSH(FOLLOW_functionName_in_functionSymbol1870);
            functionName(ctx, name, CHECK_DECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionSymbolEx;
            }


            {
                 PARSER_STATE->checkFunctionLike(name);
                      fun = PARSER_STATE->getVariable(name); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionSymbolEx; /* Prevent compiler warnings */
    rulefunctionSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionSymbol */

/**
 * $ANTLR start attribute
 * ../../../../src/parser/smt1/Smt1.g:493:1: attribute[std::string& s] : ATTR_IDENTIFIER ;
 */
static void
attribute(pSmt1Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    ATTR_IDENTIFIER4;

    /* Initialize rule variables
     */

    ATTR_IDENTIFIER4       = NULL;

    {
        // ../../../../src/parser/smt1/Smt1.g:494:3: ( ATTR_IDENTIFIER )
        // ../../../../src/parser/smt1/Smt1.g:494:5: ATTR_IDENTIFIER
        {
            ATTR_IDENTIFIER4 = (pANTLR3_COMMON_TOKEN) MATCHT(ATTR_IDENTIFIER, &FOLLOW_ATTR_IDENTIFIER_in_attribute1893);
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }


            {
                 s = AntlrInput::tokenText(ATTR_IDENTIFIER4); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start functionDeclaration
 * ../../../../src/parser/smt1/Smt1.g:498:1: functionDeclaration[CVC4::PtrCloser<CVC4::Command>* smt_command] : LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK ;
 */
static void
functionDeclaration(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command)
{

      std::string name;
      std::vector<Type> sorts;

    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:503:3: ( LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK )
        // ../../../../src/parser/smt1/Smt1.g:503:5: LPAREN_TOK functionName[name,CHECK_UNDECLARED] t= sortSymbol sortList[sorts] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_functionDeclaration1918);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_functionName_in_functionDeclaration1920);
            functionName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_sortSymbol_in_functionDeclaration1933);
            t=sortSymbol(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            {
                 sorts.push_back(t); 
            }


            FOLLOWPUSH(FOLLOW_sortList_in_functionDeclaration1948);
            sortList(ctx, sorts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_functionDeclaration1951);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            {
                 if( sorts.size() == 1 ) {
                        assert( t == sorts[0] );
                      } else {
                        t = EXPR_MANAGER->mkFunctionType(sorts);
                      }
                      Expr func = PARSER_STATE->mkVar(name, t);
                      smt_command->reset(new DeclareFunctionCommand(name, func, t));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start predicateDeclaration
 * ../../../../src/parser/smt1/Smt1.g:520:1: predicateDeclaration[CVC4::PtrCloser<CVC4::Command>* smt_command] : LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK ;
 */
static void
predicateDeclaration(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command)
{

      std::string name;
      std::vector<Type> p_sorts;

    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:525:3: ( LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK )
        // ../../../../src/parser/smt1/Smt1.g:525:5: LPAREN_TOK predicateName[name,CHECK_UNDECLARED] sortList[p_sorts] RPAREN_TOK
        {
             MATCHT(LPAREN_TOK, &FOLLOW_LPAREN_TOK_in_predicateDeclaration1978);
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_predicateName_in_predicateDeclaration1980);
            predicateName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_sortList_in_predicateDeclaration1983);
            sortList(ctx, p_sorts);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


             MATCHT(RPAREN_TOK, &FOLLOW_RPAREN_TOK_in_predicateDeclaration1986);
            if  (HASEXCEPTION())
            {
                goto rulepredicateDeclarationEx;
            }


            {
                 Type t;
                      if( p_sorts.empty() ) {
                        t = EXPR_MANAGER->booleanType();
                      } else {
                        t = EXPR_MANAGER->mkPredicateType(p_sorts);
                      }
                      Expr func = PARSER_STATE->mkVar(name, t);
                      smt_command->reset(new DeclareFunctionCommand(name, func, t));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepredicateDeclarationEx; /* Prevent compiler warnings */
    rulepredicateDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end predicateDeclaration */

/**
 * $ANTLR start sortDeclaration
 * ../../../../src/parser/smt1/Smt1.g:537:1: sortDeclaration[CVC4::PtrCloser<CVC4::Command>* smt_command] : sortName[name,CHECK_UNDECLARED] ;
 */
static void
sortDeclaration(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command)
{

      std::string name;

    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:541:3: ( sortName[name,CHECK_UNDECLARED] )
        // ../../../../src/parser/smt1/Smt1.g:541:5: sortName[name,CHECK_UNDECLARED]
        {
            FOLLOWPUSH(FOLLOW_sortName_in_sortDeclaration2011);
            sortName(ctx, name, CHECK_UNDECLARED);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortDeclarationEx;
            }


            {
                 Debug("parser") << "sort decl: '" << name << "'" << std::endl;
                      Type type = PARSER_STATE->mkSort(name);
                      smt_command->reset(new DeclareTypeCommand(name, 0, type));
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortDeclarationEx; /* Prevent compiler warnings */
    rulesortDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortDeclaration */

/**
 * $ANTLR start sortList
 * ../../../../src/parser/smt1/Smt1.g:551:1: sortList[std::vector<CVC4::Type>& sorts] : (t= sortSymbol )* ;
 */
static void
sortList(pSmt1Parser ctx, std::vector<CVC4::Type>& sorts)
{
    CVC4::parser::smt1::myType t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t CVC4::parser::smt1::myType

    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:552:3: ( (t= sortSymbol )* )
        // ../../../../src/parser/smt1/Smt1.g:552:5: (t= sortSymbol )*
        {
            // ../../../../src/parser/smt1/Smt1.g:552:5: (t= sortSymbol )*

            for (;;)
            {
                int alt23=2;
                switch ( LA(1) )
                {
                case BITVECTOR_TOK:
                case IDENTIFIER:
                case 102:
                	{
                		alt23=1;
                	}
                    break;

                }

                switch (alt23)
                {
            	case 1:
            	    // ../../../../src/parser/smt1/Smt1.g:552:7: t= sortSymbol
            	    {
            	        FOLLOWPUSH(FOLLOW_sortSymbol_in_sortList2040);
            	        t=sortSymbol(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesortListEx;
            	        }


            	        {
            	             sorts.push_back(t); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop23;	/* break out of the loop */
            	    break;
                }
            }
            loop23: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortListEx; /* Prevent compiler warnings */
    rulesortListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortList */

/**
 * $ANTLR start sortName
 * ../../../../src/parser/smt1/Smt1.g:559:1: sortName[std::string& name, CVC4::parser::DeclarationCheck check] : identifier[name,check,SYM_SORT] ;
 */
static void
sortName(pSmt1Parser ctx, std::string& name, CVC4::parser::DeclarationCheck check)
{
    /* Initialize rule variables
     */

    {
        // ../../../../src/parser/smt1/Smt1.g:560:3: ( identifier[name,check,SYM_SORT] )
        // ../../../../src/parser/smt1/Smt1.g:560:5: identifier[name,check,SYM_SORT]
        {
            FOLLOWPUSH(FOLLOW_identifier_in_sortName2060);
            identifier(ctx, name, check, SYM_SORT);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesortNameEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesortNameEx; /* Prevent compiler warnings */
    rulesortNameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end sortName */

/**
 * $ANTLR start sortSymbol
 * ../../../../src/parser/smt1/Smt1.g:563:1: sortSymbol returns [CVC4::parser::smt1::myType t] : ( sortName[name,CHECK_NONE] | BITVECTOR_TOK '[' NUMERAL_TOK ']' | 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' );
 */
static CVC4::parser::smt1::myType
sortSymbol(pSmt1Parser ctx)
{
    CVC4::parser::smt1::myType t;



      std::string name;

    pANTLR3_COMMON_TOKEN    n1;
    pANTLR3_COMMON_TOKEN    n2;
    pANTLR3_COMMON_TOKEN    NUMERAL_TOK5;

    /* Initialize rule variables
     */

    n1       = NULL;
    n2       = NULL;
    NUMERAL_TOK5       = NULL;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:567:3: ( sortName[name,CHECK_NONE] | BITVECTOR_TOK '[' NUMERAL_TOK ']' | 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']' )

            ANTLR3_UINT32 alt24;

            alt24=3;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt24=1;
            	}
                break;
            case BITVECTOR_TOK:
            	{
            		alt24=2;
            	}
                break;
            case 102:
            	{
            		alt24=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto rulesortSymbolEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:567:5: sortName[name,CHECK_NONE]
        	    {
        	        FOLLOWPUSH(FOLLOW_sortName_in_sortSymbol2083);
        	        sortName(ctx, name, CHECK_NONE);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {
        	             t= PARSER_STATE->getSort(name);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:569:5: BITVECTOR_TOK '[' NUMERAL_TOK ']'
        	    {
        	         MATCHT(BITVECTOR_TOK, &FOLLOW_BITVECTOR_TOK_in_sortSymbol2095);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(103, &FOLLOW_103_in_sortSymbol2097);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        NUMERAL_TOK5 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2099);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_sortSymbol2101);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	              	t= EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(NUMERAL_TOK5));

        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:574:5: 'Array[' n1= NUMERAL_TOK ':' n2= NUMERAL_TOK ']'
        	    {
        	         MATCHT(102, &FOLLOW_102_in_sortSymbol2113);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        n1 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2117);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(100, &FOLLOW_100_in_sortSymbol2119);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        n2 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMERAL_TOK, &FOLLOW_NUMERAL_TOK_in_sortSymbol2123);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	         MATCHT(104, &FOLLOW_104_in_sortSymbol2125);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesortSymbolEx;
        	        }


        	        {

        	                    t= EXPR_MANAGER->mkArrayType(EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(n1)),
        	                                                   EXPR_MANAGER->mkBitVectorType(AntlrInput::tokenToUnsigned(n2)));

        	                
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulesortSymbolEx; /* Prevent compiler warnings */
    rulesortSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return t;
}
/* $ANTLR end sortSymbol */

/**
 * $ANTLR start status
 * ../../../../src/parser/smt1/Smt1.g:583:1: status[ CVC4::BenchmarkStatus& status ] : ( SAT_TOK | UNSAT_TOK | UNKNOWN_TOK );
 */
static void
status(pSmt1Parser ctx, CVC4::BenchmarkStatus& status)
{
    /* Initialize rule variables
     */

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:584:3: ( SAT_TOK | UNSAT_TOK | UNKNOWN_TOK )

            ANTLR3_UINT32 alt25;

            alt25=3;

            switch ( LA(1) )
            {
            case SAT_TOK:
            	{
            		alt25=1;
            	}
                break;
            case UNSAT_TOK:
            	{
            		alt25=2;
            	}
                break;
            case UNKNOWN_TOK:
            	{
            		alt25=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 25;
                EXCEPTION->state        = 0;


                goto rulestatusEx;

            }

            switch (alt25)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:584:5: SAT_TOK
        	    {
        	         MATCHT(SAT_TOK, &FOLLOW_SAT_TOK_in_status2143);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_SATISFIABLE;    
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:585:5: UNSAT_TOK
        	    {
        	         MATCHT(UNSAT_TOK, &FOLLOW_UNSAT_TOK_in_status2157);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_UNSATISFIABLE;  
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:586:5: UNKNOWN_TOK
        	    {
        	         MATCHT(UNKNOWN_TOK, &FOLLOW_UNKNOWN_TOK_in_status2169);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatusEx;
        	        }


        	        {
        	             status= SMT_UNKNOWN;        
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatusEx; /* Prevent compiler warnings */
    rulestatusEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end status */

/**
 * $ANTLR start annotation
 * ../../../../src/parser/smt1/Smt1.g:593:1: annotation[CVC4::PtrCloser<CVC4::Command>* smt_command] : ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | attribute[key] ( userValue[value] |) );
 */
static void
annotation(pSmt1Parser ctx, CVC4::PtrCloser<CVC4::Command>* smt_command)
{
    /* Initialize rule variables
     */


      std::string key, value;
      std::vector<Expr> pats;
      Expr pat;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:599:3: ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | attribute[key] ( userValue[value] |) )

            ANTLR3_UINT32 alt27;

            alt27=2;

            switch ( LA(1) )
            {
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt27=1;
            	}
                break;
            case ATTR_IDENTIFIER:
            	{
            		alt27=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 27;
                EXCEPTION->state        = 0;


                goto ruleannotationEx;

            }

            switch (alt27)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:599:5: PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}'
        	    {
        	         MATCHT(PATTERN_ANNOTATION_BEGIN, &FOLLOW_PATTERN_ANNOTATION_BEGIN_in_annotation2194);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	        {
        	             PARSER_STATE->warning(":pat not supported here; ignored"); 
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_annotation2206);
        	        annotatedFormulas(ctx, pats, pat);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	         MATCHT(105, &FOLLOW_105_in_annotation2209);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:602:5: attribute[key] ( userValue[value] |)
        	    {
        	        FOLLOWPUSH(FOLLOW_attribute_in_annotation2215);
        	        attribute(ctx, key);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleannotationEx;
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:603:5: ( userValue[value] |)
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	            case USER_VALUE:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;
        	            case ASSUMPTION_TOK:
        	            case ATTR_IDENTIFIER:
        	            case EXTRAFUNS_TOK:
        	            case EXTRAPREDS_TOK:
        	            case EXTRASORTS_TOK:
        	            case FORMULA_TOK:
        	            case LOGIC_TOK:
        	            case NOTES_TOK:
        	            case PATTERN_ANNOTATION_BEGIN:
        	            case RPAREN_TOK:
        	            case STATUS_TOK:
        	            	{
        	            		alt26=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 26;
        	                EXCEPTION->state        = 0;


        	                goto ruleannotationEx;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:603:7: userValue[value]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_userValue_in_annotation2224);
        	        	        userValue(ctx, value);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleannotationEx;
        	        	        }


        	        	        {
        	        	             smt_command->reset(
        	        	                        new SetInfoCommand(key.c_str() + 1, SExpr(value))); 
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // ../../../../src/parser/smt1/Smt1.g:606:7: 
        	        	    {
        	        	        {
        	        	             smt_command->reset(
        	        	                        new EmptyCommand(std::string("annotation: ") + key)); 
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleannotationEx; /* Prevent compiler warnings */
    ruleannotationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end annotation */

/**
 * $ANTLR start termAnnotation
 * ../../../../src/parser/smt1/Smt1.g:615:1: termAnnotation[CVC4::Expr& expr] : ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | ':pat' | attribute[key] ( userValue[value] )? );
 */
static void
termAnnotation(pSmt1Parser ctx, CVC4::Expr& expr)
{
    /* Initialize rule variables
     */


      std::string key, value;
      std::vector<Expr> pats;
      Expr pat;

    {
        {
            //  ../../../../src/parser/smt1/Smt1.g:621:3: ( PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}' | ':pat' | attribute[key] ( userValue[value] )? )

            ANTLR3_UINT32 alt29;

            alt29=3;

            switch ( LA(1) )
            {
            case PATTERN_ANNOTATION_BEGIN:
            	{
            		alt29=1;
            	}
                break;
            case 101:
            	{
            		alt29=2;
            	}
                break;
            case ATTR_IDENTIFIER:
            	{
            		alt29=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruletermAnnotationEx;

            }

            switch (alt29)
            {
        	case 1:
        	    // ../../../../src/parser/smt1/Smt1.g:621:5: PATTERN_ANNOTATION_BEGIN annotatedFormulas[pats,pat] '}'
        	    {
        	         MATCHT(PATTERN_ANNOTATION_BEGIN, &FOLLOW_PATTERN_ANNOTATION_BEGIN_in_termAnnotation2268);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_annotatedFormulas_in_termAnnotation2270);
        	        annotatedFormulas(ctx, pats, pat);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	         MATCHT(105, &FOLLOW_105_in_termAnnotation2273);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        {
        	             if(expr.getKind() == kind::FORALL || expr.getKind() == kind::EXISTS) {
        	                    pat = MK_EXPR(kind::INST_PATTERN, pats);
        	                    if(expr.getNumChildren() == 3) {
        	                      // we have other user patterns attached to the quantifier
        	                      // already; add this one to the existing list
        	                      pats = expr[2].getChildren();
        	                      pats.push_back(pat);
        	                      expr = MK_EXPR(expr.getKind(), expr[0], expr[1], MK_EXPR(kind::INST_PATTERN_LIST, pats));
        	                    } else {
        	                      // this is the only user pattern for the quantifier
        	                      expr = MK_EXPR(expr.getKind(), expr[0], expr[1], MK_EXPR(kind::INST_PATTERN_LIST, pat));
        	                    }
        	                  } else {
        	                    PARSER_STATE->warning(":pat only supported on quantifiers");
        	                  }
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // ../../../../src/parser/smt1/Smt1.g:638:5: ':pat'
        	    {
        	         MATCHT(101, &FOLLOW_101_in_termAnnotation2285);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        {
        	             PARSER_STATE->warning("expected an instantiation pattern after :pat"); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // ../../../../src/parser/smt1/Smt1.g:640:5: attribute[key] ( userValue[value] )?
        	    {
        	        FOLLOWPUSH(FOLLOW_attribute_in_termAnnotation2297);
        	        attribute(ctx, key);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletermAnnotationEx;
        	        }


        	        // ../../../../src/parser/smt1/Smt1.g:640:20: ( userValue[value] )?
        	        {
        	            int alt28=2;
        	            switch ( LA(1) )
        	            {
        	                case USER_VALUE:
        	                	{
        	                		alt28=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // ../../../../src/parser/smt1/Smt1.g:640:20: userValue[value]
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_userValue_in_termAnnotation2300);
        	        	        userValue(ctx, value);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletermAnnotationEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {
        	             PARSER_STATE->attributeNotSupported(key); 
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletermAnnotationEx; /* Prevent compiler warnings */
    ruletermAnnotationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end termAnnotation */

/**
 * $ANTLR start identifier
 * ../../../../src/parser/smt1/Smt1.g:650:1: identifier[std::string& id,\n\t\t CVC4::parser::DeclarationCheck check,\n CVC4::parser::SymbolType type] : IDENTIFIER ;
 */
static void
identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check, CVC4::parser::SymbolType type)
{
    pANTLR3_COMMON_TOKEN    IDENTIFIER6;

    /* Initialize rule variables
     */

    IDENTIFIER6       = NULL;

    {
        // ../../../../src/parser/smt1/Smt1.g:653:3: ( IDENTIFIER )
        // ../../../../src/parser/smt1/Smt1.g:653:5: IDENTIFIER
        {
            IDENTIFIER6 = (pANTLR3_COMMON_TOKEN) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_identifier2324);
            if  (HASEXCEPTION())
            {
                goto ruleidentifierEx;
            }


            {
                 id = AntlrInput::tokenText(IDENTIFIER6);
                      Debug("parser") << "identifier: " << id
                                      << " check? " << check
                                      << " type? " << type << std::endl;
                      PARSER_STATE->checkDeclaration(id, check, type); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleidentifierEx; /* Prevent compiler warnings */
    ruleidentifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end identifier */

/**
 * $ANTLR start let_identifier
 * ../../../../src/parser/smt1/Smt1.g:666:1: let_identifier[std::string& id,\n \t\t CVC4::parser::DeclarationCheck check] : LET_IDENTIFIER ;
 */
static void
let_identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check)
{
    pANTLR3_COMMON_TOKEN    LET_IDENTIFIER7;

    /* Initialize rule variables
     */

    LET_IDENTIFIER7       = NULL;

    {
        // ../../../../src/parser/smt1/Smt1.g:668:3: ( LET_IDENTIFIER )
        // ../../../../src/parser/smt1/Smt1.g:668:5: LET_IDENTIFIER
        {
            LET_IDENTIFIER7 = (pANTLR3_COMMON_TOKEN) MATCHT(LET_IDENTIFIER, &FOLLOW_LET_IDENTIFIER_in_let_identifier2346);
            if  (HASEXCEPTION())
            {
                goto rulelet_identifierEx;
            }


            {
                 id = AntlrInput::tokenText(LET_IDENTIFIER7);
                      Debug("parser") << "let_identifier: " << id
                                      << " check? " << check << std::endl;
                      PARSER_STATE->checkDeclaration(id, check, SYM_VARIABLE); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelet_identifierEx; /* Prevent compiler warnings */
    rulelet_identifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end let_identifier */

/**
 * $ANTLR start flet_identifier
 * ../../../../src/parser/smt1/Smt1.g:680:1: flet_identifier[std::string& id,\n \t\t CVC4::parser::DeclarationCheck check] : FLET_IDENTIFIER ;
 */
static void
flet_identifier(pSmt1Parser ctx, std::string& id, CVC4::parser::DeclarationCheck check)
{
    pANTLR3_COMMON_TOKEN    FLET_IDENTIFIER8;

    /* Initialize rule variables
     */

    FLET_IDENTIFIER8       = NULL;

    {
        // ../../../../src/parser/smt1/Smt1.g:682:3: ( FLET_IDENTIFIER )
        // ../../../../src/parser/smt1/Smt1.g:682:5: FLET_IDENTIFIER
        {
            FLET_IDENTIFIER8 = (pANTLR3_COMMON_TOKEN) MATCHT(FLET_IDENTIFIER, &FOLLOW_FLET_IDENTIFIER_in_flet_identifier2368);
            if  (HASEXCEPTION())
            {
                goto ruleflet_identifierEx;
            }


            {
                 id = AntlrInput::tokenText(FLET_IDENTIFIER8);
                      Debug("parser") << "flet_identifier: " << id
                                      << " check? " << check << std::endl;
                      PARSER_STATE->checkDeclaration(id, check); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleflet_identifierEx; /* Prevent compiler warnings */
    ruleflet_identifierEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end flet_identifier */

/**
 * $ANTLR start userValue
 * ../../../../src/parser/smt1/Smt1.g:824:1: userValue[std::string& s] : USER_VALUE ;
 */
static void
userValue(pSmt1Parser ctx, std::string& s)
{
    pANTLR3_COMMON_TOKEN    USER_VALUE9;

    /* Initialize rule variables
     */

    USER_VALUE9       = NULL;

    {
        // ../../../../src/parser/smt1/Smt1.g:825:3: ( USER_VALUE )
        // ../../../../src/parser/smt1/Smt1.g:825:5: USER_VALUE
        {
            USER_VALUE9 = (pANTLR3_COMMON_TOKEN) MATCHT(USER_VALUE, &FOLLOW_USER_VALUE_in_userValue3616);
            if  (HASEXCEPTION())
            {
                goto ruleuserValueEx;
            }


            {
                 s = AntlrInput::tokenText(USER_VALUE9);
                      assert(*s.begin() == '{');
                      assert(*s.rbegin() == '}');
                      // trim whitespace
                      s.erase(s.begin(), s.begin() + 1);
                      s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                      s.erase(s.end() - 1);
                      s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuserValueEx; /* Prevent compiler warnings */
    ruleuserValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end userValue */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
