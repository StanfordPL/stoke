<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Fast Buffering APIs</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Fast Buffering APIs</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a> )(BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BUFFER_ID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">LEVEL_PINCLIENT::PIN_DefineTraceBuffer</a> (size_t recordSize, UINT32 numPages, <a class="el" href="group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b">TRACE_BUFFER_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g13114277f4e96e1975a3a93898c12238">LEVEL_PINCLIENT::PIN_AllocateBuffer</a> (BUFFER_ID id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#ga15b74f066828e4a53cf4e985f247c8c">LEVEL_PINCLIENT::PIN_DeallocateBuffer</a> (BUFFER_ID id, VOID *buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BUFFER__API.html#g1f4f970d91ae257131d0fccabf3e009b">LEVEL_PINCLIENT::PIN_GetBufferPointer</a> (<a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *const ctxt, BUFFER_ID id)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
APIs to perform low-overhead buffering of data for analysis. Use <a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer()</a> to create space for storing data, and <a class="el" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer()</a> to fill the buffers. When a buffer overflows, or the thread exits, the defined callback will be used to process the data. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g2f6bf0657fdea122fa71bd8ff95d9e9b"></a><!-- doxytag: member="LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK" ref="g2f6bf0657fdea122fa71bd8ff95d9e9b" args=")(BUFFER_ID id, THREADID tid, const CONTEXT *ctxt, VOID *buf, UINT64 numElements, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID*(* <a class="el" href="group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b">LEVEL_PINCLIENT::TRACE_BUFFER_CALLBACK</a>)(BUFFER_ID id, <a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *buf, UINT64 numElements, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A call-back function which Pin calls whenever the tools needs to consume a trace buffer (e.g., the trace buffer is full).<p>
<dl compact><dt><b>Note:</b></dt><dd>This function may be called on a different thread than the given threadIndex.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The ID of the thread owning this buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the start of the buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numElements</em>&nbsp;</td><td>The number of elements collected into the buffer which need to be consumed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the buffer to use when the thread resumes. Typically, this is <em>buf</em>, but see also <a class="el" href="group__BUFFER__API.html#g13114277f4e96e1975a3a93898c12238">PIN_AllocateBuffer()</a>. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g13114277f4e96e1975a3a93898c12238"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AllocateBuffer" ref="g13114277f4e96e1975a3a93898c12238" args="(BUFFER_ID id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID* LEVEL_PINCLIENT::PIN_AllocateBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">BUFFER_ID&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>id</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Explicitly allocate a trace buffer. This is only needed for tools which use a "double buffering" technique. When used, the buffer pointer should be returned from the TRACE_BUFFER_CALLBACK call-back.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer to allocate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the new buffer.]</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15b74f066828e4a53cf4e985f247c8c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DeallocateBuffer" ref="ga15b74f066828e4a53cf4e985f247c8c" args="(BUFFER_ID id, VOID *buf)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_DeallocateBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">BUFFER_ID&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Explicitly deallocate a trace buffer. This is only needed by tools using a "double buffering" technique, where it is used to deallocate buffers allocated via <a class="el" href="group__BUFFER__API.html#g13114277f4e96e1975a3a93898c12238">PIN_AllocateBuffer()</a>. However, it may be safely called (with no effect) for a thread's implicit initial buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Pointer to the start of the buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g16f88ae475a2539bfec3c7ce8b9eb16e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DefineTraceBuffer" ref="g16f88ae475a2539bfec3c7ce8b9eb16e" args="(size_t recordSize, UINT32 numPages, TRACE_BUFFER_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BUFFER_ID LEVEL_PINCLIENT::PIN_DefineTraceBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>recordSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UINT32&nbsp;</td>
          <td class="mdname" nowrap> <em>numPages</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__BUFFER__API.html#g2f6bf0657fdea122fa71bd8ff95d9e9b">TRACE_BUFFER_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Define a trace buffer to use with the Pin trace buffer API. This function defines the shape of the buffer, but doesn't allocate the buffer itself. Each thread implicitly creates its first buffer on start-up. Additional buffers may then be created using <a class="el" href="group__BUFFER__API.html#g13114277f4e96e1975a3a93898c12238">PIN_AllocateBuffer</a>, but this is only needed by tools using "double buffering".<p>
Upon exit, the notification callback may be called on a different physical thread than the one that is exiting.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>recordSize</em>&nbsp;</td><td>Size (bytes) of each record in the buffer. This size must be less than the size of an OS page. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numPages</em>&nbsp;</td><td>The number of OS pages to allocate for each buffer. This size does not have to be an even multiple of <em>recordSize</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>A call-back function that is called whenever the buffer is full, or when the thread exits with a partially-full buffer. Note that when called for a full buffer, not during thread exit, this function is called WITHOUT holding any Pin locks. So that multiple threads may be executing the function simultaneously. It is the tool's responsibility to take care of the multi-thread safety of this function, and any functions called by it. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Passed as the last argument to <em>fun</em>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On success, a BUFFER_ID. On error (e.g., maximum number of trace buffers exceeded,) returns BUFFER_ID_INVALID.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g1f4f970d91ae257131d0fccabf3e009b"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_GetBufferPointer" ref="g1f4f970d91ae257131d0fccabf3e009b" args="(CONTEXT *const ctxt, BUFFER_ID id)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID* LEVEL_PINCLIENT::PIN_GetBufferPointer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *const &nbsp;</td>
          <td class="mdname" nowrap> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BUFFER_ID&nbsp;</td>
          <td class="mdname" nowrap> <em>id</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the address of the current position in the buffer. Needs a CONTEXT that was passed in as a call back argument or IARG_CONTEXT<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>id</em>&nbsp;</td><td>The ID of the trace buffer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>CONTEXT</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Dec 26 02:10:27 2013 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
